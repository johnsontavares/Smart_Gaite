{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\nimport { PrimaryColumnCannotBeNullableError } from \"../../error/PrimaryColumnCannotBeNullableError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\n\nexport function PrimaryColumn(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    var type;\n\n    if (typeof typeOrOptions === \"string\") {\n      type = typeOrOptions;\n    } else {\n      options = Object.assign({}, typeOrOptions);\n    }\n\n    if (!options) options = {}; // if type is not given explicitly then try to guess it\n\n    var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType) type = reflectMetadataType; // check if there is no type in column options then set type from first function argument, or guessed one\n\n    if (!options.type && type) options.type = type; // if we still don't have a type then we need to give error to user that type is required\n\n    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName); // check if column is not nullable, because we cannot allow a primary key to be nullable\n\n    if (options.nullable) throw new PrimaryColumnCannotBeNullableError(object, propertyName); // explicitly set a primary to column options\n\n    options.primary = true; // create and register a new column metadata\n\n    getMetadataArgsStorage().columns.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: \"regular\",\n      options: options\n    });\n\n    if (options.generated) {\n      getMetadataArgsStorage().generations.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n      });\n    }\n  };\n}","map":{"version":3,"sources":["../browser/src/decorator/columns/PrimaryColumn.ts"],"names":[],"mappings":"AAAA,SAAmC,sBAAnC,QAAgE,QAAhE;AACA,SAAQ,wBAAR,QAAuC,sCAAvC;AACA,SAAQ,kCAAR,QAAiD,gDAAjD;AAwBA;;;;AAIG;;AACH,OAAM,SAAU,aAAV,CAAwB,aAAxB,EAAyE,OAAzE,EAAuG;AACzG,SAAO,UAAU,MAAV,EAA0B,YAA1B,EAA8C;AAEjD;AACA,QAAI,IAAJ;;AACA,QAAI,OAAO,aAAP,KAAyB,QAA7B,EAAuC;AACnC,MAAA,IAAI,GAAG,aAAP;AACH,KAFD,MAEO;AACH,MAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAyC,aAAzC,CAAV;AACH;;AACD,QAAI,CAAC,OAAL,EAAc,OAAO,GAAG,EAAV,CATmC,CAWjD;;AACA,QAAM,mBAAmB,GAAG,OAAO,IAAK,OAAe,CAAC,WAA5B,GAA2C,OAAe,CAAC,WAAhB,CAA4B,aAA5B,EAA2C,MAA3C,EAAmD,YAAnD,CAA3C,GAA8G,SAA1I;AACA,QAAI,CAAC,IAAD,IAAS,mBAAb,EACI,IAAI,GAAG,mBAAP,CAd6C,CAgBjD;;AACA,QAAI,CAAC,OAAO,CAAC,IAAT,IAAiB,IAArB,EACI,OAAO,CAAC,IAAR,GAAe,IAAf,CAlB6C,CAoBjD;;AACA,QAAI,CAAC,OAAO,CAAC,IAAb,EACI,MAAM,IAAI,wBAAJ,CAA6B,MAA7B,EAAqC,YAArC,CAAN,CAtB6C,CAwBjD;;AACA,QAAI,OAAO,CAAC,QAAZ,EACI,MAAM,IAAI,kCAAJ,CAAuC,MAAvC,EAA+C,YAA/C,CAAN,CA1B6C,CA4BjD;;AACA,IAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB,CA7BiD,CA+BjD;;AACA,IAAA,sBAAsB,GAAG,OAAzB,CAAiC,IAAjC,CAAsC;AAClC,MAAA,MAAM,EAAE,MAAM,CAAC,WADmB;AAElC,MAAA,YAAY,EAAE,YAFoB;AAGlC,MAAA,IAAI,EAAE,SAH4B;AAIlC,MAAA,OAAO,EAAE;AAJyB,KAAtC;;AAOA,QAAI,OAAO,CAAC,SAAZ,EAAuB;AACnB,MAAA,sBAAsB,GAAG,WAAzB,CAAqC,IAArC,CAA0C;AACtC,QAAA,MAAM,EAAE,MAAM,CAAC,WADuB;AAEtC,QAAA,YAAY,EAAE,YAFwB;AAGtC,QAAA,QAAQ,EAAE,OAAO,OAAO,CAAC,SAAf,KAA6B,QAA7B,GAAwC,OAAO,CAAC,SAAhD,GAA4D;AAHhC,OAA1C;AAKH;AACJ,GA9CD;AA+CH","sourcesContent":["import {ColumnOptions, ColumnType, getMetadataArgsStorage} from \"../../\";\nimport {ColumnTypeUndefinedError} from \"../../error/ColumnTypeUndefinedError\";\nimport {PrimaryColumnCannotBeNullableError} from \"../../error/PrimaryColumnCannotBeNullableError\";\nimport {ColumnMetadataArgs} from \"../../metadata-args/ColumnMetadataArgs\";\nimport {GeneratedMetadataArgs} from \"../../metadata-args/GeneratedMetadataArgs\";\n\n/**\n * Describes all primary key column's options.\n * If specified, the nullable field must be set to false.\n */\nexport type PrimaryColumnOptions = ColumnOptions & { nullable?: false };\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(options?: PrimaryColumnOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(type?: ColumnType, options?: PrimaryColumnOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(typeOrOptions?: ColumnType|PrimaryColumnOptions, options?: PrimaryColumnOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n\n        // normalize parameters\n        let type: ColumnType|undefined;\n        if (typeof typeOrOptions === \"string\") {\n            type = typeOrOptions;\n        } else {\n            options = Object.assign({}, <PrimaryColumnOptions> typeOrOptions);\n        }\n        if (!options) options = {} as PrimaryColumnOptions;\n\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType = Reflect && (Reflect as any).getMetadata ? (Reflect as any).getMetadata(\"design:type\", object, propertyName) : undefined;\n        if (!type && reflectMetadataType)\n            type = reflectMetadataType;\n\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type)\n            options.type = type;\n\n        // if we still don't have a type then we need to give error to user that type is required\n        if (!options.type)\n            throw new ColumnTypeUndefinedError(object, propertyName);\n\n        // check if column is not nullable, because we cannot allow a primary key to be nullable\n        if (options.nullable)\n            throw new PrimaryColumnCannotBeNullableError(object, propertyName);\n\n        // explicitly set a primary to column options\n        options.primary = true;\n\n        // create and register a new column metadata\n        getMetadataArgsStorage().columns.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            mode: \"regular\",\n            options: options\n        } as ColumnMetadataArgs);\n\n        if (options.generated) {\n            getMetadataArgsStorage().generations.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n            } as GeneratedMetadataArgs);\n        }\n    };\n}\n\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}