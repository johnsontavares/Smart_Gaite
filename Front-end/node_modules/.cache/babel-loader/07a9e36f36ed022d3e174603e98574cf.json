{"ast":null,"code":"import { FindRelationsNotFoundError } from \"../error/FindRelationsNotFoundError\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Utilities to work with FindOptions.\n */\n\nvar FindOptionsUtils =\n/** @class */\nfunction () {\n  function FindOptionsUtils() {} // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if given object is really instance of FindOneOptions interface.\n   */\n\n\n  FindOptionsUtils.isFindOneOptions = function (obj) {\n    var possibleOptions = obj;\n    return possibleOptions && (Array.isArray(possibleOptions.select) || possibleOptions.where instanceof Object || typeof possibleOptions.where === \"string\" || Array.isArray(possibleOptions.relations) || possibleOptions.join instanceof Object || possibleOptions.order instanceof Object || possibleOptions.cache instanceof Object || typeof possibleOptions.cache === \"boolean\" || typeof possibleOptions.cache === \"number\" || possibleOptions.lock instanceof Object || possibleOptions.loadRelationIds instanceof Object || typeof possibleOptions.loadRelationIds === \"boolean\" || typeof possibleOptions.loadEagerRelations === \"boolean\" || typeof possibleOptions.withDeleted === \"boolean\" || typeof possibleOptions.transaction === \"boolean\");\n  };\n  /**\n   * Checks if given object is really instance of FindManyOptions interface.\n   */\n\n\n  FindOptionsUtils.isFindManyOptions = function (obj) {\n    var possibleOptions = obj;\n    return possibleOptions && (this.isFindOneOptions(possibleOptions) || typeof possibleOptions.skip === \"number\" || typeof possibleOptions.take === \"number\" || typeof possibleOptions.skip === \"string\" || typeof possibleOptions.take === \"string\");\n  };\n  /**\n   * Checks if given object is really instance of FindOptions interface.\n   */\n\n\n  FindOptionsUtils.extractFindManyOptionsAlias = function (object) {\n    if (this.isFindManyOptions(object) && object.join) return object.join.alias;\n    return undefined;\n  };\n  /**\n   * Applies give find many options to the given query builder.\n   */\n\n\n  FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder = function (qb, options) {\n    if (this.isFindManyOptions(options)) return this.applyOptionsToQueryBuilder(qb, options);\n    if (options) return qb.where(options);\n    return qb;\n  };\n  /**\n   * Applies give find options to the given query builder.\n   */\n\n\n  FindOptionsUtils.applyOptionsToQueryBuilder = function (qb, options) {\n    // if options are not set then simply return query builder. This is made for simplicity of usage.\n    if (!options || !this.isFindOneOptions(options) && !this.isFindManyOptions(options)) return qb;\n\n    if (options.transaction === true) {\n      qb.expressionMap.useTransaction = true;\n    }\n\n    if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata) return qb;\n    var metadata = qb.expressionMap.mainAlias.metadata; // apply all options from FindOptions\n\n    if (options.select) {\n      qb.select([]);\n      options.select.forEach(function (select) {\n        if (!metadata.findColumnWithPropertyPath(String(select))) throw new Error(select + \" column was not found in the \" + metadata.name + \" entity.\");\n        qb.addSelect(qb.alias + \".\" + select);\n      });\n    }\n\n    if (options.where) qb.where(options.where);\n    if (options.skip) qb.skip(options.skip);\n    if (options.take) qb.take(options.take);\n    if (options.order) Object.keys(options.order).forEach(function (key) {\n      var order = options.order[key];\n      if (!metadata.findColumnWithPropertyPath(key)) throw new Error(key + \" column was not found in the \" + metadata.name + \" entity.\");\n\n      switch (order) {\n        case 1:\n          qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n          break;\n\n        case -1:\n          qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n          break;\n\n        case \"ASC\":\n          qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n          break;\n\n        case \"DESC\":\n          qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n          break;\n      }\n    });\n\n    if (options.relations) {\n      var allRelations = options.relations.map(function (relation) {\n        return relation;\n      });\n      this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, \"\"); // recursive removes found relations from allRelations array\n      // if there are relations left in this array it means those relations were not found in the entity structure\n      // so, we give an exception about not found relations\n\n      if (allRelations.length > 0) throw new FindRelationsNotFoundError(allRelations);\n    }\n\n    if (options.join) {\n      if (options.join.leftJoin) Object.keys(options.join.leftJoin).forEach(function (key) {\n        qb.leftJoin(options.join.leftJoin[key], key);\n      });\n      if (options.join.innerJoin) Object.keys(options.join.innerJoin).forEach(function (key) {\n        qb.innerJoin(options.join.innerJoin[key], key);\n      });\n      if (options.join.leftJoinAndSelect) Object.keys(options.join.leftJoinAndSelect).forEach(function (key) {\n        qb.leftJoinAndSelect(options.join.leftJoinAndSelect[key], key);\n      });\n      if (options.join.innerJoinAndSelect) Object.keys(options.join.innerJoinAndSelect).forEach(function (key) {\n        qb.innerJoinAndSelect(options.join.innerJoinAndSelect[key], key);\n      });\n    }\n\n    if (options.cache) {\n      if (options.cache instanceof Object) {\n        var cache = options.cache;\n        qb.cache(cache.id, cache.milliseconds);\n      } else {\n        qb.cache(options.cache);\n      }\n    }\n\n    if (options.lock) {\n      if (options.lock.mode === \"optimistic\") {\n        qb.setLock(options.lock.mode, options.lock.version);\n      } else if (options.lock.mode === \"pessimistic_read\" || options.lock.mode === \"pessimistic_write\" || options.lock.mode === \"dirty_read\" || options.lock.mode === \"pessimistic_partial_write\" || options.lock.mode === \"pessimistic_write_or_fail\") {\n        var tableNames = options.lock.tables ? options.lock.tables.map(function (table) {\n          var tableAlias = qb.expressionMap.aliases.find(function (alias) {\n            return alias.metadata.tableNameWithoutPrefix === table;\n          });\n\n          if (!tableAlias) {\n            throw new Error(\"\\\"\" + table + \"\\\" is not part of this query\");\n          }\n\n          return qb.escape(tableAlias.name);\n        }) : undefined;\n        qb.setLock(options.lock.mode, undefined, tableNames);\n      }\n    }\n\n    if (options.withDeleted) {\n      qb.withDeleted();\n    }\n\n    if (options.loadRelationIds === true) {\n      qb.loadAllRelationIds();\n    } else if (options.loadRelationIds instanceof Object) {\n      qb.loadAllRelationIds(options.loadRelationIds);\n    }\n\n    return qb;\n  }; // -------------------------------------------------------------------------\n  // Protected Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n   */\n\n\n  FindOptionsUtils.applyRelationsRecursively = function (qb, allRelations, alias, metadata, prefix) {\n    var _this = this; // find all relations that match given prefix\n\n\n    var matchedBaseRelations = [];\n\n    if (prefix) {\n      var regexp_1 = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\");\n      matchedBaseRelations = allRelations.filter(function (relation) {\n        return relation.match(regexp_1);\n      }).map(function (relation) {\n        return relation.replace(regexp_1, \"\");\n      }).filter(function (relation) {\n        return metadata.findRelationWithPropertyPath(relation);\n      });\n    } else {\n      matchedBaseRelations = allRelations.filter(function (relation) {\n        return metadata.findRelationWithPropertyPath(relation);\n      });\n    } // go through all matched relations and add join for them\n\n\n    matchedBaseRelations.forEach(function (relation) {\n      // generate a relation alias\n      var relationAlias = DriverUtils.buildAlias(qb.connection.driver, {\n        shorten: true,\n        joiner: \"__\"\n      }, alias, relation); // add a join for the found relation\n\n      var selection = alias + \".\" + relation;\n      qb.leftJoinAndSelect(selection, relationAlias); // join the eager relations of the found relation\n\n      var relMetadata = metadata.relations.find(function (metadata) {\n        return metadata.propertyName === relation;\n      });\n\n      if (relMetadata) {\n        _this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);\n      } // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n\n\n      allRelations.splice(allRelations.indexOf(prefix ? prefix + \".\" + relation : relation), 1); // try to find sub-relations\n\n      var join = qb.expressionMap.joinAttributes.find(function (join) {\n        return join.entityOrProperty === selection;\n      });\n\n      _this.applyRelationsRecursively(qb, allRelations, join.alias.name, join.metadata, prefix ? prefix + \".\" + relation : relation);\n    });\n  };\n\n  FindOptionsUtils.joinEagerRelations = function (qb, alias, metadata) {\n    var _this = this;\n\n    metadata.eagerRelations.forEach(function (relation) {\n      // generate a relation alias\n      var relationAlias = DriverUtils.buildAlias(qb.connection.driver, {\n        shorten: true\n      }, qb.connection.namingStrategy.eagerJoinRelationAlias(alias, relation.propertyPath)); // add a join for the relation\n\n      qb.leftJoinAndSelect(alias + \".\" + relation.propertyPath, relationAlias); // (recursive) join the eager relations\n\n      _this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);\n    });\n  };\n\n  return FindOptionsUtils;\n}();\n\nexport { FindOptionsUtils };","map":{"version":3,"sources":["../browser/src/find-options/FindOptionsUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import {FindManyOptions} from \"./FindManyOptions\";\nimport {FindOneOptions} from \"./FindOneOptions\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {FindRelationsNotFoundError} from \"../error/FindRelationsNotFoundError\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {DriverUtils} from \"../driver/DriverUtils\";\n\n/**\n * Utilities to work with FindOptions.\n */\nexport class FindOptionsUtils {\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if given object is really instance of FindOneOptions interface.\n     */\n    static isFindOneOptions<Entity = any>(obj: any): obj is FindOneOptions<Entity> {\n        const possibleOptions: FindOneOptions<Entity> = obj;\n        return possibleOptions &&\n                (\n                    Array.isArray(possibleOptions.select) ||\n                    possibleOptions.where instanceof Object ||\n                    typeof possibleOptions.where === \"string\" ||\n                    Array.isArray(possibleOptions.relations) ||\n                    possibleOptions.join instanceof Object ||\n                    possibleOptions.order instanceof Object ||\n                    possibleOptions.cache instanceof Object ||\n                    typeof possibleOptions.cache === \"boolean\" ||\n                    typeof possibleOptions.cache === \"number\" ||\n                    possibleOptions.lock instanceof Object ||\n                    possibleOptions.loadRelationIds instanceof Object ||\n                    typeof possibleOptions.loadRelationIds === \"boolean\" ||\n                    typeof possibleOptions.loadEagerRelations === \"boolean\" ||\n                    typeof possibleOptions.withDeleted === \"boolean\" ||\n                    typeof possibleOptions.transaction === \"boolean\"\n                );\n    }\n\n    /**\n     * Checks if given object is really instance of FindManyOptions interface.\n     */\n    static isFindManyOptions<Entity = any>(obj: any): obj is FindManyOptions<Entity> {\n        const possibleOptions: FindManyOptions<Entity> = obj;\n        return possibleOptions && (\n            this.isFindOneOptions(possibleOptions) ||\n            typeof (possibleOptions as FindManyOptions<any>).skip === \"number\" ||\n            typeof (possibleOptions as FindManyOptions<any>).take === \"number\" ||\n            typeof (possibleOptions as FindManyOptions<any>).skip === \"string\" ||\n            typeof (possibleOptions as FindManyOptions<any>).take === \"string\"\n        );\n    }\n\n    /**\n     * Checks if given object is really instance of FindOptions interface.\n     */\n    static extractFindManyOptionsAlias(object: any): string|undefined {\n        if (this.isFindManyOptions(object) && object.join)\n            return object.join.alias;\n\n        return undefined;\n    }\n\n    /**\n     * Applies give find many options to the given query builder.\n     */\n    static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {\n        if (this.isFindManyOptions(options))\n            return this.applyOptionsToQueryBuilder(qb, options);\n\n        if (options)\n            return qb.where(options);\n\n        return qb;\n    }\n\n    /**\n     * Applies give find options to the given query builder.\n     */\n    static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {\n\n        // if options are not set then simply return query builder. This is made for simplicity of usage.\n        if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))\n            return qb;\n\n        if (options.transaction === true) {\n            qb.expressionMap.useTransaction = true;\n        }\n\n        if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)\n            return qb;\n\n        const metadata = qb.expressionMap.mainAlias!.metadata;\n\n        // apply all options from FindOptions\n        if (options.select) {\n            qb.select([]);\n            options.select.forEach(select => {\n                if (!metadata.findColumnWithPropertyPath(String(select)))\n                    throw new Error(`${select} column was not found in the ${metadata.name} entity.`);\n\n                qb.addSelect(qb.alias + \".\" + select);\n            });\n        }\n\n        if (options.where)\n            qb.where(options.where);\n\n        if ((options as FindManyOptions<T>).skip)\n            qb.skip((options as FindManyOptions<T>).skip!);\n\n        if ((options as FindManyOptions<T>).take)\n            qb.take((options as FindManyOptions<T>).take!);\n\n        if (options.order)\n            Object.keys(options.order).forEach(key => {\n                const order = ((options as FindOneOptions<T>).order as any)[key as any];\n\n                if (!metadata.findColumnWithPropertyPath(key))\n                    throw new Error(`${key} column was not found in the ${metadata.name} entity.`);\n\n                switch (order) {\n                    case 1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case -1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                    case \"ASC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case \"DESC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                }\n            });\n\n        if (options.relations) {\n            const allRelations = options.relations.map(relation => relation);\n            this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, \"\");\n            // recursive removes found relations from allRelations array\n            // if there are relations left in this array it means those relations were not found in the entity structure\n            // so, we give an exception about not found relations\n            if (allRelations.length > 0)\n                throw new FindRelationsNotFoundError(allRelations);\n        }\n\n        if (options.join) {\n            if (options.join.leftJoin)\n                Object.keys(options.join.leftJoin).forEach(key => {\n                    qb.leftJoin(options.join!.leftJoin![key], key);\n                });\n\n            if (options.join.innerJoin)\n                Object.keys(options.join.innerJoin).forEach(key => {\n                    qb.innerJoin(options.join!.innerJoin![key], key);\n                });\n\n            if (options.join.leftJoinAndSelect)\n                Object.keys(options.join.leftJoinAndSelect).forEach(key => {\n                    qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);\n                });\n\n            if (options.join.innerJoinAndSelect)\n                Object.keys(options.join.innerJoinAndSelect).forEach(key => {\n                    qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);\n                });\n        }\n\n        if (options.cache) {\n            if (options.cache instanceof Object) {\n                const cache = options.cache as { id: any, milliseconds: number };\n                qb.cache(cache.id, cache.milliseconds);\n            } else {\n                qb.cache(options.cache);\n            }\n        }\n\n        if (options.lock) {\n            if (options.lock.mode === \"optimistic\") {\n                qb.setLock(options.lock.mode, options.lock.version);\n            } else if (options.lock.mode === \"pessimistic_read\" || options.lock.mode === \"pessimistic_write\" || options.lock.mode === \"dirty_read\" || options.lock.mode === \"pessimistic_partial_write\" || options.lock.mode === \"pessimistic_write_or_fail\") {\n                const tableNames = options.lock.tables ? options.lock.tables.map((table) => {\n                    const tableAlias = qb.expressionMap.aliases.find((alias) => {\n                        return alias.metadata.tableNameWithoutPrefix === table;\n                    });\n                    if (!tableAlias) {\n                        throw new Error(`\"${table}\" is not part of this query`);\n                    }\n                    return qb.escape(tableAlias.name);\n                }) : undefined;\n                qb.setLock(options.lock.mode, undefined, tableNames);\n            }\n        }\n\n        if (options.withDeleted) {\n            qb.withDeleted();\n        }\n\n        if (options.loadRelationIds === true) {\n            qb.loadAllRelationIds();\n\n        } else if (options.loadRelationIds instanceof Object) {\n            qb.loadAllRelationIds(options.loadRelationIds as any);\n        }\n\n        return qb;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n     */\n    protected static applyRelationsRecursively(qb: SelectQueryBuilder<any>, allRelations: string[], alias: string, metadata: EntityMetadata, prefix: string): void {\n\n        // find all relations that match given prefix\n        let matchedBaseRelations: string[] = [];\n        if (prefix) {\n            const regexp = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\");\n            matchedBaseRelations = allRelations\n                .filter(relation => relation.match(regexp))\n                .map(relation => relation.replace(regexp, \"\"))\n                .filter(relation => metadata.findRelationWithPropertyPath(relation));\n        } else {\n            matchedBaseRelations = allRelations.filter(relation => metadata.findRelationWithPropertyPath(relation));\n        }\n\n        // go through all matched relations and add join for them\n        matchedBaseRelations.forEach(relation => {\n\n            // generate a relation alias\n            let relationAlias: string = DriverUtils.buildAlias(qb.connection.driver, { shorten: true, joiner: \"__\" }, alias, relation);\n\n            // add a join for the found relation\n            const selection = alias + \".\" + relation;\n            qb.leftJoinAndSelect(selection, relationAlias);\n\n            // join the eager relations of the found relation\n            const relMetadata = metadata.relations.find(metadata => metadata.propertyName === relation);\n            if (relMetadata) {\n                this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);\n            }\n\n            // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n            allRelations.splice(allRelations.indexOf(prefix ? prefix + \".\" + relation : relation), 1);\n\n            // try to find sub-relations\n            const join = qb.expressionMap.joinAttributes.find(join => join.entityOrProperty === selection);\n            this.applyRelationsRecursively(qb, allRelations, join!.alias.name, join!.metadata!, prefix ? prefix + \".\" + relation : relation);\n        });\n    }\n\n    public static joinEagerRelations(qb: SelectQueryBuilder<any>, alias: string, metadata: EntityMetadata) {\n        metadata.eagerRelations.forEach(relation => {\n\n            // generate a relation alias\n            let relationAlias = DriverUtils.buildAlias(qb.connection.driver, { shorten: true }, qb.connection.namingStrategy.eagerJoinRelationAlias(alias, relation.propertyPath));\n\n            // add a join for the relation\n            qb.leftJoinAndSelect(alias + \".\" + relation.propertyPath, relationAlias);\n\n            // (recursive) join the eager relations\n            this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);\n        });\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}