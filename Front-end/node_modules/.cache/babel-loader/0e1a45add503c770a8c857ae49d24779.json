{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { getConnection } from \"../index\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Base abstract entity for all entities, used in ActiveRecord patterns.\n */\n\nvar BaseEntity =\n/** @class */\nfunction () {\n  function BaseEntity() {} // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if entity has an id.\n   * If entity composite compose ids, it will check them all.\n   */\n\n\n  BaseEntity.prototype.hasId = function () {\n    return this.constructor.getRepository().hasId(this);\n  };\n  /**\n   * Saves current entity in the database.\n   * If entity does not exist in the database then inserts, otherwise updates.\n   */\n\n\n  BaseEntity.prototype.save = function (options) {\n    return this.constructor.getRepository().save(this, options);\n  };\n  /**\n   * Removes current entity from the database.\n   */\n\n\n  BaseEntity.prototype.remove = function (options) {\n    return this.constructor.getRepository().remove(this, options);\n  };\n  /**\n   * Records the delete date of current entity.\n   */\n\n\n  BaseEntity.prototype.softRemove = function (options) {\n    return this.constructor.getRepository().softRemove(this, options);\n  };\n  /**\n   * Recovers a given entity in the database.\n   */\n\n\n  BaseEntity.prototype.recover = function (options) {\n    return this.constructor.getRepository().recover(this, options);\n  };\n  /**\n   * Reloads entity data from the database.\n   */\n\n\n  BaseEntity.prototype.reload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var base, newestEntity;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            base = this.constructor;\n            return [4\n            /*yield*/\n            , base.getRepository().findOneOrFail(base.getId(this))];\n\n          case 1:\n            newestEntity = _a.sent();\n            ObjectUtils.assign(this, newestEntity);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Sets connection to be used by entity.\n   */\n\n\n  BaseEntity.useConnection = function (connection) {\n    this.usedConnection = connection;\n  };\n  /**\n   * Gets current entity's Repository.\n   */\n\n\n  BaseEntity.getRepository = function () {\n    var connection = this.usedConnection || getConnection();\n    return connection.getRepository(this);\n  };\n\n  Object.defineProperty(BaseEntity, \"target\", {\n    /**\n     * Returns object that is managed by this repository.\n     * If this repository manages entity from schema,\n     * then it returns a name of that schema instead.\n     */\n    get: function () {\n      return this.getRepository().target;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Checks entity has an id.\n   * If entity composite compose ids, it will check them all.\n   */\n\n  BaseEntity.hasId = function (entity) {\n    return this.getRepository().hasId(entity);\n  };\n  /**\n   * Gets entity mixed id.\n   */\n\n\n  BaseEntity.getId = function (entity) {\n    return this.getRepository().getId(entity);\n  };\n  /**\n   * Creates a new query builder that can be used to build a sql query.\n   */\n\n\n  BaseEntity.createQueryBuilder = function (alias) {\n    return this.getRepository().createQueryBuilder(alias);\n  };\n  /**\n    * Creates a new entity instance and copies all entity properties from this object into a new entity.\n    * Note that it copies only properties that present in entity schema.\n    */\n\n\n  BaseEntity.create = function (entityOrEntities) {\n    return this.getRepository().create(entityOrEntities);\n  };\n  /**\n   * Merges multiple entities (or entity-like objects) into a given entity.\n   */\n\n\n  BaseEntity.merge = function (mergeIntoEntity) {\n    var _a;\n\n    var entityLikes = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      entityLikes[_i - 1] = arguments[_i];\n    }\n\n    return (_a = this.getRepository()).merge.apply(_a, __spreadArray([mergeIntoEntity], __read(entityLikes)));\n  };\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   *\n   * Note that given entity-like object must have an entity id / primary key to find entity by.\n   * Returns undefined if entity with given id was not found.\n   */\n\n\n  BaseEntity.preload = function (entityLike) {\n    return this.getRepository().preload(entityLike);\n  };\n  /**\n   * Saves one or many given entities.\n   */\n\n\n  BaseEntity.save = function (entityOrEntities, options) {\n    return this.getRepository().save(entityOrEntities, options);\n  };\n  /**\n   * Removes one or many given entities.\n   */\n\n\n  BaseEntity.remove = function (entityOrEntities, options) {\n    return this.getRepository().remove(entityOrEntities, options);\n  };\n  /**\n   * Records the delete date of one or many given entities.\n   */\n\n\n  BaseEntity.softRemove = function (entityOrEntities, options) {\n    return this.getRepository().softRemove(entityOrEntities, options);\n  };\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   */\n\n\n  BaseEntity.insert = function (entity, options) {\n    return this.getRepository().insert(entity, options);\n  };\n  /**\n   * Updates entity partially. Entity can be found by a given conditions.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  BaseEntity.update = function (criteria, partialEntity, options) {\n    return this.getRepository().update(criteria, partialEntity, options);\n  };\n  /**\n   * Deletes entities by a given criteria.\n   * Unlike remove method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   */\n\n\n  BaseEntity.delete = function (criteria, options) {\n    return this.getRepository().delete(criteria, options);\n  };\n  /**\n   * Counts entities that match given find options or conditions.\n   */\n\n\n  BaseEntity.count = function (optionsOrConditions) {\n    return this.getRepository().count(optionsOrConditions);\n  };\n  /**\n   * Finds entities that match given find options or conditions.\n   */\n\n\n  BaseEntity.find = function (optionsOrConditions) {\n    return this.getRepository().find(optionsOrConditions);\n  };\n  /**\n   * Finds entities that match given find options or conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n\n\n  BaseEntity.findAndCount = function (optionsOrConditions) {\n    return this.getRepository().findAndCount(optionsOrConditions);\n  };\n  /**\n   * Finds entities by ids.\n   * Optionally find options can be applied.\n   */\n\n\n  BaseEntity.findByIds = function (ids, optionsOrConditions) {\n    return this.getRepository().findByIds(ids, optionsOrConditions);\n  };\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  BaseEntity.findOne = function (optionsOrConditions, maybeOptions) {\n    return this.getRepository().findOne(optionsOrConditions, maybeOptions);\n  };\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  BaseEntity.findOneOrFail = function (optionsOrConditions, maybeOptions) {\n    return this.getRepository().findOneOrFail(optionsOrConditions, maybeOptions);\n  };\n  /**\n   * Executes a raw SQL query and returns a raw database results.\n   * Raw query execution is supported only by relational databases (MongoDB is not supported).\n   */\n\n\n  BaseEntity.query = function (query, parameters) {\n    return this.getRepository().query(query, parameters);\n  };\n  /**\n   * Clears all the data from the given table/collection (truncates/drops it).\n   */\n\n\n  BaseEntity.clear = function () {\n    return this.getRepository().clear();\n  };\n\n  return BaseEntity;\n}();\n\nexport { BaseEntity };","map":{"version":3,"sources":["../browser/src/repository/BaseEntity.ts"],"names":[],"mappings":"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","sourcesContent":["import {Repository} from \"./Repository\";\nimport {FindConditions, getConnection} from \"../index\";\nimport {DeepPartial} from \"../common/DeepPartial\";\nimport {SaveOptions} from \"./SaveOptions\";\nimport {FindOneOptions} from \"../find-options/FindOneOptions\";\nimport {RemoveOptions} from \"./RemoveOptions\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\nimport {Connection} from \"../connection/Connection\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {InsertResult} from \"../query-builder/result/InsertResult\";\nimport {UpdateResult} from \"../query-builder/result/UpdateResult\";\nimport {DeleteResult} from \"../query-builder/result/DeleteResult\";\nimport {ObjectID} from \"../driver/mongodb/typings\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\nimport {QueryDeepPartialEntity} from \"../query-builder/QueryPartialEntity\";\n\n/**\n * Base abstract entity for all entities, used in ActiveRecord patterns.\n */\nexport class BaseEntity {\n\n    // -------------------------------------------------------------------------\n    // Private Static Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used in all static methods of the BaseEntity.\n     */\n    // @ts-ignore: Unused variable which is actually used\n    private static usedConnection?: Connection;\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    hasId(): boolean {\n        return (this.constructor as any).getRepository().hasId(this);\n    }\n\n    /**\n     * Saves current entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save(options?: SaveOptions): Promise<this> {\n        return (this.constructor as any).getRepository().save(this, options);\n    }\n\n    /**\n     * Removes current entity from the database.\n     */\n    remove(options?: RemoveOptions): Promise<this> {\n        return (this.constructor as any).getRepository().remove(this, options);\n    }\n\n    /**\n     * Records the delete date of current entity.\n     */\n    softRemove(options?: SaveOptions): Promise<this> {\n        return (this.constructor as any).getRepository().softRemove(this, options);\n    }\n\n    /**\n     * Recovers a given entity in the database.\n     */\n    recover(options?: SaveOptions): Promise<this> {\n        return (this.constructor as any).getRepository().recover(this, options);\n    }\n\n    /**\n     * Reloads entity data from the database.\n     */\n    async reload(): Promise<void> {\n        const base: any = this.constructor;\n        const newestEntity: BaseEntity = await base.getRepository().findOneOrFail(base.getId(this));\n\n        ObjectUtils.assign(this, newestEntity);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets connection to be used by entity.\n     */\n    static useConnection(connection: Connection) {\n        this.usedConnection = connection;\n    }\n\n    /**\n     * Gets current entity's Repository.\n     */\n    static getRepository<T extends BaseEntity>(this: ObjectType<T>): Repository<T> {\n        const connection: Connection = (this as any).usedConnection || getConnection();\n        return connection.getRepository<T>(this);\n    }\n\n    /**\n     * Returns object that is managed by this repository.\n     * If this repository manages entity from schema,\n     * then it returns a name of that schema instead.\n     */\n    static get target(): Function|string {\n        return this.getRepository().target;\n    }\n\n    /**\n     * Checks entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    static hasId(entity: BaseEntity): boolean {\n        return this.getRepository().hasId(entity);\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    static getId<T extends BaseEntity>(this: ObjectType<T>, entity: T): any {\n        return (this as any).getRepository().getId(entity);\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    static createQueryBuilder<T extends BaseEntity>(this: ObjectType<T>, alias?: string): SelectQueryBuilder<T> {\n        return (this as any).getRepository().createQueryBuilder(alias);\n    }\n\n    /**\n     * Creates a new entity instance.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>): T;\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>, entityLikeArray: DeepPartial<T>[]): T[];\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>, entityLike: DeepPartial<T>): T;\n   /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    static create<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities?: any): T {\n        return (this as any).getRepository().create(entityOrEntities);\n    }\n\n    /**\n     * Merges multiple entities (or entity-like objects) into a given entity.\n     */\n    static merge<T extends BaseEntity>(this: ObjectType<T>, mergeIntoEntity: T, ...entityLikes: DeepPartial<T>[]): T {\n        return (this as any).getRepository().merge(mergeIntoEntity, ...entityLikes);\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     *\n     * Note that given entity-like object must have an entity id / primary key to find entity by.\n     * Returns undefined if entity with given id was not found.\n     */\n    static preload<T extends BaseEntity>(this: ObjectType<T>, entityLike: DeepPartial<T>): Promise<T|undefined> {\n        return (this as any).getRepository().preload(entityLike);\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    static save<T extends BaseEntity>(this: ObjectType<T>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    static save<T extends BaseEntity>(this: ObjectType<T>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Saves one or many given entities.\n     */\n    static save<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities: T|T[], options?: SaveOptions): Promise<T|T[]> {\n        return (this as any).getRepository().save(entityOrEntities as any, options);\n    }\n\n    /**\n     * Removes a given entities from the database.\n     */\n    static remove<T extends BaseEntity>(this: ObjectType<T>, entities: T[], options?: RemoveOptions): Promise<T[]>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    static remove<T extends BaseEntity>(this: ObjectType<T>, entity: T, options?: RemoveOptions): Promise<T>;\n\n    /**\n     * Removes one or many given entities.\n     */\n    static remove<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities: T|T[], options?: RemoveOptions): Promise<T|T[]> {\n        return (this as any).getRepository().remove(entityOrEntities as any, options);\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    static softRemove<T extends BaseEntity>(this: ObjectType<T>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    static softRemove<T extends BaseEntity>(this: ObjectType<T>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    static softRemove<T extends BaseEntity>(this: ObjectType<T>, entityOrEntities: T|T[], options?: SaveOptions): Promise<T|T[]> {\n        return (this as any).getRepository().softRemove(entityOrEntities as any, options);\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     */\n    static insert<T extends BaseEntity>(this: ObjectType<T>, entity: QueryDeepPartialEntity<T>|QueryDeepPartialEntity<T>[], options?: SaveOptions): Promise<InsertResult> {\n        return (this as any).getRepository().insert(entity, options);\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     */\n    static update<T extends BaseEntity>(this: ObjectType<T>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindConditions<T>, partialEntity: QueryDeepPartialEntity<T>, options?: SaveOptions): Promise<UpdateResult> {\n        return (this as any).getRepository().update(criteria, partialEntity, options);\n    }\n\n    /**\n     * Deletes entities by a given criteria.\n     * Unlike remove method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    static delete<T extends BaseEntity>(this: ObjectType<T>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindConditions<T>, options?: RemoveOptions): Promise<DeleteResult> {\n        return (this as any).getRepository().delete(criteria, options);\n    }\n\n    /**\n     * Counts entities that match given options.\n     */\n    static count<T extends BaseEntity>(this: ObjectType<T>, options?: FindManyOptions<T>): Promise<number>;\n\n    /**\n     * Counts entities that match given conditions.\n     */\n    static count<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindConditions<T>): Promise<number>;\n\n    /**\n     * Counts entities that match given find options or conditions.\n     */\n    static count<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: FindManyOptions<T>|FindConditions<T>): Promise<number> {\n        return (this as any).getRepository().count(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities that match given options.\n     */\n    static find<T extends BaseEntity>(this: ObjectType<T>, options?: FindManyOptions<T>): Promise<T[]>;\n\n    /**\n     * Finds entities that match given conditions.\n     */\n    static find<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindConditions<T>): Promise<T[]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     */\n    static find<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: FindManyOptions<T>|FindConditions<T>): Promise<T[]> {\n        return (this as any).getRepository().find(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(this: ObjectType<T>, options?: FindManyOptions<T>): Promise<[ T[], number ]>;\n\n    /**\n     * Finds entities that match given conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindConditions<T>): Promise<[ T[], number ]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    static findAndCount<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: FindManyOptions<T>|FindConditions<T>): Promise<[ T[], number ]> {\n        return (this as any).getRepository().findAndCount(optionsOrConditions as any);\n    }\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     */\n    static findByIds<T extends BaseEntity>(this: ObjectType<T>, ids: any[], options?: FindManyOptions<T>): Promise<T[]>;\n\n    /**\n     * Finds entities by ids.\n     * Optionally conditions can be applied.\n     */\n    static findByIds<T extends BaseEntity>(this: ObjectType<T>, ids: any[], conditions?: FindConditions<T>): Promise<T[]>;\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     */\n    static findByIds<T extends BaseEntity>(this: ObjectType<T>, ids: any[], optionsOrConditions?: FindManyOptions<T>|FindConditions<T>): Promise<T[]> {\n        return (this as any).getRepository().findByIds(ids, optionsOrConditions as any);\n    }\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, id?: string|number|Date|ObjectID, options?: FindOneOptions<T>): Promise<T|undefined>;\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, options?: FindOneOptions<T>): Promise<T|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindConditions<T>, options?: FindOneOptions<T>): Promise<T|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOne<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: string|number|Date|ObjectID|FindOneOptions<T>|FindConditions<T>, maybeOptions?: FindOneOptions<T>): Promise<T|undefined> {\n        return (this as any).getRepository().findOne(optionsOrConditions as any, maybeOptions);\n    }\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, id?: string|number|Date|ObjectID, options?: FindOneOptions<T>): Promise<T>;\n\n    /**\n     * Finds first entity that matches given options.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, options?: FindOneOptions<T>): Promise<T>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, conditions?: FindConditions<T>, options?: FindOneOptions<T>): Promise<T>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    static findOneOrFail<T extends BaseEntity>(this: ObjectType<T>, optionsOrConditions?: string|number|Date|ObjectID|FindOneOptions<T>|FindConditions<T>, maybeOptions?: FindOneOptions<T>): Promise<T> {\n        return (this as any).getRepository().findOneOrFail(optionsOrConditions as any, maybeOptions);\n    }\n\n    /**\n     * Executes a raw SQL query and returns a raw database results.\n     * Raw query execution is supported only by relational databases (MongoDB is not supported).\n     */\n    static query<T extends BaseEntity>(this: ObjectType<T>, query: string, parameters?: any[]): Promise<any> {\n        return (this as any).getRepository().query(query, parameters);\n    }\n\n    /**\n     * Clears all the data from the given table/collection (truncates/drops it).\n     */\n    static clear<T extends BaseEntity>(this: ObjectType<T>, ): Promise<void> {\n        return (this as any).getRepository().clear();\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}