{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { EntityMetadata } from \"./EntityMetadata\";\n/**\n * Contains all information about some entity's relation.\n */\n\nvar RelationMetadata =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function RelationMetadata(options) {\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    this.isTreeParent = false;\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n\n    this.isTreeChildren = false;\n    /**\n     * Indicates if this relation's column is a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates if this relation is lazily loaded.\n     */\n\n    this.isLazy = false;\n    /**\n     * Indicates if this relation is eagerly loaded.\n     */\n\n    this.isEager = false;\n    /**\n     * Indicates if persistence is enabled for the relation.\n     * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n     * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n     * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n     */\n\n    this.persistenceEnabled = true;\n    /**\n     * If set to true then related objects are allowed to be inserted to the database.\n     */\n\n    this.isCascadeInsert = false;\n    /**\n     * If set to true then related objects are allowed to be updated in the database.\n     */\n\n    this.isCascadeUpdate = false;\n    /**\n     * If set to true then related objects are allowed to be remove from the database.\n     */\n\n    this.isCascadeRemove = false;\n    /**\n     * If set to true then related objects are allowed to be soft-removed from the database.\n     */\n\n    this.isCascadeSoftRemove = false;\n    /**\n     * If set to true then related objects are allowed to be recovered from the database.\n     */\n\n    this.isCascadeRecover = false;\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n\n    this.isNullable = true;\n    /**\n     * Indicates whether foreign key constraints will be created for join columns.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     * Defaults to true.\n     */\n\n    this.createForeignKeyConstraints = true;\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n\n    this.isOwning = false;\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n\n    this.isOneToOne = false;\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n\n    this.isOneToOneOwner = false;\n    /**\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n     */\n\n    this.isWithJoinColumn = false;\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n\n    this.isOneToOneNotOwner = false;\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n\n    this.isOneToMany = false;\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n\n    this.isManyToOne = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n\n    this.isManyToMany = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n\n    this.isManyToManyOwner = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n\n    this.isManyToManyNotOwner = false;\n    /**\n     * Foreign keys created for this relation.\n     */\n\n    this.foreignKeys = [];\n    /**\n     * Join table columns.\n     * Join columns can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be empty.\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n     */\n\n    this.joinColumns = [];\n    /**\n     * Inverse join table columns.\n     * Inverse join columns are supported only for many-to-many relations\n     * and can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be undefined.\n     */\n\n    this.inverseJoinColumns = [];\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    var args = options.args;\n    this.target = args.target;\n    this.propertyName = args.propertyName;\n    this.relationType = args.relationType;\n    if (args.inverseSideProperty) this.givenInverseSidePropertyFactory = args.inverseSideProperty;\n    this.isLazy = args.isLazy || false; // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n    // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n    // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n    // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n    // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n\n    this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"insert\") !== -1;\n    this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"update\") !== -1;\n    this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"remove\") !== -1;\n    this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"soft-remove\") !== -1;\n    this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"recover\") !== -1;\n    this.isPrimary = args.options.primary || false;\n    this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;\n    this.onDelete = args.options.onDelete;\n    this.onUpdate = args.options.onUpdate;\n    this.deferrable = args.options.deferrable;\n    this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;\n    this.isEager = args.options.eager || false;\n    this.persistenceEnabled = args.options.persistence === false ? false : true;\n    this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\";\n    this.isTreeParent = args.isTreeParent || false;\n    this.isTreeChildren = args.isTreeChildren || false;\n    this.type = args.type instanceof Function ? args.type() : args.type;\n    this.isOneToOne = this.relationType === \"one-to-one\";\n    this.isOneToMany = this.relationType === \"one-to-many\";\n    this.isManyToOne = this.relationType === \"many-to-one\";\n    this.isManyToMany = this.relationType === \"many-to-many\";\n    this.isOneToOneNotOwner = this.isOneToOne ? true : false;\n    this.isManyToManyNotOwner = this.isManyToMany ? true : false;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Creates join column ids map from the given related entity ids array.\n   */\n\n\n  RelationMetadata.prototype.getRelationIdMap = function (entity) {\n    var joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;\n    var referencedColumns = joinColumns.map(function (joinColumn) {\n      return joinColumn.referencedColumn;\n    }); // console.log(\"entity\", entity);\n    // console.log(\"referencedColumns\", referencedColumns);\n\n    return EntityMetadata.getValueMap(entity, referencedColumns);\n  };\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n\n\n  RelationMetadata.prototype.ensureRelationIdMap = function (id) {\n    if (id instanceof Object) return id;\n    var joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;\n    var referencedColumns = joinColumns.map(function (joinColumn) {\n      return joinColumn.referencedColumn;\n    });\n    if (referencedColumns.length > 1) throw new Error(\"Cannot create relation id map for a single value because relation contains multiple referenced columns.\");\n    return referencedColumns[0].createValueMap(id);\n  };\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n\n\n  RelationMetadata.prototype.getEntityValue = function (entity, getLazyRelationsPromiseValue) {\n    if (getLazyRelationsPromiseValue === void 0) {\n      getLazyRelationsPromiseValue = false;\n    }\n\n    if (entity === null || entity === undefined) return undefined; // extract column value from embeddeds of entity if column is in embedded\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var propertyNames = __spreadArray([], __read(this.embeddedMetadata.parentPropertyNames)); // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n\n\n      var extractEmbeddedColumnValue_1 = function (propertyNames, value) {\n        var propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          if (value[propertyName]) {\n            return extractEmbeddedColumnValue_1(propertyNames, value[propertyName]);\n          }\n\n          return undefined;\n        }\n\n        return value;\n      }; // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n\n\n      var embeddedObject = extractEmbeddedColumnValue_1(propertyNames, entity);\n\n      if (this.isLazy) {\n        if (embeddedObject[\"__\" + this.propertyName + \"__\"] !== undefined) return embeddedObject[\"__\" + this.propertyName + \"__\"];\n        if (getLazyRelationsPromiseValue === true) return embeddedObject[this.propertyName];\n        return undefined;\n      }\n\n      return embeddedObject ? embeddedObject[this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName] : undefined;\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.isLazy) {\n        if (entity[\"__\" + this.propertyName + \"__\"] !== undefined) return entity[\"__\" + this.propertyName + \"__\"];\n        if (getLazyRelationsPromiseValue === true) return entity[this.propertyName];\n        return undefined;\n      }\n\n      return entity[this.propertyName];\n    }\n  };\n  /**\n   * Sets given entity's relation's value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   *\n   * If merge is set to true, it merges given value into currently\n   */\n\n\n  RelationMetadata.prototype.setEntityValue = function (entity, value) {\n    var propertyName = this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName;\n\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var extractEmbeddedColumnValue_2 = function (embeddedMetadatas, map) {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        var embeddedMetadata = embeddedMetadatas.shift();\n\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue_2(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n\n        map[propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue_2(__spreadArray([], __read(this.embeddedMetadata.embeddedMetadataTree)), entity);\n    } else {\n      entity[propertyName] = value;\n    }\n  };\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n\n\n  RelationMetadata.prototype.createValueMap = function (value) {\n    var _a;\n\n    var _this = this; // extract column value from embeds of entity if column is in embedded\n\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var propertyNames = __spreadArray([], __read(this.embeddedMetadata.parentPropertyNames)); // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n\n\n      var extractEmbeddedColumnValue_3 = function (propertyNames, map) {\n        var propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue_3(propertyNames, map[propertyName]);\n          return map;\n        }\n\n        map[_this.propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue_3(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      return _a = {}, _a[this.propertyName] = value, _a;\n    }\n  }; // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds some depend relation metadata properties.\n   * This builder method should be used only after embedded metadata tree was build.\n   */\n\n\n  RelationMetadata.prototype.build = function () {\n    this.propertyPath = this.buildPropertyPath();\n  };\n  /**\n   * Registers given foreign keys in the relation.\n   * This builder method should be used to register foreign key in the relation.\n   */\n\n\n  RelationMetadata.prototype.registerForeignKeys = function () {\n    var _a;\n\n    var foreignKeys = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      foreignKeys[_i] = arguments[_i];\n    }\n\n    (_a = this.foreignKeys).push.apply(_a, __spreadArray([], __read(foreignKeys)));\n  };\n  /**\n   * Registers given join columns in the relation.\n   * This builder method should be used to register join column in the relation.\n   */\n\n\n  RelationMetadata.prototype.registerJoinColumns = function (joinColumns, inverseJoinColumns) {\n    if (joinColumns === void 0) {\n      joinColumns = [];\n    }\n\n    if (inverseJoinColumns === void 0) {\n      inverseJoinColumns = [];\n    }\n\n    this.joinColumns = joinColumns;\n    this.inverseJoinColumns = inverseJoinColumns;\n    this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;\n    this.isOneToOneOwner = this.isOneToOne && this.isOwning;\n    this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;\n    this.isManyToManyOwner = this.isManyToMany && this.isOwning;\n    this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;\n    this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;\n  };\n  /**\n   * Registers a given junction entity metadata.\n   * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n   */\n\n\n  RelationMetadata.prototype.registerJunctionEntityMetadata = function (junctionEntityMetadata) {\n    this.junctionEntityMetadata = junctionEntityMetadata;\n    this.joinTableName = junctionEntityMetadata.tableName;\n\n    if (this.inverseRelation) {\n      this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;\n      this.joinTableName = junctionEntityMetadata.tableName;\n    }\n  };\n  /**\n   * Builds inverse side property path based on given inverse side property factory.\n   * This builder method should be used only after properties map of the inverse entity metadata was build.\n   */\n\n\n  RelationMetadata.prototype.buildInverseSidePropertyPath = function () {\n    if (this.givenInverseSidePropertyFactory) {\n      var ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;\n      if (typeof this.givenInverseSidePropertyFactory === \"function\") return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);\n      if (typeof this.givenInverseSidePropertyFactory === \"string\") return this.givenInverseSidePropertyFactory;\n    } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {\n      return this.entityMetadata.treeChildrenRelation.propertyName;\n    } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {\n      return this.entityMetadata.treeParentRelation.propertyName;\n    }\n\n    return \"\";\n  };\n  /**\n   * Builds relation's property path based on its embedded tree.\n   */\n\n\n  RelationMetadata.prototype.buildPropertyPath = function () {\n    if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length) return this.propertyName;\n    return this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\" + this.propertyName;\n  };\n\n  return RelationMetadata;\n}();\n\nexport { RelationMetadata };","map":{"version":3,"sources":["../browser/src/metadata/RelationMetadata.ts"],"names":[],"mappings":"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","sourcesContent":["import {RelationType} from \"./types/RelationTypes\";\nimport {EntityMetadata} from \"./EntityMetadata\";\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {ColumnMetadata} from \"./ColumnMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\nimport {RelationMetadataArgs} from \"../metadata-args/RelationMetadataArgs\";\nimport {DeferrableType} from \"./types/DeferrableType\";\nimport {OnUpdateType} from \"./types/OnUpdateType\";\nimport {OnDeleteType} from \"./types/OnDeleteType\";\nimport {PropertyTypeFactory} from \"./types/PropertyTypeInFunction\";\n\n/**\n * Contains all information about some entity's relation.\n */\nexport class RelationMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the entity where this relation is placed.\n     *\n     * For example for @ManyToMany(type => Category) in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata;\n\n    /**\n     * Entity metadata of the entity that is targeted by this relation.\n     *\n     * For example for @ManyToMany(type => Category) in Post, inverseEntityMetadata will be metadata of Category entity.\n     */\n    inverseEntityMetadata: EntityMetadata;\n\n    /**\n     * Entity metadata of the junction table.\n     * Junction tables have their own entity metadata objects.\n     * Defined only for many-to-many relations.\n     */\n    junctionEntityMetadata?: EntityMetadata;\n\n    /**\n     * Embedded metadata where this relation is.\n     * If this relation is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata;\n\n    /**\n     * Relation type, e.g. is it one-to-one, one-to-many, many-to-one or many-to-many.\n     */\n    relationType: RelationType;\n\n    /**\n     * Target entity to which this relation is applied.\n     * Target IS NOT equal to entityMetadata.target, because relation\n     *\n     * For example for @ManyToMany(type => Category) in Post, target will be Post.\n     * If @ManyToMany(type => Category) is in Counters which is embedded into Post, target will be Counters.\n     * If @ManyToMany(type => Category) is in abstract class BaseUser which Post extends, target will be BaseUser.\n     * Target can be string if its defined in entity schema instead of class.\n     */\n    target: Function|string;\n\n    /**\n     * Target's property name to which relation decorator is applied.\n     */\n    propertyName: string;\n\n    /**\n     * Gets full path to this column property (including relation name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string;\n\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    isTreeParent: boolean = false;\n\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n    isTreeChildren: boolean = false;\n\n    /**\n     * Indicates if this relation's column is a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n    isPrimary: boolean = false;\n\n    /**\n     * Indicates if this relation is lazily loaded.\n     */\n    isLazy: boolean = false;\n\n    /**\n     * Indicates if this relation is eagerly loaded.\n     */\n    isEager: boolean = false;\n\n    /**\n     * Indicates if persistence is enabled for the relation.\n     * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n     * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n     * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n     */\n    persistenceEnabled: boolean = true;\n\n    /**\n     * When a child row is removed from its parent, determines if the child row should be orphaned (default) or deleted.\n     */\n    orphanedRowAction?: \"nullify\" | \"delete\";\n\n    /**\n     * If set to true then related objects are allowed to be inserted to the database.\n     */\n    isCascadeInsert: boolean = false;\n\n    /**\n     * If set to true then related objects are allowed to be updated in the database.\n     */\n    isCascadeUpdate: boolean = false;\n\n    /**\n     * If set to true then related objects are allowed to be remove from the database.\n     */\n    isCascadeRemove: boolean = false;\n\n    /**\n     * If set to true then related objects are allowed to be soft-removed from the database.\n     */\n    isCascadeSoftRemove: boolean = false;\n\n    /**\n     * If set to true then related objects are allowed to be recovered from the database.\n     */\n    isCascadeRecover: boolean = false;\n\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n    isNullable: boolean = true;\n\n    /**\n     * What to do with a relation on deletion of the row containing a foreign key.\n     */\n    onDelete?: OnDeleteType;\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    onUpdate?: OnUpdateType;\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    deferrable?: DeferrableType;\n\n    /**\n     * Indicates whether foreign key constraints will be created for join columns.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     * Defaults to true.\n     */\n    createForeignKeyConstraints: boolean = true;\n\n    /**\n     * Gets the property's type to which this relation is applied.\n     *\n     * For example for @ManyToMany(type => Category) in Post, target will be Category.\n     */\n    type: Function|string;\n\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n    isOwning: boolean = false;\n\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n    isOneToOne: boolean = false;\n\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n    isOneToOneOwner: boolean = false;\n\n    /**\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n     */\n    isWithJoinColumn: boolean = false;\n\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n    isOneToOneNotOwner: boolean = false;\n\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n    isOneToMany: boolean = false;\n\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n    isManyToOne: boolean = false;\n\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n    isManyToMany: boolean = false;\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n    isManyToManyOwner: boolean = false;\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n    isManyToManyNotOwner: boolean = false;\n\n    /**\n     * Gets the property path of the inverse side of the relation.\n     */\n    inverseSidePropertyPath: string;\n\n    /**\n     * Inverse side of the relation set by user.\n     *\n     * Inverse side set in the relation can be either string - property name of the column on inverse side,\n     * either can be a function that accepts a map of properties with the object and returns one of them.\n     * Second approach is used to achieve type-safety.\n     */\n    givenInverseSidePropertyFactory: PropertyTypeFactory<any>;\n\n    /**\n     * Gets the relation metadata of the inverse side of this relation.\n     */\n    inverseRelation?: RelationMetadata;\n\n    /**\n     * Join table name.\n     */\n    joinTableName: string;\n\n    /**\n     * Foreign keys created for this relation.\n     */\n    foreignKeys: ForeignKeyMetadata[] = [];\n\n    /**\n     * Join table columns.\n     * Join columns can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be empty.\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n     */\n    joinColumns: ColumnMetadata[] = [];\n\n    /**\n     * Inverse join table columns.\n     * Inverse join columns are supported only for many-to-many relations\n     * and can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be undefined.\n     */\n    inverseJoinColumns: ColumnMetadata[] = [];\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata,\n        embeddedMetadata?: EmbeddedMetadata,\n        args: RelationMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata!;\n        const args = options.args;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.relationType = args.relationType;\n\n        if (args.inverseSideProperty)\n            this.givenInverseSidePropertyFactory = args.inverseSideProperty;\n\n        this.isLazy = args.isLazy || false;\n        // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n        // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n        // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n        // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n        // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n        this.isCascadeInsert = args.options.cascade === true || (Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"insert\") !== -1);\n        this.isCascadeUpdate = args.options.cascade === true || (Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"update\") !== -1);\n        this.isCascadeRemove = args.options.cascade === true || (Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"remove\") !== -1);\n        this.isCascadeSoftRemove = args.options.cascade === true || (Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n        this.isCascadeRecover = args.options.cascade === true || (Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"recover\") !== -1);\n        this.isPrimary = args.options.primary || false;\n        this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;\n        this.onDelete = args.options.onDelete;\n        this.onUpdate = args.options.onUpdate;\n        this.deferrable = args.options.deferrable;\n        this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;\n        this.isEager = args.options.eager || false;\n        this.persistenceEnabled = args.options.persistence === false ? false : true;\n        this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\";\n        this.isTreeParent = args.isTreeParent || false;\n        this.isTreeChildren = args.isTreeChildren || false;\n        this.type = args.type instanceof Function ? (args.type as () => any)() : args.type;\n\n        this.isOneToOne = this.relationType === \"one-to-one\";\n        this.isOneToMany = this.relationType === \"one-to-many\";\n        this.isManyToOne = this.relationType === \"many-to-one\";\n        this.isManyToMany = this.relationType === \"many-to-many\";\n        this.isOneToOneNotOwner = this.isOneToOne ? true : false;\n        this.isManyToManyNotOwner = this.isManyToMany ? true : false;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates join column ids map from the given related entity ids array.\n     */\n    getRelationIdMap(entity: ObjectLiteral): ObjectLiteral|undefined {\n        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation!.joinColumns;\n        const referencedColumns = joinColumns.map(joinColumn => joinColumn.referencedColumn!);\n        // console.log(\"entity\", entity);\n        // console.log(\"referencedColumns\", referencedColumns);\n        return EntityMetadata.getValueMap(entity, referencedColumns);\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureRelationIdMap(id: any): ObjectLiteral {\n        if (id instanceof Object)\n            return id;\n\n        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation!.joinColumns;\n        const referencedColumns = joinColumns.map(joinColumn => joinColumn.referencedColumn!);\n\n        if (referencedColumns.length > 1)\n            throw new Error(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);\n\n        return referencedColumns[0].createValueMap(id);\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(entity: ObjectLiteral, getLazyRelationsPromiseValue: boolean = false): any|undefined {\n        if (entity === null || entity === undefined) return undefined;\n        // extract column value from embeddeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    if (value[propertyName]) {\n                        return extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n                    }\n                    return undefined;\n                }\n                return value;\n            };\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n\n            if (this.isLazy) {\n                if (embeddedObject[\"__\" + this.propertyName + \"__\"] !== undefined)\n                    return embeddedObject[\"__\" + this.propertyName + \"__\"];\n\n                if (getLazyRelationsPromiseValue === true)\n                    return embeddedObject[this.propertyName];\n\n                return undefined;\n            }\n            return embeddedObject ? embeddedObject[this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName] : undefined;\n\n        } else { // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.isLazy) {\n                if (entity[\"__\" + this.propertyName + \"__\"] !== undefined)\n                    return entity[\"__\" + this.propertyName + \"__\"];\n\n                if (getLazyRelationsPromiseValue === true)\n                    return entity[this.propertyName];\n\n                return undefined;\n            }\n            return entity[this.propertyName];\n        }\n    }\n\n    /**\n     * Sets given entity's relation's value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     *\n     * If merge is set to true, it merges given value into currently\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        const propertyName = this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName;\n\n        if (this.embeddedMetadata) {\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (embeddedMetadatas: EmbeddedMetadata[], map: ObjectLiteral): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift();\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n                    return map;\n                }\n                map[propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n\n        } else {\n            entity[propertyName] = value;\n        }\n    }\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any) {\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, {});\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n            return { [this.propertyName]: value };\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend relation metadata properties.\n     * This builder method should be used only after embedded metadata tree was build.\n     */\n    build() {\n        this.propertyPath = this.buildPropertyPath();\n    }\n\n    /**\n     * Registers given foreign keys in the relation.\n     * This builder method should be used to register foreign key in the relation.\n     */\n    registerForeignKeys(...foreignKeys: ForeignKeyMetadata[]) {\n        this.foreignKeys.push(...foreignKeys);\n    }\n\n    /**\n     * Registers given join columns in the relation.\n     * This builder method should be used to register join column in the relation.\n     */\n    registerJoinColumns(joinColumns: ColumnMetadata[] = [], inverseJoinColumns: ColumnMetadata[] = []) {\n        this.joinColumns = joinColumns;\n        this.inverseJoinColumns = inverseJoinColumns;\n        this.isOwning = this.isManyToOne || ((this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0);\n        this.isOneToOneOwner = this.isOneToOne && this.isOwning;\n        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;\n        this.isManyToManyOwner = this.isManyToMany && this.isOwning;\n        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;\n        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;\n    }\n\n    /**\n     * Registers a given junction entity metadata.\n     * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n     */\n    registerJunctionEntityMetadata(junctionEntityMetadata: EntityMetadata) {\n        this.junctionEntityMetadata = junctionEntityMetadata;\n        this.joinTableName = junctionEntityMetadata.tableName;\n        if (this.inverseRelation) {\n            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;\n            this.joinTableName = junctionEntityMetadata.tableName;\n        }\n    }\n\n    /**\n     * Builds inverse side property path based on given inverse side property factory.\n     * This builder method should be used only after properties map of the inverse entity metadata was build.\n     */\n    buildInverseSidePropertyPath(): string {\n\n        if (this.givenInverseSidePropertyFactory) {\n            const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;\n            if (typeof this.givenInverseSidePropertyFactory === \"function\")\n                return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);\n\n            if (typeof this.givenInverseSidePropertyFactory === \"string\")\n                return this.givenInverseSidePropertyFactory;\n\n        } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {\n            return this.entityMetadata.treeChildrenRelation.propertyName;\n\n        } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {\n            return this.entityMetadata.treeParentRelation.propertyName;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Builds relation's property path based on its embedded tree.\n     */\n    buildPropertyPath(): string {\n        if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length)\n            return this.propertyName;\n\n        return this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\" + this.propertyName;\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}