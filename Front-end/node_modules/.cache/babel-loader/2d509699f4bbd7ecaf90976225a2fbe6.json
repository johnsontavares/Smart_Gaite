{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Builds operations needs to be executed for one-to-one non-owner relations of the given subjects.\n *\n * by example: post contains one-to-one non-owner relation with category in the property called \"category\", e.g.\n *             @OneToOne(type => Category, category => category.post) category: Category\n *             If user sets a category into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToManyUpdateBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\n\nvar OneToOneInverseSideSubjectBuilder =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function OneToOneInverseSideSubjectBuilder(subjects) {\n    this.subjects = subjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds all required operations.\n   */\n\n\n  OneToOneInverseSideSubjectBuilder.prototype.build = function () {\n    var _this = this;\n\n    this.subjects.forEach(function (subject) {\n      subject.metadata.oneToOneRelations.forEach(function (relation) {\n        // we don't need owning relations, this operation is only for inverse side of one-to-one relations\n        // skip relations for which persistence is disabled\n        if (relation.isOwning || relation.persistenceEnabled === false) return;\n\n        _this.buildForSubjectRelation(subject, relation);\n      });\n    });\n  }; // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds operations for a given subject and relation.\n   *\n   * by example: subject is \"post\" entity we are saving here and relation is \"category\" inside it here.\n   */\n\n\n  OneToOneInverseSideSubjectBuilder.prototype.buildForSubjectRelation = function (subject, relation) {\n    // prepare objects (relation id map) for the database entity\n    // note: subject.databaseEntity contains relation with loaded relation id only (id map)\n    // by example: since subject is a post, we are expecting to get post's category saved in the database here,\n    //             particularly its relation id, e.g. category id stored in the database\n    var relatedEntityDatabaseRelationId = undefined;\n    if (subject.databaseEntity) // related entity in the database can exist only if this entity (post) is saved\n      relatedEntityDatabaseRelationId = relation.getEntityValue(subject.databaseEntity); // get related entities of persisted entity\n    // by example: get category from the passed to persist post entity\n\n    var relatedEntity = relation.getEntityValue(subject.entity); // by example: relatedEntity is a category here\n\n    if (relatedEntity === undefined) // if relation is undefined then nothing to update\n      return; // if related entity is null then we need to check if there a bind in the database and unset it\n    // if there is no bind in the entity then we don't need to do anything\n    // by example: if post.category = null and category has this post in the database then we unset it\n\n    if (relatedEntity === null) {\n      // it makes sense to update database only there is a previously set value in the database\n      if (relatedEntityDatabaseRelationId) {\n        // todo: probably we can improve this in the future by finding entity with column those values,\n        // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n        // we create a new subject which operations will be executed in subject operation executor\n        var removedRelatedEntitySubject = new Subject({\n          metadata: relation.inverseEntityMetadata,\n          parentSubject: subject,\n          canBeUpdated: true,\n          identifier: relatedEntityDatabaseRelationId,\n          changeMaps: [{\n            relation: relation.inverseRelation,\n            value: null\n          }]\n        });\n        this.subjects.push(removedRelatedEntitySubject);\n      }\n\n      return;\n    } // else means entity is bind in the database\n    // extract only relation id from the related entities, since we only need it for comparision\n    // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n\n\n    var relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }\n    // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n\n    var relatedEntitySubject = this.subjects.find(function (operateSubject) {\n      return !!operateSubject.entity && operateSubject.entity === relatedEntity;\n    }); // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n\n    if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier; // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n    // by example: if post contains category which does not have id(s) yet (because its a new category)\n    //             it means its always newly inserted and relation update operation always must be created for it\n    //             it does not make sense to perform difference operation for it for both add and remove actions\n\n    if (!relationIdMap) {\n      // we decided to remove this error because it brings complications when saving object with non-saved entities\n      // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n      // in this persistence because he didn't pass this entity for save or he did not set cascades\n      // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n      // if (!relatedEntitySubject)\n      //     throw new Error(`One-to-one inverse relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n      //         `entity which does not exist in the database yet, thus cannot be bind in the database. ` +\n      //         `Please setup cascade insertion or save entity before binding it.`);\n      if (!relatedEntitySubject) return; // okay, so related subject exist and its marked for insertion, then add a new change map\n      // by example: this will tell category to insert into its post relation our post we are working with\n      //             relatedEntitySubject is newly inserted CategorySubject\n      //             relation.inverseRelation is OneToOne owner relation inside Category\n      //             subject is Post needs to be inserted into Category\n\n      relatedEntitySubject.changeMaps.push({\n        relation: relation.inverseRelation,\n        value: subject\n      });\n    } // check if this binding really exist in the database\n    // by example: find our post if its already bind to category in the database and its not equal to what user tries to set\n\n\n    var areRelatedIdEqualWithDatabase = relatedEntityDatabaseRelationId && OrmUtils.compareIds(relationIdMap, relatedEntityDatabaseRelationId); // if they aren't equal it means its a new relation and we need to \"bind\" them\n    // by example: this will tell category to insert into its post relation our post we are working with\n    //             relatedEntitySubject is newly inserted CategorySubject\n    //             relation.inverseRelation is ManyToOne relation inside Category\n    //             subject is Post needs to be inserted into Category\n\n    if (!areRelatedIdEqualWithDatabase) {\n      // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n      // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n      // we create a new subject here:\n      if (!relatedEntitySubject) {\n        relatedEntitySubject = new Subject({\n          metadata: relation.inverseEntityMetadata,\n          canBeUpdated: true,\n          identifier: relationIdMap\n        });\n        this.subjects.push(relatedEntitySubject);\n      }\n\n      relatedEntitySubject.changeMaps.push({\n        relation: relation.inverseRelation,\n        value: subject\n      });\n    }\n  };\n\n  return OneToOneInverseSideSubjectBuilder;\n}();\n\nexport { OneToOneInverseSideSubjectBuilder };","map":{"version":3,"sources":["../browser/src/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"../Subject\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {RelationMetadata} from \"../../metadata/RelationMetadata\";\n\n/**\n * Builds operations needs to be executed for one-to-one non-owner relations of the given subjects.\n *\n * by example: post contains one-to-one non-owner relation with category in the property called \"category\", e.g.\n *             @OneToOne(type => Category, category => category.post) category: Category\n *             If user sets a category into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToManyUpdateBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\nexport class OneToOneInverseSideSubjectBuilder {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds all required operations.\n     */\n    build(): void {\n        this.subjects.forEach(subject => {\n            subject.metadata.oneToOneRelations.forEach(relation => {\n\n                // we don't need owning relations, this operation is only for inverse side of one-to-one relations\n                // skip relations for which persistence is disabled\n                if (relation.isOwning || relation.persistenceEnabled === false)\n                    return;\n\n                this.buildForSubjectRelation(subject, relation);\n            });\n        });\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"category\" inside it here.\n     */\n    protected buildForSubjectRelation(subject: Subject, relation: RelationMetadata) {\n\n        // prepare objects (relation id map) for the database entity\n        // note: subject.databaseEntity contains relation with loaded relation id only (id map)\n        // by example: since subject is a post, we are expecting to get post's category saved in the database here,\n        //             particularly its relation id, e.g. category id stored in the database\n        let relatedEntityDatabaseRelationId: ObjectLiteral|undefined = undefined;\n        if (subject.databaseEntity) // related entity in the database can exist only if this entity (post) is saved\n            relatedEntityDatabaseRelationId = relation.getEntityValue(subject.databaseEntity);\n\n        // get related entities of persisted entity\n        // by example: get category from the passed to persist post entity\n        let relatedEntity: ObjectLiteral|null = relation.getEntityValue(subject.entity!); // by example: relatedEntity is a category here\n        if (relatedEntity === undefined) // if relation is undefined then nothing to update\n            return;\n\n        // if related entity is null then we need to check if there a bind in the database and unset it\n        // if there is no bind in the entity then we don't need to do anything\n        // by example: if post.category = null and category has this post in the database then we unset it\n        if (relatedEntity === null) {\n\n            // it makes sense to update database only there is a previously set value in the database\n            if (relatedEntityDatabaseRelationId) {\n                // todo: probably we can improve this in the future by finding entity with column those values,\n                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n                // we create a new subject which operations will be executed in subject operation executor\n\n                const removedRelatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    parentSubject: subject,\n                    canBeUpdated: true,\n                    identifier: relatedEntityDatabaseRelationId,\n                    changeMaps: [{\n                        relation: relation.inverseRelation!,\n                        value: null\n                    }]\n                });\n                this.subjects.push(removedRelatedEntitySubject);\n            }\n\n            return;\n        } // else means entity is bind in the database\n\n        // extract only relation id from the related entities, since we only need it for comparision\n        // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n        let relationIdMap = relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }\n\n        // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n        let relatedEntitySubject = this.subjects.find(operateSubject => {\n            return !!operateSubject.entity && operateSubject.entity === relatedEntity;\n        });\n\n        // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n        if (relatedEntitySubject)\n            relationIdMap = relatedEntitySubject.identifier;\n\n        // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n        // by example: if post contains category which does not have id(s) yet (because its a new category)\n        //             it means its always newly inserted and relation update operation always must be created for it\n        //             it does not make sense to perform difference operation for it for both add and remove actions\n        if (!relationIdMap) {\n\n            // we decided to remove this error because it brings complications when saving object with non-saved entities\n            // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n            // in this persistence because he didn't pass this entity for save or he did not set cascades\n            // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n            // if (!relatedEntitySubject)\n            //     throw new Error(`One-to-one inverse relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n            //         `entity which does not exist in the database yet, thus cannot be bind in the database. ` +\n            //         `Please setup cascade insertion or save entity before binding it.`);\n            if (!relatedEntitySubject)\n                return;\n\n            // okay, so related subject exist and its marked for insertion, then add a new change map\n            // by example: this will tell category to insert into its post relation our post we are working with\n            //             relatedEntitySubject is newly inserted CategorySubject\n            //             relation.inverseRelation is OneToOne owner relation inside Category\n            //             subject is Post needs to be inserted into Category\n            relatedEntitySubject.changeMaps.push({\n                relation: relation.inverseRelation!,\n                value: subject\n            });\n        }\n\n        // check if this binding really exist in the database\n        // by example: find our post if its already bind to category in the database and its not equal to what user tries to set\n        const areRelatedIdEqualWithDatabase = relatedEntityDatabaseRelationId && OrmUtils.compareIds(relationIdMap, relatedEntityDatabaseRelationId);\n\n        // if they aren't equal it means its a new relation and we need to \"bind\" them\n        // by example: this will tell category to insert into its post relation our post we are working with\n        //             relatedEntitySubject is newly inserted CategorySubject\n        //             relation.inverseRelation is ManyToOne relation inside Category\n        //             subject is Post needs to be inserted into Category\n        if (!areRelatedIdEqualWithDatabase) {\n\n            // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n            // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n            // we create a new subject here:\n            if (!relatedEntitySubject) {\n                relatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    canBeUpdated: true,\n                    identifier: relationIdMap\n                });\n                this.subjects.push(relatedEntitySubject);\n            }\n\n            relatedEntitySubject.changeMaps.push({\n                relation: relation.inverseRelation!,\n                value: subject\n            });\n        }\n    }\n\n}"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}