{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { Brackets } from \"./Brackets\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { SqljsDriver } from \"../driver/sqljs/SqljsDriver\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { CockroachDriver } from \"../driver/cockroachdb/CockroachDriver\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { EntitySchema } from \"../\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { In } from \"../find-options/operator/In\";\nimport { EntityColumnNotFound } from \"../error/EntityColumnNotFound\"; // todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nvar QueryBuilder =\n/** @class */\nfunction () {\n  /**\n   * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n   */\n  function QueryBuilder(connectionOrQueryBuilder, queryRunner) {\n    if (connectionOrQueryBuilder instanceof QueryBuilder) {\n      this.connection = connectionOrQueryBuilder.connection;\n      this.queryRunner = connectionOrQueryBuilder.queryRunner;\n      this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n    } else {\n      this.connection = connectionOrQueryBuilder;\n      this.queryRunner = queryRunner;\n      this.expressionMap = new QueryExpressionMap(this.connection);\n    }\n  }\n\n  Object.defineProperty(QueryBuilder.prototype, \"alias\", {\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get: function () {\n      if (!this.expressionMap.mainAlias) throw new Error(\"Main alias is not set\"); // todo: better exception\n\n      return this.expressionMap.mainAlias.name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n\n  QueryBuilder.prototype.select = function (selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(function (selection) {\n        return {\n          selection: selection\n        };\n      });\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    } // loading it dynamically because of circular issue\n\n\n    var SelectQueryBuilderCls = require(\"./SelectQueryBuilder\").SelectQueryBuilder;\n\n    if (this instanceof SelectQueryBuilderCls) return this;\n    return new SelectQueryBuilderCls(this);\n  };\n  /**\n   * Creates INSERT query.\n   */\n\n\n  QueryBuilder.prototype.insert = function () {\n    this.expressionMap.queryType = \"insert\"; // loading it dynamically because of circular issue\n\n    var InsertQueryBuilderCls = require(\"./InsertQueryBuilder\").InsertQueryBuilder;\n\n    if (this instanceof InsertQueryBuilderCls) return this;\n    return new InsertQueryBuilderCls(this);\n  };\n  /**\n   * Creates UPDATE query and applies given update values.\n   */\n\n\n  QueryBuilder.prototype.update = function (entityOrTableNameUpdateSet, maybeUpdateSet) {\n    var updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;\n    entityOrTableNameUpdateSet = entityOrTableNameUpdateSet instanceof EntitySchema ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;\n\n    if (entityOrTableNameUpdateSet instanceof Function || typeof entityOrTableNameUpdateSet === \"string\") {\n      var mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n      this.expressionMap.setMainAlias(mainAlias);\n    }\n\n    this.expressionMap.queryType = \"update\";\n    this.expressionMap.valuesSet = updateSet; // loading it dynamically because of circular issue\n\n    var UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\").UpdateQueryBuilder;\n\n    if (this instanceof UpdateQueryBuilderCls) return this;\n    return new UpdateQueryBuilderCls(this);\n  };\n  /**\n   * Creates DELETE query.\n   */\n\n\n  QueryBuilder.prototype.delete = function () {\n    this.expressionMap.queryType = \"delete\"; // loading it dynamically because of circular issue\n\n    var DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\").DeleteQueryBuilder;\n\n    if (this instanceof DeleteQueryBuilderCls) return this;\n    return new DeleteQueryBuilderCls(this);\n  };\n\n  QueryBuilder.prototype.softDelete = function () {\n    this.expressionMap.queryType = \"soft-delete\"; // loading it dynamically because of circular issue\n\n    var SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n\n    if (this instanceof SoftDeleteQueryBuilderCls) return this;\n    return new SoftDeleteQueryBuilderCls(this);\n  };\n\n  QueryBuilder.prototype.restore = function () {\n    this.expressionMap.queryType = \"restore\"; // loading it dynamically because of circular issue\n\n    var SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n\n    if (this instanceof SoftDeleteQueryBuilderCls) return this;\n    return new SoftDeleteQueryBuilderCls(this);\n  };\n  /**\n   * Sets entity's relation with which this query builder gonna work.\n   */\n\n\n  QueryBuilder.prototype.relation = function (entityTargetOrPropertyPath, maybePropertyPath) {\n    var entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n    var propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;\n    this.expressionMap.queryType = \"relation\";\n    this.expressionMap.relationPropertyPath = propertyPath;\n\n    if (entityTarget) {\n      var mainAlias = this.createFromAlias(entityTarget);\n      this.expressionMap.setMainAlias(mainAlias);\n    } // loading it dynamically because of circular issue\n\n\n    var RelationQueryBuilderCls = require(\"./RelationQueryBuilder\").RelationQueryBuilder;\n\n    if (this instanceof RelationQueryBuilderCls) return this;\n    return new RelationQueryBuilderCls(this);\n  };\n  /**\n   * Checks if given relation or relations exist in the entity.\n   * Returns true if relation exists, false otherwise.\n   *\n   * todo: move this method to manager? or create a shortcut?\n   */\n\n\n  QueryBuilder.prototype.hasRelation = function (target, relation) {\n    var entityMetadata = this.connection.getMetadata(target);\n    var relations = Array.isArray(relation) ? relation : [relation];\n    return relations.every(function (relation) {\n      return !!entityMetadata.findRelationWithPropertyPath(relation);\n    });\n  };\n  /**\n   * Sets parameter name and its value.\n   */\n\n\n  QueryBuilder.prototype.setParameter = function (key, value) {\n    this.expressionMap.parameters[key] = value;\n    return this;\n  };\n  /**\n   * Adds all parameters from the given object.\n   */\n\n\n  QueryBuilder.prototype.setParameters = function (parameters) {\n    var _this = this; // remove function parameters\n\n\n    Object.keys(parameters).forEach(function (key) {\n      if (parameters[key] instanceof Function) {\n        throw new Error(\"Function parameter isn't supported in the parameters. Please check \\\"\" + key + \"\\\" parameter.\");\n      }\n    }); // set parent query builder parameters as well in sub-query mode\n\n    if (this.expressionMap.parentQueryBuilder) this.expressionMap.parentQueryBuilder.setParameters(parameters);\n    Object.keys(parameters).forEach(function (key) {\n      return _this.setParameter(key, parameters[key]);\n    });\n    return this;\n  };\n  /**\n   * Adds native parameters from the given object.\n   */\n\n\n  QueryBuilder.prototype.setNativeParameters = function (parameters) {\n    var _this = this; // set parent query builder parameters as well in sub-query mode\n\n\n    if (this.expressionMap.parentQueryBuilder) this.expressionMap.parentQueryBuilder.setNativeParameters(parameters);\n    Object.keys(parameters).forEach(function (key) {\n      _this.expressionMap.nativeParameters[key] = parameters[key];\n    });\n    return this;\n  };\n  /**\n   * Gets all parameters.\n   */\n\n\n  QueryBuilder.prototype.getParameters = function () {\n    var parameters = Object.assign({}, this.expressionMap.parameters); // add discriminator column parameter if it exist\n\n    if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {\n      var metadata = this.expressionMap.mainAlias.metadata;\n\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        var values = metadata.childEntityMetadatas.filter(function (childMetadata) {\n          return childMetadata.discriminatorColumn;\n        }).map(function (childMetadata) {\n          return childMetadata.discriminatorValue;\n        });\n        values.push(metadata.discriminatorValue);\n        parameters[\"discriminatorColumnValues\"] = values;\n      }\n    }\n\n    return parameters;\n  };\n  /**\n   * Prints sql to stdout using console.log.\n   */\n\n\n  QueryBuilder.prototype.printSql = function () {\n    var _a = __read(this.getQueryAndParameters(), 2),\n        query = _a[0],\n        parameters = _a[1];\n\n    this.connection.logger.logQuery(query, parameters);\n    return this;\n  };\n  /**\n   * Gets generated sql that will be executed.\n   * Parameters in the query are escaped for the currently used driver.\n   */\n\n\n  QueryBuilder.prototype.getSql = function () {\n    return this.getQueryAndParameters()[0];\n  };\n  /**\n   * Gets query to be executed with all parameters used in it.\n   */\n\n\n  QueryBuilder.prototype.getQueryAndParameters = function () {\n    // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n    var query = this.getQuery();\n    var parameters = this.getParameters();\n    return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\n  };\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n\n\n  QueryBuilder.prototype.execute = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, sql, parameters, queryRunner;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = __read(this.getQueryAndParameters(), 2), sql = _a[0], parameters = _a[1];\n            queryRunner = this.obtainQueryRunner();\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 3, 8]);\n\n            return [4\n            /*yield*/\n            , queryRunner.query(sql, parameters)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _b.sent()];\n          // await is needed here because we are using finally\n\n          case 3:\n            if (!(queryRunner !== this.queryRunner)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 4:\n            _b.sent();\n\n            _b.label = 5;\n\n          case 5:\n            if (!(this.connection.driver instanceof SqljsDriver)) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , this.connection.driver.autoSave()];\n\n          case 6:\n            _b.sent();\n\n            _b.label = 7;\n\n          case 7:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a completely new query builder.\n   * Uses same query runner as current QueryBuilder.\n   */\n\n\n  QueryBuilder.prototype.createQueryBuilder = function () {\n    return new this.constructor(this.connection, this.queryRunner);\n  };\n  /**\n   * Clones query builder as it is.\n   * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n   * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n   * where queryBuilder is cloned QueryBuilder.\n   */\n\n\n  QueryBuilder.prototype.clone = function () {\n    return new this.constructor(this);\n  };\n  /**\n   * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n   * such as finding a specific query in the database server's logs, or for categorization using\n   * an APM product.\n   */\n\n\n  QueryBuilder.prototype.comment = function (comment) {\n    this.expressionMap.comment = comment;\n    return this;\n  };\n  /**\n   * Disables escaping.\n   */\n\n\n  QueryBuilder.prototype.disableEscaping = function () {\n    this.expressionMap.disableEscaping = false;\n    return this;\n  };\n  /**\n   * Escapes table name, column name or alias name using current database's escaping character.\n   */\n\n\n  QueryBuilder.prototype.escape = function (name) {\n    if (!this.expressionMap.disableEscaping) return name;\n    return this.connection.driver.escape(name);\n  };\n  /**\n   * Sets or overrides query builder's QueryRunner.\n   */\n\n\n  QueryBuilder.prototype.setQueryRunner = function (queryRunner) {\n    this.queryRunner = queryRunner;\n    return this;\n  };\n  /**\n   * Indicates if listeners and subscribers must be called before and after query execution.\n   * Enabled by default.\n   */\n\n\n  QueryBuilder.prototype.callListeners = function (enabled) {\n    this.expressionMap.callListeners = enabled;\n    return this;\n  };\n  /**\n   * If set to true the query will be wrapped into a transaction.\n   */\n\n\n  QueryBuilder.prototype.useTransaction = function (enabled) {\n    this.expressionMap.useTransaction = enabled;\n    return this;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets escaped table name with schema name if SqlServer driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n\n\n  QueryBuilder.prototype.getTableName = function (tablePath) {\n    var _this = this;\n\n    return tablePath.split(\".\").map(function (i) {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      if (i === \"\") return i;\n      return _this.escape(i);\n    }).join(\".\");\n  };\n  /**\n   * Gets name of the table where insert should be performed.\n   */\n\n\n  QueryBuilder.prototype.getMainTableName = function () {\n    if (!this.expressionMap.mainAlias) throw new Error(\"Entity where values should be inserted is not specified. Call \\\"qb.into(entity)\\\" method to specify it.\");\n    if (this.expressionMap.mainAlias.hasMetadata) return this.expressionMap.mainAlias.metadata.tablePath;\n    return this.expressionMap.mainAlias.tablePath;\n  };\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n\n\n  QueryBuilder.prototype.createFromAlias = function (entityTarget, aliasName) {\n    // if table has a metadata then find it to properly escape its properties\n    // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n    if (this.connection.hasMetadata(entityTarget)) {\n      var metadata = this.connection.getMetadata(entityTarget);\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        metadata: this.connection.getMetadata(entityTarget),\n        tablePath: metadata.tablePath\n      });\n    } else {\n      if (typeof entityTarget === \"string\") {\n        var isSubquery = entityTarget.substr(0, 1) === \"(\" && entityTarget.substr(-1) === \")\";\n        return this.expressionMap.createAlias({\n          type: \"from\",\n          name: aliasName,\n          tablePath: !isSubquery ? entityTarget : undefined,\n          subQuery: isSubquery ? entityTarget : undefined\n        });\n      }\n\n      var subQueryBuilder = entityTarget(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      var subquery = subQueryBuilder.getQuery();\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        subQuery: subquery\n      });\n    }\n  };\n  /**\n   * Replaces all entity's propertyName to name in the given statement.\n   */\n\n\n  QueryBuilder.prototype.replacePropertyNames = function (statement) {\n    var e_1, _a;\n\n    var _this = this; // Escape special characters in regular expressions\n    // Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n\n\n    var escapeRegExp = function (s) {\n      return s.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    };\n\n    var _loop_1 = function (alias) {\n      var e_2, _d, e_3, _e, e_4, _f, e_5, _g, e_6, _h, e_7, _j;\n\n      if (!alias.hasMetadata) return \"continue\";\n      var replaceAliasNamePrefix = this_1.expressionMap.aliasNamePrefixingEnabled ? alias.name + \".\" : \"\";\n      var replacementAliasNamePrefix = this_1.expressionMap.aliasNamePrefixingEnabled ? this_1.escape(alias.name) + \".\" : \"\";\n      var replacements = {};\n\n      try {\n        // Insert & overwrite the replacements from least to most relevant in our replacements object.\n        // To do this we iterate and overwrite in the order of relevance.\n        // Least to Most Relevant:\n        // * Relation Property Path to first join column key\n        // * Relation Property Path + Column Path\n        // * Column Database Name\n        // * Column Propety Name\n        // * Column Property Path\n        for (var _k = (e_2 = void 0, __values(alias.metadata.relations)), _l = _k.next(); !_l.done; _l = _k.next()) {\n          var relation = _l.value;\n          if (relation.joinColumns.length > 0) replacements[relation.propertyPath] = relation.joinColumns[0].databaseName;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_l && !_l.done && (_d = _k.return)) _d.call(_k);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      try {\n        for (var _m = (e_3 = void 0, __values(alias.metadata.relations)), _o = _m.next(); !_o.done; _o = _m.next()) {\n          var relation = _o.value;\n\n          try {\n            for (var _p = (e_4 = void 0, __values(__spreadArray(__spreadArray([], __read(relation.joinColumns)), __read(relation.inverseJoinColumns)))), _q = _p.next(); !_q.done; _q = _p.next()) {\n              var joinColumn = _q.value;\n              var propertyKey = relation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath;\n              replacements[propertyKey] = joinColumn.databaseName;\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_q && !_q.done && (_f = _p.return)) _f.call(_p);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_o && !_o.done && (_e = _m.return)) _e.call(_m);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      try {\n        for (var _r = (e_5 = void 0, __values(alias.metadata.columns)), _s = _r.next(); !_s.done; _s = _r.next()) {\n          var column = _s.value;\n          replacements[column.databaseName] = column.databaseName;\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_s && !_s.done && (_g = _r.return)) _g.call(_r);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      try {\n        for (var _t = (e_6 = void 0, __values(alias.metadata.columns)), _u = _t.next(); !_u.done; _u = _t.next()) {\n          var column = _u.value;\n          replacements[column.propertyName] = column.databaseName;\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_u && !_u.done && (_h = _t.return)) _h.call(_t);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      try {\n        for (var _v = (e_7 = void 0, __values(alias.metadata.columns)), _w = _v.next(); !_w.done; _w = _v.next()) {\n          var column = _w.value;\n          replacements[column.propertyPath] = column.databaseName;\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (_w && !_w.done && (_j = _v.return)) _j.call(_v);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      }\n\n      var replacementKeys = Object.keys(replacements);\n\n      if (replacementKeys.length) {\n        statement = statement.replace(new RegExp( // Avoid a lookbehind here since it's not well supported\n        \"([ =(]|^.{0})\" + (escapeRegExp(replaceAliasNamePrefix) + \"(\" + replacementKeys.map(escapeRegExp).join(\"|\") + \")\") + \"(?=[ =),]|.{0}$)\", \"gm\"), function (_, pre, p) {\n          return \"\" + pre + replacementAliasNamePrefix + _this.escape(replacements[p]);\n        });\n      }\n    };\n\n    var this_1 = this;\n\n    try {\n      for (var _b = __values(this.expressionMap.aliases), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var alias = _c.value;\n\n        _loop_1(alias);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return statement;\n  };\n\n  QueryBuilder.prototype.createComment = function () {\n    if (!this.expressionMap.comment) {\n      return \"\";\n    } // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n    // In some dialects query nesting is available - but not all.  Because of this, we'll need\n    // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n    // as-is and it should be valid.\n\n\n    return \"/* \" + this.expressionMap.comment.replace(\"*/\", \"\") + \" */ \";\n  };\n  /**\n   * Creates \"WHERE\" expression.\n   */\n\n\n  QueryBuilder.prototype.createWhereExpression = function () {\n    var conditionsArray = [];\n    var whereExpression = this.createWhereExpressionString();\n    whereExpression.trim() && conditionsArray.push(this.createWhereExpressionString());\n\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      var metadata = this.expressionMap.mainAlias.metadata; // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n\n      if (this.expressionMap.queryType === \"select\" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {\n        var column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;\n        var condition = this.replacePropertyNames(column) + \" IS NULL\";\n        conditionsArray.push(condition);\n      }\n\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        var column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;\n        var condition = this.replacePropertyNames(column) + \" IN (:...discriminatorColumnValues)\";\n        conditionsArray.push(condition);\n      }\n    }\n\n    if (this.expressionMap.extraAppendedAndWhereCondition) {\n      var condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\n      conditionsArray.push(condition);\n    }\n\n    if (!conditionsArray.length) {\n      return \"\";\n    } else if (conditionsArray.length === 1) {\n      return \" WHERE \" + conditionsArray[0];\n    } else {\n      return \" WHERE ( \" + conditionsArray.join(\" ) AND ( \") + \" )\";\n    }\n  };\n  /**\n   * Creates \"RETURNING\" / \"OUTPUT\" expression.\n   */\n\n\n  QueryBuilder.prototype.createReturningExpression = function () {\n    var _this = this;\n\n    var columns = this.getReturningColumns();\n    var driver = this.connection.driver; // also add columns we must auto-return to perform entity updation\n    // if user gave his own returning\n\n    if (typeof this.expressionMap.returning !== \"string\" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported()) {\n      columns.push.apply(columns, __spreadArray([], __read(this.expressionMap.extraReturningColumns.filter(function (column) {\n        return columns.indexOf(column) === -1;\n      }))));\n    }\n\n    if (columns.length) {\n      var columnsExpression = columns.map(function (column) {\n        var name = _this.escape(column.databaseName);\n\n        if (driver instanceof SqlServerDriver) {\n          if (_this.expressionMap.queryType === \"insert\" || _this.expressionMap.queryType === \"update\" || _this.expressionMap.queryType === \"soft-delete\" || _this.expressionMap.queryType === \"restore\") {\n            return \"INSERTED.\" + name;\n          } else {\n            return _this.escape(_this.getMainTableName()) + \".\" + name;\n          }\n        } else {\n          return name;\n        }\n      }).join(\", \");\n\n      if (driver instanceof OracleDriver) {\n        columnsExpression += \" INTO \" + columns.map(function (column) {\n          var parameterName = \"output_\" + column.databaseName;\n          _this.expressionMap.nativeParameters[parameterName] = {\n            type: driver.columnTypeToNativeParameter(column.type),\n            dir: driver.oracle.BIND_OUT\n          };\n          return _this.connection.driver.createParameter(parameterName, Object.keys(_this.expressionMap.nativeParameters).length);\n        }).join(\", \");\n      }\n\n      if (driver instanceof SqlServerDriver) {\n        if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\") {\n          columnsExpression += \" INTO @OutputTable\";\n        }\n      }\n\n      return columnsExpression;\n    } else if (typeof this.expressionMap.returning === \"string\") {\n      return this.expressionMap.returning;\n    }\n\n    return \"\";\n  };\n  /**\n   * If returning / output cause is set to array of column names,\n   * then this method will return all column metadatas of those column names.\n   */\n\n\n  QueryBuilder.prototype.getReturningColumns = function () {\n    var _this = this;\n\n    var columns = [];\n\n    if (Array.isArray(this.expressionMap.returning)) {\n      this.expressionMap.returning.forEach(function (columnName) {\n        if (_this.expressionMap.mainAlias.hasMetadata) {\n          columns.push.apply(columns, __spreadArray([], __read(_this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName))));\n        }\n      });\n    }\n\n    return columns;\n  };\n  /**\n   * Concatenates all added where expressions into one string.\n   */\n\n\n  QueryBuilder.prototype.createWhereExpressionString = function () {\n    var _this = this;\n\n    return this.expressionMap.wheres.map(function (where, index) {\n      switch (where.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + _this.replacePropertyNames(where.condition);\n\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + _this.replacePropertyNames(where.condition);\n\n        default:\n          return _this.replacePropertyNames(where.condition);\n      }\n    }).join(\" \");\n  };\n  /**\n   * Creates \"WHERE\" expression and variables for the given \"ids\".\n   */\n\n\n  QueryBuilder.prototype.createWhereIdsExpression = function (ids) {\n    var _a;\n\n    var _this = this;\n\n    var metadata = this.expressionMap.mainAlias.metadata;\n    var normalized = (Array.isArray(ids) ? ids : [ids]).map(function (id) {\n      return metadata.ensureEntityIdMap(id);\n    }); // using in(...ids) for single primary key entities\n\n    if (!metadata.hasMultiplePrimaryKeys && metadata.embeddeds.length === 0) {\n      var primaryColumn_1 = metadata.primaryColumns[0]; // getEntityValue will try to transform `In`, it is a bug\n      // todo: remove this transformer check after #2390 is fixed\n\n      if (!primaryColumn_1.transformer) {\n        return this.computeWhereParameter((_a = {}, _a[primaryColumn_1.propertyName] = In(normalized.map(function (id) {\n          return primaryColumn_1.getEntityValue(id, false);\n        })), _a));\n      }\n    } // create shortcuts for better readability\n\n\n    var alias = this.expressionMap.aliasNamePrefixingEnabled ? this.escape(this.expressionMap.mainAlias.name) + \".\" : \"\";\n    var parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n    var whereStrings = normalized.map(function (id, index) {\n      var whereSubStrings = [];\n      metadata.primaryColumns.forEach(function (primaryColumn, secondIndex) {\n        var parameterName = \"id_\" + index + \"_\" + secondIndex; // whereSubStrings.push(alias + this.escape(primaryColumn.databaseName) + \"=:id_\" + index + \"_\" + secondIndex);\n\n        whereSubStrings.push(alias + _this.escape(primaryColumn.databaseName) + \" = \" + _this.connection.driver.createParameter(parameterName, parameterIndex));\n        _this.expressionMap.nativeParameters[parameterName] = primaryColumn.getEntityValue(id, true);\n        parameterIndex++;\n      });\n      return whereSubStrings.join(\" AND \");\n    });\n    return whereStrings.length > 1 ? \"(\" + whereStrings.map(function (whereString) {\n      return \"(\" + whereString + \")\";\n    }).join(\" OR \") + \")\" : whereStrings[0];\n  };\n  /**\n   * Computes given where argument - transforms to a where string all forms it can take.\n   */\n\n\n  QueryBuilder.prototype.computeWhereParameter = function (where) {\n    var _this = this;\n\n    if (typeof where === \"string\") return where;\n\n    if (where instanceof Brackets) {\n      var whereQueryBuilder = this.createQueryBuilder();\n      whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;\n      whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;\n      whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;\n      where.whereFactory(whereQueryBuilder);\n      var whereString = whereQueryBuilder.createWhereExpressionString();\n      this.setParameters(whereQueryBuilder.getParameters());\n      return whereString ? \"(\" + whereString + \")\" : \"\";\n    } else if (where instanceof Function) {\n      return where(this);\n    } else if (where instanceof Object) {\n      var wheres = Array.isArray(where) ? where : [where];\n      var andConditions = void 0;\n      var parameterIndex_1 = Object.keys(this.expressionMap.nativeParameters).length;\n\n      if (this.expressionMap.mainAlias.hasMetadata) {\n        andConditions = wheres.map(function (where, whereIndex) {\n          var propertyPaths = EntityMetadata.createPropertyPath(_this.expressionMap.mainAlias.metadata, where);\n          return propertyPaths.map(function (propertyPath, propertyIndex) {\n            var columns = _this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(propertyPath);\n\n            if (!columns.length) {\n              throw new EntityColumnNotFound(propertyPath);\n            }\n\n            return columns.map(function (column, columnIndex) {\n              var aliasPath = _this.expressionMap.aliasNamePrefixingEnabled ? _this.alias + \".\" + propertyPath : column.propertyPath;\n              var parameterValue = column.getEntityValue(where, true);\n              var parameterName = \"where_\" + whereIndex + \"_\" + propertyIndex + \"_\" + columnIndex;\n              var parameterBaseCount = Object.keys(_this.expressionMap.nativeParameters).filter(function (x) {\n                return x.startsWith(parameterName);\n              }).length;\n\n              if (parameterValue === null) {\n                return aliasPath + \" IS NULL\";\n              } else if (parameterValue instanceof FindOperator) {\n                var parameters_1 = [];\n\n                if (parameterValue.useParameter) {\n                  if (parameterValue.objectLiteralParameters) {\n                    _this.setParameters(parameterValue.objectLiteralParameters);\n                  } else {\n                    var realParameterValues = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n                    realParameterValues.forEach(function (realParameterValue, realParameterValueIndex) {\n                      _this.expressionMap.nativeParameters[parameterName + (parameterBaseCount + realParameterValueIndex)] = realParameterValue;\n                      parameterIndex_1++;\n                      parameters_1.push(_this.connection.driver.createParameter(parameterName + (parameterBaseCount + realParameterValueIndex), parameterIndex_1 - 1));\n                    });\n                  }\n                }\n\n                return _this.computeFindOperatorExpression(parameterValue, aliasPath, parameters_1);\n              } else {\n                _this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                parameterIndex_1++;\n\n                var parameter = _this.connection.driver.createParameter(parameterName, parameterIndex_1 - 1);\n\n                return aliasPath + \" = \" + parameter;\n              }\n            }).filter(function (expression) {\n              return !!expression;\n            }).join(\" AND \");\n          }).filter(function (expression) {\n            return !!expression;\n          }).join(\" AND \");\n        });\n      } else {\n        andConditions = wheres.map(function (where, whereIndex) {\n          return Object.keys(where).map(function (key, parameterIndex) {\n            var parameterValue = where[key];\n            var aliasPath = _this.expressionMap.aliasNamePrefixingEnabled ? _this.alias + \".\" + key : key;\n\n            if (parameterValue === null) {\n              return aliasPath + \" IS NULL\";\n            } else {\n              var parameterName = \"where_\" + whereIndex + \"_\" + parameterIndex;\n              _this.expressionMap.nativeParameters[parameterName] = parameterValue;\n              parameterIndex++;\n              return aliasPath + \" = \" + _this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n            }\n          }).join(\" AND \");\n        });\n      }\n\n      if (andConditions.length > 1) return andConditions.map(function (where) {\n        return \"(\" + where + \")\";\n      }).join(\" OR \");\n      return andConditions.join(\"\");\n    }\n\n    return \"\";\n  };\n  /**\n   * Gets SQL needs to be inserted into final query.\n   */\n\n\n  QueryBuilder.prototype.computeFindOperatorExpression = function (operator, aliasPath, parameters) {\n    var driver = this.connection.driver;\n\n    switch (operator.type) {\n      case \"not\":\n        if (operator.child) {\n          return \"NOT(\" + this.computeFindOperatorExpression(operator.child, aliasPath, parameters) + \")\";\n        } else {\n          return aliasPath + \" != \" + parameters[0];\n        }\n\n      case \"lessThan\":\n        return aliasPath + \" < \" + parameters[0];\n\n      case \"lessThanOrEqual\":\n        return aliasPath + \" <= \" + parameters[0];\n\n      case \"moreThan\":\n        return aliasPath + \" > \" + parameters[0];\n\n      case \"moreThanOrEqual\":\n        return aliasPath + \" >= \" + parameters[0];\n\n      case \"equal\":\n        return aliasPath + \" = \" + parameters[0];\n\n      case \"ilike\":\n        if (driver instanceof PostgresDriver || driver instanceof CockroachDriver) {\n          return aliasPath + \" ILIKE \" + parameters[0];\n        }\n\n        return \"UPPER(\" + aliasPath + \") LIKE UPPER(\" + parameters[0] + \")\";\n\n      case \"like\":\n        return aliasPath + \" LIKE \" + parameters[0];\n\n      case \"between\":\n        return aliasPath + \" BETWEEN \" + parameters[0] + \" AND \" + parameters[1];\n\n      case \"in\":\n        if (parameters.length === 0) {\n          return \"0=1\";\n        }\n\n        return aliasPath + \" IN (\" + parameters.join(\", \") + \")\";\n\n      case \"any\":\n        return aliasPath + \" = ANY(\" + parameters[0] + \")\";\n\n      case \"isNull\":\n        return aliasPath + \" IS NULL\";\n\n      case \"raw\":\n        if (operator.getSql) {\n          return operator.getSql(aliasPath);\n        } else {\n          return aliasPath + \" = \" + operator.value;\n        }\n\n    }\n\n    throw new TypeError(\"Unsupported FindOperator \" + FindOperator.constructor.name);\n  };\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n\n\n  QueryBuilder.prototype.obtainQueryRunner = function () {\n    return this.queryRunner || this.connection.createQueryRunner();\n  };\n\n  return QueryBuilder;\n}();\n\nexport { QueryBuilder };","map":{"version":3,"sources":["../browser/src/query-builder/QueryBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Connection} from \"../connection/Connection\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {SelectQueryBuilder} from \"./SelectQueryBuilder\";\nimport {UpdateQueryBuilder} from \"./UpdateQueryBuilder\";\nimport {DeleteQueryBuilder} from \"./DeleteQueryBuilder\";\nimport {SoftDeleteQueryBuilder} from \"./SoftDeleteQueryBuilder\";\nimport {InsertQueryBuilder} from \"./InsertQueryBuilder\";\nimport {RelationQueryBuilder} from \"./RelationQueryBuilder\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {Alias} from \"./Alias\";\nimport {Brackets} from \"./Brackets\";\nimport {QueryDeepPartialEntity} from \"./QueryPartialEntity\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {SqljsDriver} from \"../driver/sqljs/SqljsDriver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {CockroachDriver} from \"../driver/cockroachdb/CockroachDriver\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {EntitySchema} from \"../\";\nimport {FindOperator} from \"../find-options/FindOperator\";\nimport {In} from \"../find-options/operator/In\";\nimport {EntityColumnNotFound} from \"../error/EntityColumnNotFound\";\n\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport abstract class QueryBuilder<Entity> {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection on which QueryBuilder was created.\n     */\n    readonly connection: Connection;\n\n    /**\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\n     */\n    readonly expressionMap: QueryExpressionMap;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Query runner used to execute query builder query.\n     */\n    protected queryRunner?: QueryRunner;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(queryBuilder: QueryBuilder<any>);\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connection: Connection, queryRunner?: QueryRunner);\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connectionOrQueryBuilder: Connection|QueryBuilder<any>, queryRunner?: QueryRunner) {\n        if (connectionOrQueryBuilder instanceof QueryBuilder) {\n            this.connection = connectionOrQueryBuilder.connection;\n            this.queryRunner = connectionOrQueryBuilder.queryRunner;\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n\n        } else {\n            this.connection = connectionOrQueryBuilder;\n            this.queryRunner = queryRunner;\n            this.expressionMap = new QueryExpressionMap(this.connection);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    abstract getQuery(): string;\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(`Main alias is not set`); // todo: better exception\n\n        return this.expressionMap.mainAlias.name;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection?: string|string[], selectionAliasName?: string): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map(selection => ({ selection: selection }));\n        } else if (selection) {\n            this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];\n        }\n\n        // loading it dynamically because of circular issue\n        const SelectQueryBuilderCls = require(\"./SelectQueryBuilder\").SelectQueryBuilder;\n        if (this instanceof SelectQueryBuilderCls)\n            return this as any;\n\n        return new SelectQueryBuilderCls(this);\n    }\n\n    /**\n     * Creates INSERT query.\n     */\n    insert(): InsertQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"insert\";\n\n        // loading it dynamically because of circular issue\n        const InsertQueryBuilderCls = require(\"./InsertQueryBuilder\").InsertQueryBuilder;\n        if (this instanceof InsertQueryBuilderCls)\n            return this as any;\n\n        return new InsertQueryBuilderCls(this);\n    }\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(updateSet: QueryDeepPartialEntity<Entity>): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update<Entity>(entity: EntityTarget<Entity>, updateSet?: QueryDeepPartialEntity<Entity>): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query for the given table name and applies given update values.\n     */\n    update(tableName: string, updateSet?: QueryDeepPartialEntity<Entity>): UpdateQueryBuilder<Entity>;\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(entityOrTableNameUpdateSet?: EntityTarget<any>|ObjectLiteral, maybeUpdateSet?: ObjectLiteral): UpdateQueryBuilder<any> {\n        const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet as ObjectLiteral|undefined;\n        entityOrTableNameUpdateSet = entityOrTableNameUpdateSet instanceof EntitySchema ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;\n\n        if (entityOrTableNameUpdateSet instanceof Function || typeof entityOrTableNameUpdateSet === \"string\") {\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n            this.expressionMap.setMainAlias(mainAlias);\n        }\n\n        this.expressionMap.queryType = \"update\";\n        this.expressionMap.valuesSet = updateSet;\n\n        // loading it dynamically because of circular issue\n        const UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\").UpdateQueryBuilder;\n        if (this instanceof UpdateQueryBuilderCls)\n            return this as any;\n\n        return new UpdateQueryBuilderCls(this);\n    }\n\n    /**\n     * Creates DELETE query.\n     */\n    delete(): DeleteQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"delete\";\n\n        // loading it dynamically because of circular issue\n        const DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\").DeleteQueryBuilder;\n        if (this instanceof DeleteQueryBuilderCls)\n            return this as any;\n\n        return new DeleteQueryBuilderCls(this);\n    }\n\n    softDelete(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"soft-delete\";\n\n        // loading it dynamically because of circular issue\n        const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n        if (this instanceof SoftDeleteQueryBuilderCls)\n            return this as any;\n\n        return new SoftDeleteQueryBuilderCls(this);\n    }\n\n    restore(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"restore\";\n\n        // loading it dynamically because of circular issue\n        const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n        if (this instanceof SoftDeleteQueryBuilderCls)\n            return this as any;\n\n        return new SoftDeleteQueryBuilderCls(this);\n    }\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(propertyPath: string): RelationQueryBuilder<Entity>;\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation<T>(entityTarget: EntityTarget<T>, propertyPath: string): RelationQueryBuilder<T>;\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(entityTargetOrPropertyPath: Function|string, maybePropertyPath?: string): RelationQueryBuilder<Entity> {\n        const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n        const propertyPath = arguments.length === 2 ? maybePropertyPath as string : entityTargetOrPropertyPath as string;\n\n        this.expressionMap.queryType = \"relation\";\n        this.expressionMap.relationPropertyPath = propertyPath;\n\n        if (entityTarget) {\n            const mainAlias = this.createFromAlias(entityTarget);\n            this.expressionMap.setMainAlias(mainAlias);\n        }\n\n        // loading it dynamically because of circular issue\n        const RelationQueryBuilderCls = require(\"./RelationQueryBuilder\").RelationQueryBuilder;\n        if (this instanceof RelationQueryBuilderCls)\n            return this as any;\n\n        return new RelationQueryBuilderCls(this);\n    }\n\n\n    /**\n     * Checks if given relation exists in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string): boolean;\n\n    /**\n     * Checks if given relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string[]): boolean;\n\n    /**\n     * Checks if given relation or relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string|string[]): boolean {\n        const entityMetadata = this.connection.getMetadata(target);\n        const relations = Array.isArray(relation) ? relation : [relation];\n        return relations.every(relation => {\n            return !!entityMetadata.findRelationWithPropertyPath(relation);\n        });\n    }\n\n    /**\n     * Sets parameter name and its value.\n     */\n    setParameter(key: string, value: any): this {\n        this.expressionMap.parameters[key] = value;\n        return this;\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     */\n    setParameters(parameters: ObjectLiteral): this {\n\n        // remove function parameters\n        Object.keys(parameters).forEach(key => {\n            if (parameters[key] instanceof Function) {\n                throw new Error(`Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`);\n            }\n        });\n\n        // set parent query builder parameters as well in sub-query mode\n        if (this.expressionMap.parentQueryBuilder)\n            this.expressionMap.parentQueryBuilder.setParameters(parameters);\n\n        Object.keys(parameters).forEach(key => this.setParameter(key, parameters[key]));\n        return this;\n    }\n\n    /**\n     * Adds native parameters from the given object.\n     */\n    setNativeParameters(parameters: ObjectLiteral): this {\n\n        // set parent query builder parameters as well in sub-query mode\n        if (this.expressionMap.parentQueryBuilder)\n            this.expressionMap.parentQueryBuilder.setNativeParameters(parameters);\n\n        Object.keys(parameters).forEach(key => {\n            this.expressionMap.nativeParameters[key] = parameters[key];\n        });\n        return this;\n    }\n\n    /**\n     * Gets all parameters.\n     */\n    getParameters(): ObjectLiteral {\n        const parameters: ObjectLiteral = Object.assign({}, this.expressionMap.parameters);\n\n        // add discriminator column parameter if it exist\n        if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const values = metadata.childEntityMetadatas\n                    .filter(childMetadata => childMetadata.discriminatorColumn)\n                    .map(childMetadata => childMetadata.discriminatorValue);\n                values.push(metadata.discriminatorValue);\n                parameters[\"discriminatorColumnValues\"] = values;\n            }\n        }\n\n        return parameters;\n    }\n\n    /**\n     * Prints sql to stdout using console.log.\n     */\n    printSql(): this { // TODO rename to logSql()\n        const [query, parameters] = this.getQueryAndParameters();\n        this.connection.logger.logQuery(query, parameters);\n        return this;\n    }\n\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql(): string {\n        return this.getQueryAndParameters()[0];\n    }\n\n    /**\n     * Gets query to be executed with all parameters used in it.\n     */\n    getQueryAndParameters(): [string, any[]] {\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n        const query = this.getQuery();\n        const parameters = this.getParameters();\n        return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<any> {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        try {\n            return await queryRunner.query(sql, parameters);  // await is needed here because we are using finally\n\n        } finally {\n            if (queryRunner !== this.queryRunner) { // means we created our own query runner\n                await queryRunner.release();\n            }\n            if (this.connection.driver instanceof SqljsDriver) {\n                await this.connection.driver.autoSave();\n            }\n        }\n    }\n\n    /**\n     * Creates a completely new query builder.\n     * Uses same query runner as current QueryBuilder.\n     */\n    createQueryBuilder(): this {\n        return new (this.constructor as any)(this.connection, this.queryRunner);\n    }\n\n    /**\n     * Clones query builder as it is.\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n     * where queryBuilder is cloned QueryBuilder.\n     */\n    clone(): this {\n        return new (this.constructor as any)(this);\n    }\n\n    /**\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n     * such as finding a specific query in the database server's logs, or for categorization using\n     * an APM product.\n     */\n    comment(comment: string): this {\n        this.expressionMap.comment = comment;\n        return this;\n    }\n\n    /**\n     * Disables escaping.\n     */\n    disableEscaping(): this {\n        this.expressionMap.disableEscaping = false;\n        return this;\n    }\n\n    /**\n     * Escapes table name, column name or alias name using current database's escaping character.\n     */\n    escape(name: string): string {\n        if (!this.expressionMap.disableEscaping)\n            return name;\n        return this.connection.driver.escape(name);\n    }\n\n    /**\n     * Sets or overrides query builder's QueryRunner.\n     */\n    setQueryRunner(queryRunner: QueryRunner): this {\n        this.queryRunner = queryRunner;\n        return this;\n    }\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callListeners(enabled: boolean): this {\n        this.expressionMap.callListeners = enabled;\n        return this;\n    }\n\n    /**\n     * If set to true the query will be wrapped into a transaction.\n     */\n    useTransaction(enabled: boolean): this {\n        this.expressionMap.useTransaction = enabled;\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets escaped table name with schema name if SqlServer driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath.split(\".\")\n            .map(i => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                if (i === \"\")\n                    return i;\n                return this.escape(i);\n            }).join(\".\");\n    }\n\n    /**\n     * Gets name of the table where insert should be performed.\n     */\n    protected getMainTableName(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new Error(`Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`);\n\n        if (this.expressionMap.mainAlias.hasMetadata)\n            return this.expressionMap.mainAlias.metadata.tablePath;\n\n        return this.expressionMap.mainAlias.tablePath!;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    protected createFromAlias(entityTarget: EntityTarget<any>|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName?: string): Alias {\n\n        // if table has a metadata then find it to properly escape its properties\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n        if (this.connection.hasMetadata(entityTarget)) {\n            const metadata = this.connection.getMetadata(entityTarget);\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                metadata: this.connection.getMetadata(entityTarget),\n                tablePath: metadata.tablePath\n            });\n\n        } else {\n            if (typeof entityTarget === \"string\") {\n                const isSubquery = entityTarget.substr(0, 1) === \"(\" && entityTarget.substr(-1) === \")\";\n\n                return this.expressionMap.createAlias({\n                    type: \"from\",\n                    name: aliasName,\n                    tablePath: !isSubquery ? entityTarget as string : undefined,\n                    subQuery: isSubquery ? entityTarget : undefined,\n                });\n            }\n\n            const subQueryBuilder: SelectQueryBuilder<any> = (entityTarget as any)(((this as any) as SelectQueryBuilder<any>).subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            const subquery = subQueryBuilder.getQuery();\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                subQuery: subquery\n            });\n        }\n    }\n\n    /**\n     * Replaces all entity's propertyName to name in the given statement.\n     */\n    protected replacePropertyNames(statement: string) {\n        // Escape special characters in regular expressions\n        // Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n        const escapeRegExp = (s: String) => s.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n        for (const alias of this.expressionMap.aliases) {\n            if (!alias.hasMetadata) continue;\n            const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.` : \"\";\n            const replacementAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled ? `${this.escape(alias.name)}.` : \"\";\n\n            const replacements: { [key: string]: string } = {};\n\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\n            // To do this we iterate and overwrite in the order of relevance.\n            // Least to Most Relevant:\n            // * Relation Property Path to first join column key\n            // * Relation Property Path + Column Path\n            // * Column Database Name\n            // * Column Propety Name\n            // * Column Property Path\n\n            for (const relation of alias.metadata.relations) {\n                if (relation.joinColumns.length > 0)\n                    replacements[relation.propertyPath] = relation.joinColumns[0].databaseName;\n            }\n\n            for (const relation of alias.metadata.relations) {\n                for (const joinColumn of [...relation.joinColumns, ...relation.inverseJoinColumns]) {\n                    const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn!.propertyPath}`;\n                    replacements[propertyKey] = joinColumn.databaseName;\n                }\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[column.databaseName] = column.databaseName;\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[column.propertyName] = column.databaseName;\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[column.propertyPath] = column.databaseName;\n            }\n\n            const replacementKeys = Object.keys(replacements);\n\n            if (replacementKeys.length) {\n                statement = statement.replace(new RegExp(\n                    // Avoid a lookbehind here since it's not well supported\n                    `([ =\\(]|^.{0})` +\n                    `${escapeRegExp(replaceAliasNamePrefix)}(${replacementKeys.map(escapeRegExp).join(\"|\")})` +\n                    `(?=[ =\\)\\,]|.{0}$)`,\n                    \"gm\"\n                ), (_, pre, p) =>\n                    `${pre}${replacementAliasNamePrefix}${this.escape(replacements[p])}`\n                );\n            }\n        }\n\n        return statement;\n    }\n\n    protected createComment(): string {\n        if (!this.expressionMap.comment) {\n            return \"\";\n        }\n\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n        // as-is and it should be valid.\n\n        return `/* ${this.expressionMap.comment.replace(\"*/\", \"\")} */ `;\n    }\n\n    /**\n     * Creates \"WHERE\" expression.\n     */\n    protected createWhereExpression() {\n        const conditionsArray = [];\n\n        const whereExpression = this.createWhereExpressionString();\n        whereExpression.trim() && conditionsArray.push(this.createWhereExpressionString());\n\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n            if (this.expressionMap.queryType === \"select\" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name + \".\" + metadata.deleteDateColumn.propertyName\n                    : metadata.deleteDateColumn.propertyName;\n\n                const condition = `${this.replacePropertyNames(column)} IS NULL`;\n                conditionsArray.push(condition);\n            }\n\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name + \".\" + metadata.discriminatorColumn.databaseName\n                    : metadata.discriminatorColumn.databaseName;\n\n                const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;\n                conditionsArray.push(condition);\n            }\n        }\n\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\n            const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\n            conditionsArray.push(condition);\n        }\n\n        if (!conditionsArray.length) {\n            return \"\";\n        } else if (conditionsArray.length === 1) {\n            return ` WHERE ${conditionsArray[0]}`;\n        } else {\n            return ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`;\n        }\n    }\n\n    /**\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\n     */\n    protected createReturningExpression(): string {\n        const columns = this.getReturningColumns();\n        const driver = this.connection.driver;\n\n        // also add columns we must auto-return to perform entity updation\n        // if user gave his own returning\n        if (typeof this.expressionMap.returning !== \"string\" &&\n            this.expressionMap.extraReturningColumns.length > 0 &&\n            driver.isReturningSqlSupported()) {\n            columns.push(...this.expressionMap.extraReturningColumns.filter(column => {\n                return columns.indexOf(column) === -1;\n            }));\n        }\n\n        if (columns.length) {\n            let columnsExpression = columns.map(column => {\n                const name = this.escape(column.databaseName);\n                if (driver instanceof SqlServerDriver) {\n                    if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\" || this.expressionMap.queryType === \"soft-delete\" || this.expressionMap.queryType === \"restore\") {\n                        return \"INSERTED.\" + name;\n                    } else {\n                        return this.escape(this.getMainTableName()) + \".\" + name;\n                    }\n                } else {\n                    return name;\n                }\n            }).join(\", \");\n\n            if (driver instanceof OracleDriver) {\n                columnsExpression += \" INTO \" + columns.map(column => {\n                    const parameterName = \"output_\" + column.databaseName;\n                    this.expressionMap.nativeParameters[parameterName] = { type: driver.columnTypeToNativeParameter(column.type), dir: driver.oracle.BIND_OUT };\n                    return this.connection.driver.createParameter(parameterName, Object.keys(this.expressionMap.nativeParameters).length);\n                }).join(\", \");\n            }\n\n            if (driver instanceof SqlServerDriver) {\n                if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\") {\n                    columnsExpression += \" INTO @OutputTable\";\n                }\n            }\n\n            return columnsExpression;\n\n        } else if (typeof this.expressionMap.returning === \"string\") {\n            return this.expressionMap.returning;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * If returning / output cause is set to array of column names,\n     * then this method will return all column metadatas of those column names.\n     */\n    protected getReturningColumns(): ColumnMetadata[] {\n        const columns: ColumnMetadata[] = [];\n        if (Array.isArray(this.expressionMap.returning)) {\n            (this.expressionMap.returning as string[]).forEach(columnName => {\n                if (this.expressionMap.mainAlias!.hasMetadata) {\n                    columns.push(...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(columnName));\n                }\n            });\n        }\n        return columns;\n    }\n\n    /**\n     * Concatenates all added where expressions into one string.\n     */\n    protected createWhereExpressionString(): string {\n        return this.expressionMap.wheres.map((where, index) => {\n            switch (where.type) {\n                case \"and\":\n                    return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(where.condition);\n                case \"or\":\n                    return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(where.condition);\n                default:\n                    return this.replacePropertyNames(where.condition);\n            }\n        }).join(\" \");\n    }\n\n    /**\n     * Creates \"WHERE\" expression and variables for the given \"ids\".\n     */\n    protected createWhereIdsExpression(ids: any|any[]): string {\n        const metadata = this.expressionMap.mainAlias!.metadata;\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map(id => metadata.ensureEntityIdMap(id));\n\n        // using in(...ids) for single primary key entities\n        if (!metadata.hasMultiplePrimaryKeys\n            && metadata.embeddeds.length === 0\n        ) {\n            const primaryColumn = metadata.primaryColumns[0];\n\n            // getEntityValue will try to transform `In`, it is a bug\n            // todo: remove this transformer check after #2390 is fixed\n            if (!primaryColumn.transformer) {\n                return this.computeWhereParameter({\n                    [primaryColumn.propertyName]: In(\n                        normalized.map(id => primaryColumn.getEntityValue(id, false))\n                    )\n                });\n            }\n        }\n\n        // create shortcuts for better readability\n        const alias = this.expressionMap.aliasNamePrefixingEnabled ? this.escape(this.expressionMap.mainAlias!.name) + \".\" : \"\";\n        let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n        const whereStrings = normalized.map((id, index) => {\n            const whereSubStrings: string[] = [];\n            metadata.primaryColumns.forEach((primaryColumn, secondIndex) => {\n                const parameterName = \"id_\" + index + \"_\" + secondIndex;\n                // whereSubStrings.push(alias + this.escape(primaryColumn.databaseName) + \"=:id_\" + index + \"_\" + secondIndex);\n                whereSubStrings.push(alias + this.escape(primaryColumn.databaseName) + \" = \" + this.connection.driver.createParameter(parameterName, parameterIndex));\n                this.expressionMap.nativeParameters[parameterName] = primaryColumn.getEntityValue(id, true);\n                parameterIndex++;\n            });\n            return whereSubStrings.join(\" AND \");\n        });\n\n        return whereStrings.length > 1\n            ? \"(\" + whereStrings.map(whereString => \"(\" + whereString + \")\").join(\" OR \") + \")\"\n            : whereStrings[0];\n    }\n\n    /**\n     * Computes given where argument - transforms to a where string all forms it can take.\n     */\n    protected computeWhereParameter(where: string|((qb: this) => string)|Brackets|ObjectLiteral|ObjectLiteral[]) {\n        if (typeof where === \"string\")\n            return where;\n\n        if (where instanceof Brackets) {\n            const whereQueryBuilder = this.createQueryBuilder();\n            whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;\n            whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;\n            where.whereFactory(whereQueryBuilder as any);\n            const whereString = whereQueryBuilder.createWhereExpressionString();\n            this.setParameters(whereQueryBuilder.getParameters());\n            return whereString ? \"(\" + whereString + \")\" : \"\";\n\n        } else if (where instanceof Function) {\n            return where(this);\n\n        } else if (where instanceof Object) {\n            const wheres: ObjectLiteral[] = Array.isArray(where) ? where : [where];\n            let andConditions: string[];\n            let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n\n            if (this.expressionMap.mainAlias!.hasMetadata) {\n                andConditions = wheres.map((where, whereIndex) => {\n                    const propertyPaths = EntityMetadata.createPropertyPath(this.expressionMap.mainAlias!.metadata, where);\n\n                    return propertyPaths.map((propertyPath, propertyIndex) => {\n                        const columns = this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(propertyPath);\n\n                        if (!columns.length) {\n                            throw new EntityColumnNotFound(propertyPath);\n                        }\n\n                        return columns.map((column, columnIndex) => {\n\n                            const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${propertyPath}` : column.propertyPath;\n                            let parameterValue = column.getEntityValue(where, true);\n                            const parameterName = \"where_\" + whereIndex + \"_\" + propertyIndex + \"_\" + columnIndex;\n                            const parameterBaseCount = Object.keys(this.expressionMap.nativeParameters).filter(x => x.startsWith(parameterName)).length;\n\n                            if (parameterValue === null) {\n                                return `${aliasPath} IS NULL`;\n\n                            } else if (parameterValue instanceof FindOperator) {\n                                let parameters: any[] = [];\n                                if (parameterValue.useParameter) {\n                                    if (parameterValue.objectLiteralParameters) {\n                                        this.setParameters(parameterValue.objectLiteralParameters);\n                                    } else {\n                                        const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n                                        realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n                                            this.expressionMap.nativeParameters[parameterName + (parameterBaseCount + realParameterValueIndex)] = realParameterValue;\n                                            parameterIndex++;\n                                            parameters.push(this.connection.driver.createParameter(parameterName + (parameterBaseCount + realParameterValueIndex), parameterIndex - 1));\n                                        });\n                                    }\n                                }\n\n                                return this.computeFindOperatorExpression(parameterValue, aliasPath, parameters);\n                            } else {\n                                this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                                parameterIndex++;\n                                const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n                                return `${aliasPath} = ${parameter}`;\n                            }\n\n                        }).filter(expression => !!expression).join(\" AND \");\n                    }).filter(expression => !!expression).join(\" AND \");\n                });\n\n            } else {\n                andConditions = wheres.map((where, whereIndex) => {\n                    return Object.keys(where).map((key, parameterIndex) => {\n                        const parameterValue = where[key];\n                        const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;\n                        if (parameterValue === null) {\n                            return `${aliasPath} IS NULL`;\n\n                        } else {\n                            const parameterName = \"where_\" + whereIndex + \"_\" + parameterIndex;\n                            this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                            parameterIndex++;\n                            return `${aliasPath} = ${this.connection.driver.createParameter(parameterName, parameterIndex - 1)}`;\n                        }\n                    }).join(\" AND \");\n                });\n            }\n\n            if (andConditions.length > 1)\n                return andConditions.map(where => \"(\" + where + \")\").join(\" OR \");\n\n            return andConditions.join(\"\");\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Gets SQL needs to be inserted into final query.\n     */\n    protected computeFindOperatorExpression(operator: FindOperator<any>, aliasPath: string, parameters: any[]): string {\n        const { driver } = this.connection;\n\n        switch (operator.type) {\n            case \"not\":\n                if (operator.child) {\n                    return `NOT(${this.computeFindOperatorExpression(operator.child, aliasPath, parameters)})`;\n                } else {\n                    return `${aliasPath} != ${parameters[0]}`;\n                }\n            case \"lessThan\":\n                return `${aliasPath} < ${parameters[0]}`;\n            case \"lessThanOrEqual\":\n                return `${aliasPath} <= ${parameters[0]}`;\n            case \"moreThan\":\n                return `${aliasPath} > ${parameters[0]}`;\n            case \"moreThanOrEqual\":\n                return `${aliasPath} >= ${parameters[0]}`;\n            case \"equal\":\n                return `${aliasPath} = ${parameters[0]}`;\n            case \"ilike\":\n                if (driver instanceof PostgresDriver || driver instanceof CockroachDriver) {\n                    return `${aliasPath} ILIKE ${parameters[0]}`;\n                }\n\n                return `UPPER(${aliasPath}) LIKE UPPER(${parameters[0]})`;\n            case \"like\":\n                return `${aliasPath} LIKE ${parameters[0]}`;\n            case \"between\":\n                return `${aliasPath} BETWEEN ${parameters[0]} AND ${parameters[1]}`;\n            case \"in\":\n                if (parameters.length === 0) {\n                    return \"0=1\";\n                }\n                return `${aliasPath} IN (${parameters.join(\", \")})`;\n            case \"any\":\n                return `${aliasPath} = ANY(${parameters[0]})`;\n            case \"isNull\":\n                return `${aliasPath} IS NULL`;\n            case \"raw\":\n                if (operator.getSql) {\n                    return operator.getSql(aliasPath);\n                } else {\n                    return `${aliasPath} = ${operator.value}`;\n                }\n        }\n\n        throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner();\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}