{"ast":null,"code":"import { __awaiter, __extends, __generator, __read } from \"tslib\";\nimport { TransactionAlreadyStartedError } from \"../../error/TransactionAlreadyStartedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\nimport { Query } from \"../Query\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nvar AbstractSqliteQueryRunner =\n/** @class */\nfunction (_super) {\n  __extends(AbstractSqliteQueryRunner, _super); // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n\n  function AbstractSqliteQueryRunner() {\n    return _super.call(this) || this;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.connect = function () {\n    return Promise.resolve(this.driver.databaseConnection);\n  };\n  /**\n   * Releases used database connection.\n   * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.release = function () {\n    this.loadedTables = [];\n    this.clearSqlMemory();\n    return Promise.resolve();\n  };\n  /**\n   * Starts transaction.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.startTransaction = function (isolationLevel) {\n    return __awaiter(this, void 0, void 0, function () {\n      var beforeBroadcastResult, afterBroadcastResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.isTransactionActive) throw new TransactionAlreadyStartedError();\n            if (!isolationLevel) return [3\n            /*break*/\n            , 4];\n\n            if (isolationLevel !== \"READ UNCOMMITTED\" && isolationLevel !== \"SERIALIZABLE\") {\n              throw new Error(\"SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation\");\n            }\n\n            if (!(isolationLevel === \"READ UNCOMMITTED\")) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.query(\"PRAGMA read_uncommitted = true\")];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.query(\"PRAGMA read_uncommitted = false\")];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            beforeBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastBeforeTransactionStartEvent(beforeBroadcastResult);\n            if (!(beforeBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , Promise.all(beforeBroadcastResult.promises)];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            this.isTransactionActive = true;\n            return [4\n            /*yield*/\n            , this.query(\"BEGIN TRANSACTION\")];\n\n          case 7:\n            _a.sent();\n\n            afterBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastAfterTransactionStartEvent(afterBroadcastResult);\n            if (!(afterBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , Promise.all(afterBroadcastResult.promises)];\n\n          case 8:\n            _a.sent();\n\n            _a.label = 9;\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.commitTransaction = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var beforeBroadcastResult, afterBroadcastResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.isTransactionActive) throw new TransactionNotStartedError();\n            beforeBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastBeforeTransactionCommitEvent(beforeBroadcastResult);\n            if (!(beforeBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all(beforeBroadcastResult.promises)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.query(\"COMMIT\")];\n\n          case 3:\n            _a.sent();\n\n            this.isTransactionActive = false;\n            afterBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastAfterTransactionCommitEvent(afterBroadcastResult);\n            if (!(afterBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , Promise.all(afterBroadcastResult.promises)];\n\n          case 4:\n            _a.sent();\n\n            _a.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.rollbackTransaction = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var beforeBroadcastResult, afterBroadcastResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.isTransactionActive) throw new TransactionNotStartedError();\n            beforeBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastBeforeTransactionRollbackEvent(beforeBroadcastResult);\n            if (!(beforeBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all(beforeBroadcastResult.promises)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.query(\"ROLLBACK\")];\n\n          case 3:\n            _a.sent();\n\n            this.isTransactionActive = false;\n            afterBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastAfterTransactionRollbackEvent(afterBroadcastResult);\n            if (!(afterBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , Promise.all(afterBroadcastResult.promises)];\n\n          case 4:\n            _a.sent();\n\n            _a.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Returns raw data stream.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {\n    throw new Error(\"Stream is not supported by sqlite driver.\");\n  };\n  /**\n   * Returns all available database names including system databases.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.getDatabases = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve([])];\n      });\n    });\n  };\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.getSchemas = function (database) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve([])];\n      });\n    });\n  };\n  /**\n   * Checks if database with the given name exist.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.hasDatabase = function (database) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve(false)];\n      });\n    });\n  };\n  /**\n   * Loads currently using database\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.getCurrentDatabase = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve(undefined)];\n      });\n    });\n  };\n  /**\n   * Checks if schema with the given name exist.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.hasSchema = function (schema) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error(\"This driver does not support table schemas\");\n      });\n    });\n  };\n  /**\n   * Loads currently using database schema\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.getCurrentSchema = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve(undefined)];\n      });\n    });\n  };\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.hasTable = function (tableOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tableName, sql, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n            sql = \"SELECT * FROM \\\"sqlite_master\\\" WHERE \\\"type\\\" = 'table' AND \\\"name\\\" = '\" + tableName + \"'\";\n            return [4\n            /*yield*/\n            , this.query(sql)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , result.length ? true : false];\n        }\n      });\n    });\n  };\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.hasColumn = function (tableOrName, columnName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tableName, sql, columns;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n            sql = \"PRAGMA table_info(\\\"\" + tableName + \"\\\")\";\n            return [4\n            /*yield*/\n            , this.query(sql)];\n\n          case 1:\n            columns = _a.sent();\n            return [2\n            /*return*/\n            , !!columns.find(function (column) {\n              return column[\"name\"] === columnName;\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new database.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createDatabase = function (database, ifNotExist) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve()];\n      });\n    });\n  };\n  /**\n   * Drops database.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropDatabase = function (database, ifExist) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve()];\n      });\n    });\n  };\n  /**\n   * Creates a new table schema.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createSchema = function (schema, ifNotExist) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve()];\n      });\n    });\n  };\n  /**\n   * Drops table schema.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropSchema = function (schemaPath, ifExist) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve()];\n      });\n    });\n  };\n  /**\n   * Creates a new table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createTable = function (table, ifNotExist, createForeignKeys, createIndices) {\n    if (ifNotExist === void 0) {\n      ifNotExist = false;\n    }\n\n    if (createForeignKeys === void 0) {\n      createForeignKeys = true;\n    }\n\n    if (createIndices === void 0) {\n      createIndices = true;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var upQueries, downQueries, isTableExist;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            upQueries = [];\n            downQueries = [];\n            if (!ifNotExist) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.hasTable(table)];\n\n          case 1:\n            isTableExist = _a.sent();\n            if (isTableExist) return [2\n            /*return*/\n            , Promise.resolve()];\n            _a.label = 2;\n\n          case 2:\n            upQueries.push(this.createTableSql(table, createForeignKeys));\n            downQueries.push(this.dropTableSql(table));\n\n            if (createIndices) {\n              table.indices.forEach(function (index) {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name) index.name = _this.connection.namingStrategy.indexName(table.name, index.columnNames, index.where);\n                upQueries.push(_this.createIndexSql(table, index));\n                downQueries.push(_this.dropIndexSql(index));\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.executeQueries(upQueries, downQueries)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropTable = function (tableOrName, ifExist, dropForeignKeys, dropIndices) {\n    if (dropForeignKeys === void 0) {\n      dropForeignKeys = true;\n    }\n\n    if (dropIndices === void 0) {\n      dropIndices = true;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var isTableExist, createForeignKeys, table, _a, upQueries, downQueries;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!ifExist) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.hasTable(tableOrName)];\n\n          case 1:\n            isTableExist = _b.sent();\n            if (!isTableExist) return [2\n            /*return*/\n            , Promise.resolve()];\n            _b.label = 2;\n\n          case 2:\n            createForeignKeys = dropForeignKeys;\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 3];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            table = _a;\n            upQueries = [];\n            downQueries = [];\n\n            if (dropIndices) {\n              table.indices.forEach(function (index) {\n                upQueries.push(_this.dropIndexSql(index));\n                downQueries.push(_this.createIndexSql(table, index));\n              });\n            }\n\n            upQueries.push(this.dropTableSql(table, ifExist));\n            downQueries.push(this.createTableSql(table, createForeignKeys));\n            return [4\n            /*yield*/\n            , this.executeQueries(upQueries, downQueries)];\n\n          case 6:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new view.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createView = function (view) {\n    return __awaiter(this, void 0, void 0, function () {\n      var upQueries, downQueries;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            upQueries = [];\n            downQueries = [];\n            upQueries.push(this.createViewSql(view));\n            upQueries.push(this.insertViewDefinitionSql(view));\n            downQueries.push(this.dropViewSql(view));\n            downQueries.push(this.deleteViewDefinitionSql(view));\n            return [4\n            /*yield*/\n            , this.executeQueries(upQueries, downQueries)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops the view.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropView = function (target) {\n    return __awaiter(this, void 0, void 0, function () {\n      var viewName, view, upQueries, downQueries;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            viewName = target instanceof View ? target.name : target;\n            return [4\n            /*yield*/\n            , this.getCachedView(viewName)];\n\n          case 1:\n            view = _a.sent();\n            upQueries = [];\n            downQueries = [];\n            upQueries.push(this.deleteViewDefinitionSql(view));\n            upQueries.push(this.dropViewSql(view));\n            downQueries.push(this.insertViewDefinitionSql(view));\n            downQueries.push(this.createViewSql(view));\n            return [4\n            /*yield*/\n            , this.executeQueries(upQueries, downQueries)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Renames the given table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.renameTable = function (oldTableOrName, newTableName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var oldTable, _a, newTable, up, down;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(oldTableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = oldTableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(oldTableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            oldTable = _a;\n            newTable = oldTable.clone();\n            newTable.name = newTableName;\n            up = new Query(\"ALTER TABLE \\\"\" + oldTable.name + \"\\\" RENAME TO \\\"\" + newTableName + \"\\\"\");\n            down = new Query(\"ALTER TABLE \\\"\" + newTableName + \"\\\" RENAME TO \\\"\" + oldTable.name + \"\\\"\");\n            return [4\n            /*yield*/\n            , this.executeQueries(up, down)];\n\n          case 4:\n            _b.sent(); // rename old table;\n\n\n            oldTable.name = newTable.name; // rename unique constraints\n\n            newTable.uniques.forEach(function (unique) {\n              unique.name = _this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n            }); // rename foreign key constraints\n\n            newTable.foreignKeys.forEach(function (foreignKey) {\n              foreignKey.name = _this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, foreignKey.referencedTableName, foreignKey.referencedColumnNames);\n            }); // rename indices\n\n            newTable.indices.forEach(function (index) {\n              index.name = _this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n            }); // recreate table with new constraint names\n\n            return [4\n            /*yield*/\n            , this.recreateTable(newTable, oldTable)];\n\n          case 5:\n            // recreate table with new constraint names\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new column from the column in the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.addColumn = function (tableOrName, column) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            return [2\n            /*return*/\n            , this.addColumns(table, [column])];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new columns from the column in the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.addColumns = function (tableOrName, columns) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            columns.forEach(function (column) {\n              return changedTable.addColumn(column);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Renames column in the given table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, oldColumn, newColumn;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(function (c) {\n              return c.name === oldTableColumnOrName;\n            });\n            if (!oldColumn) throw new Error(\"Column \\\"\" + oldTableColumnOrName + \"\\\" was not found in the \\\"\" + table.name + \"\\\" table.\");\n            newColumn = undefined;\n\n            if (newTableColumnOrName instanceof TableColumn) {\n              newColumn = newTableColumnOrName;\n            } else {\n              newColumn = oldColumn.clone();\n              newColumn.name = newTableColumnOrName;\n            }\n\n            return [2\n            /*return*/\n            , this.changeColumn(table, oldColumn, newColumn)];\n        }\n      });\n    });\n  };\n  /**\n   * Changes a column in the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, oldColumn;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(function (c) {\n              return c.name === oldTableColumnOrName;\n            });\n            if (!oldColumn) throw new Error(\"Column \\\"\" + oldTableColumnOrName + \"\\\" was not found in the \\\"\" + table.name + \"\\\" table.\");\n            return [4\n            /*yield*/\n            , this.changeColumns(table, [{\n              oldColumn: oldColumn,\n              newColumn: newColumn\n            }])];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Changes a column in the table.\n   * Changed column looses all its keys in the db.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.changeColumns = function (tableOrName, changedColumns) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            changedColumns.forEach(function (changedColumnSet) {\n              if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {\n                changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach(function (unique) {\n                  unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                  unique.columnNames.push(changedColumnSet.newColumn.name);\n                  unique.name = _this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);\n                });\n                changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach(function (fk) {\n                  fk.columnNames.splice(fk.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                  fk.columnNames.push(changedColumnSet.newColumn.name);\n                  fk.name = _this.connection.namingStrategy.foreignKeyName(changedTable, fk.columnNames, fk.referencedTableName, fk.referencedColumnNames);\n                });\n                changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach(function (index) {\n                  index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                  index.columnNames.push(changedColumnSet.newColumn.name);\n                  index.name = _this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);\n                });\n              }\n\n              var originalColumn = changedTable.columns.find(function (column) {\n                return column.name === changedColumnSet.oldColumn.name;\n              });\n              if (originalColumn) changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops column in the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropColumn = function (tableOrName, columnOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, column;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);\n            if (!column) throw new Error(\"Column \\\"\" + columnOrName + \"\\\" was not found in table \\\"\" + table.name + \"\\\"\");\n            return [4\n            /*yield*/\n            , this.dropColumns(table, [column])];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops the columns in the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropColumns = function (tableOrName, columns) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            columns.forEach(function (column) {\n              changedTable.removeColumn(column);\n              changedTable.findColumnUniques(column).forEach(function (unique) {\n                return changedTable.removeUniqueConstraint(unique);\n              });\n              changedTable.findColumnIndices(column).forEach(function (index) {\n                return changedTable.removeIndex(index);\n              });\n              changedTable.findColumnForeignKeys(column).forEach(function (fk) {\n                return changedTable.removeForeignKey(fk);\n              });\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent(); // remove column and its constraints from original table.\n\n\n            columns.forEach(function (column) {\n              table.removeColumn(column);\n              table.findColumnUniques(column).forEach(function (unique) {\n                return table.removeUniqueConstraint(unique);\n              });\n              table.findColumnIndices(column).forEach(function (index) {\n                return table.removeIndex(index);\n              });\n              table.findColumnForeignKeys(column).forEach(function (fk) {\n                return table.removeForeignKey(fk);\n              });\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new primary key.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createPrimaryKey = function (tableOrName, columnNames) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            changedTable.columns.forEach(function (column) {\n              if (columnNames.find(function (columnName) {\n                return columnName === column.name;\n              })) column.isPrimary = true;\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent(); // mark columns as primary in original table\n\n\n            table.columns.forEach(function (column) {\n              if (columnNames.find(function (columnName) {\n                return columnName === column.name;\n              })) column.isPrimary = true;\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Updates composite primary keys.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.updatePrimaryKeys = function (tableOrName, columns) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.resolve()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops a primary key.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropPrimaryKey = function (tableOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            changedTable.primaryColumns.forEach(function (column) {\n              column.isPrimary = false;\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent(); // mark primary columns as non-primary in original table\n\n\n            table.primaryColumns.forEach(function (column) {\n              column.isPrimary = false;\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new unique constraint.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createUniqueConstraint = function (tableOrName, uniqueConstraint) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createUniqueConstraints(tableOrName, [uniqueConstraint])];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new unique constraints.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createUniqueConstraints = function (tableOrName, uniqueConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            uniqueConstraints.forEach(function (uniqueConstraint) {\n              return changedTable.addUniqueConstraint(uniqueConstraint);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops an unique constraint.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropUniqueConstraint = function (tableOrName, uniqueOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, uniqueConstraint;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            uniqueConstraint = uniqueOrName instanceof TableUnique ? uniqueOrName : table.uniques.find(function (u) {\n              return u.name === uniqueOrName;\n            });\n            if (!uniqueConstraint) throw new Error(\"Supplied unique constraint was not found in table \" + table.name);\n            return [4\n            /*yield*/\n            , this.dropUniqueConstraints(table, [uniqueConstraint])];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates an unique constraints.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropUniqueConstraints = function (tableOrName, uniqueConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            uniqueConstraints.forEach(function (uniqueConstraint) {\n              return changedTable.removeUniqueConstraint(uniqueConstraint);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates new check constraint.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createCheckConstraint = function (tableOrName, checkConstraint) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createCheckConstraints(tableOrName, [checkConstraint])];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates new check constraints.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createCheckConstraints = function (tableOrName, checkConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            checkConstraints.forEach(function (checkConstraint) {\n              return changedTable.addCheckConstraint(checkConstraint);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops check constraint.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropCheckConstraint = function (tableOrName, checkOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, checkConstraint;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            checkConstraint = checkOrName instanceof TableCheck ? checkOrName : table.checks.find(function (c) {\n              return c.name === checkOrName;\n            });\n            if (!checkConstraint) throw new Error(\"Supplied check constraint was not found in table \" + table.name);\n            return [4\n            /*yield*/\n            , this.dropCheckConstraints(table, [checkConstraint])];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops check constraints.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropCheckConstraints = function (tableOrName, checkConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            checkConstraints.forEach(function (checkConstraint) {\n              return changedTable.removeCheckConstraint(checkConstraint);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new exclusion constraint.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createExclusionConstraint = function (tableOrName, exclusionConstraint) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error(\"Sqlite does not support exclusion constraints.\");\n      });\n    });\n  };\n  /**\n   * Creates a new exclusion constraints.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createExclusionConstraints = function (tableOrName, exclusionConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error(\"Sqlite does not support exclusion constraints.\");\n      });\n    });\n  };\n  /**\n   * Drops exclusion constraint.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropExclusionConstraint = function (tableOrName, exclusionOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error(\"Sqlite does not support exclusion constraints.\");\n      });\n    });\n  };\n  /**\n   * Drops exclusion constraints.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropExclusionConstraints = function (tableOrName, exclusionConstraints) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error(\"Sqlite does not support exclusion constraints.\");\n      });\n    });\n  };\n  /**\n   * Creates a new foreign key.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createForeignKey = function (tableOrName, foreignKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createForeignKeys(tableOrName, [foreignKey])];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new foreign keys.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            foreignKeys.forEach(function (foreignKey) {\n              return changedTable.addForeignKey(foreignKey);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops a foreign key from the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropForeignKey = function (tableOrName, foreignKeyOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, foreignKey;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find(function (fk) {\n              return fk.name === foreignKeyOrName;\n            });\n            if (!foreignKey) throw new Error(\"Supplied foreign key was not found in table \" + table.name);\n            return [4\n            /*yield*/\n            , this.dropForeignKeys(tableOrName, [foreignKey])];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops a foreign keys from the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, changedTable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            changedTable = table.clone();\n            foreignKeys.forEach(function (foreignKey) {\n              return changedTable.removeForeignKey(foreignKey);\n            });\n            return [4\n            /*yield*/\n            , this.recreateTable(changedTable, table)];\n\n          case 4:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new index.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createIndex = function (tableOrName, index) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, up, down;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a; // new index may be passed without name. In this case we generate index name manually.\n\n            if (!index.name) index.name = this.connection.namingStrategy.indexName(table.name, index.columnNames, index.where);\n            up = this.createIndexSql(table, index);\n            down = this.dropIndexSql(index);\n            return [4\n            /*yield*/\n            , this.executeQueries(up, down)];\n\n          case 4:\n            _b.sent();\n\n            table.addIndex(index);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new indices\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createIndices = function (tableOrName, indices) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promises;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            promises = indices.map(function (index) {\n              return _this.createIndex(tableOrName, index);\n            });\n            return [4\n            /*yield*/\n            , Promise.all(promises)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops an index from the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropIndex = function (tableOrName, indexOrName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var table, _a, index, up, down;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tableOrName instanceof Table)) return [3\n            /*break*/\n            , 1];\n            _a = tableOrName;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.getCachedTable(tableOrName)];\n\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            table = _a;\n            index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find(function (i) {\n              return i.name === indexOrName;\n            });\n            if (!index) throw new Error(\"Supplied index was not found in table \" + table.name);\n            up = this.dropIndexSql(index);\n            down = this.createIndexSql(table, index);\n            return [4\n            /*yield*/\n            , this.executeQueries(up, down)];\n\n          case 4:\n            _b.sent();\n\n            table.removeIndex(index);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Drops an indices from the table.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropIndices = function (tableOrName, indices) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promises;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            promises = indices.map(function (index) {\n              return _this.dropIndex(tableOrName, index);\n            });\n            return [4\n            /*yield*/\n            , Promise.all(promises)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.clearTable = function (tableName) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.query(\"DELETE FROM \\\"\" + tableName + \"\\\"\")];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Removes all tables from the currently connected database.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.clearDatabase = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var selectViewDropsQuery, dropViewQueries, selectTableDropsQuery, dropTableQueries, error_1, rollbackError_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.query(\"PRAGMA foreign_keys = OFF;\")];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.startTransaction()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 9, 14, 16]);\n\n            selectViewDropsQuery = \"SELECT 'DROP VIEW \\\"' || name || '\\\";' as query FROM \\\"sqlite_master\\\" WHERE \\\"type\\\" = 'view'\";\n            return [4\n            /*yield*/\n            , this.query(selectViewDropsQuery)];\n\n          case 4:\n            dropViewQueries = _a.sent();\n            return [4\n            /*yield*/\n            , Promise.all(dropViewQueries.map(function (q) {\n              return _this.query(q[\"query\"]);\n            }))];\n\n          case 5:\n            _a.sent();\n\n            selectTableDropsQuery = \"SELECT 'DROP TABLE \\\"' || name || '\\\";' as query FROM \\\"sqlite_master\\\" WHERE \\\"type\\\" = 'table' AND \\\"name\\\" != 'sqlite_sequence'\";\n            return [4\n            /*yield*/\n            , this.query(selectTableDropsQuery)];\n\n          case 6:\n            dropTableQueries = _a.sent();\n            return [4\n            /*yield*/\n            , Promise.all(dropTableQueries.map(function (q) {\n              return _this.query(q[\"query\"]);\n            }))];\n\n          case 7:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.commitTransaction()];\n\n          case 8:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 16];\n\n          case 9:\n            error_1 = _a.sent();\n            _a.label = 10;\n\n          case 10:\n            _a.trys.push([10, 12,, 13]);\n\n            return [4\n            /*yield*/\n            , this.rollbackTransaction()];\n\n          case 11:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            rollbackError_1 = _a.sent();\n            return [3\n            /*break*/\n            , 13];\n\n          case 13:\n            throw error_1;\n\n          case 14:\n            return [4\n            /*yield*/\n            , this.query(\"PRAGMA foreign_keys = ON;\")];\n\n          case 15:\n            _a.sent();\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  AbstractSqliteQueryRunner.prototype.loadViews = function (viewNames) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hasTable, viewNamesString, query, dbViews;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.hasTable(this.getTypeormMetadataTableName())];\n\n          case 1:\n            hasTable = _a.sent();\n            if (!hasTable) return [2\n            /*return*/\n            , Promise.resolve([])];\n            viewNamesString = viewNames.map(function (name) {\n              return \"'\" + name + \"'\";\n            }).join(\", \");\n            query = \"SELECT \\\"t\\\".* FROM \\\"\" + this.getTypeormMetadataTableName() + \"\\\" \\\"t\\\" INNER JOIN \\\"sqlite_master\\\" s ON \\\"s\\\".\\\"name\\\" = \\\"t\\\".\\\"name\\\" AND \\\"s\\\".\\\"type\\\" = 'view' WHERE \\\"t\\\".\\\"type\\\" = 'VIEW'\";\n            if (viewNamesString.length > 0) query += \" AND \\\"t\\\".\\\"name\\\" IN (\" + viewNamesString + \")\";\n            return [4\n            /*yield*/\n            , this.query(query)];\n\n          case 2:\n            dbViews = _a.sent();\n            return [2\n            /*return*/\n            , dbViews.map(function (dbView) {\n              var view = new View();\n              view.name = dbView[\"name\"];\n              view.expression = dbView[\"value\"];\n              return view;\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.loadTables = function (tableNames) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tableNamesString, dbTables, dbIndicesDef;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // if no tables given then no need to proceed\n            if (!tableNames || !tableNames.length) return [2\n            /*return*/\n            , []];\n            tableNamesString = tableNames.map(function (tableName) {\n              return \"'\" + tableName + \"'\";\n            }).join(\", \");\n            return [4\n            /*yield*/\n            , this.query(\"SELECT * FROM \\\"sqlite_master\\\" WHERE \\\"type\\\" = 'table' AND \\\"name\\\" IN (\" + tableNamesString + \")\")];\n\n          case 1:\n            dbTables = _a.sent();\n            return [4\n            /*yield*/\n            , this.query(\"SELECT * FROM \\\"sqlite_master\\\" WHERE \\\"type\\\" = 'index' AND \\\"tbl_name\\\" IN (\" + tableNamesString + \")\")];\n\n          case 2:\n            dbIndicesDef = _a.sent(); // if tables were not found in the db, no need to proceed\n\n            if (!dbTables || !dbTables.length) return [2\n            /*return*/\n            , []]; // create table schemas for loaded tables\n\n            return [2\n            /*return*/\n            , Promise.all(dbTables.map(function (dbTable) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var table, sql, _a, dbColumns, dbIndices, dbForeignKeys, autoIncrementColumnName, tableSql, autoIncrementIndex, comma, bracket, tableForeignKeyConstraints, uniqueRegexResult, uniqueMappings, uniqueRegex, tableUniquePromises, _b, result, regexp, indicesPromises, indices;\n\n                var _this = this;\n\n                return __generator(this, function (_c) {\n                  switch (_c.label) {\n                    case 0:\n                      table = new Table({\n                        name: dbTable[\"name\"]\n                      });\n                      sql = dbTable[\"sql\"];\n                      return [4\n                      /*yield*/\n                      , Promise.all([this.query(\"PRAGMA table_info(\\\"\" + dbTable[\"name\"] + \"\\\")\"), this.query(\"PRAGMA index_list(\\\"\" + dbTable[\"name\"] + \"\\\")\"), this.query(\"PRAGMA foreign_key_list(\\\"\" + dbTable[\"name\"] + \"\\\")\")])];\n\n                    case 1:\n                      _a = __read.apply(void 0, [_c.sent(), 3]), dbColumns = _a[0], dbIndices = _a[1], dbForeignKeys = _a[2];\n                      autoIncrementColumnName = undefined;\n                      tableSql = dbTable[\"sql\"];\n                      autoIncrementIndex = tableSql.toUpperCase().indexOf(\"AUTOINCREMENT\");\n\n                      if (autoIncrementIndex !== -1) {\n                        autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);\n                        comma = autoIncrementColumnName.lastIndexOf(\",\");\n                        bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n\n                        if (comma !== -1) {\n                          autoIncrementColumnName = autoIncrementColumnName.substr(comma);\n                          autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\n                          autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\n                        } else if (bracket !== -1) {\n                          autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\n                          autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\n                          autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\n                        }\n                      } // create columns from the loaded columns\n\n\n                      table.columns = dbColumns.map(function (dbColumn) {\n                        var tableColumn = new TableColumn();\n                        tableColumn.name = dbColumn[\"name\"];\n                        tableColumn.type = dbColumn[\"type\"].toLowerCase();\n                        tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\n                        tableColumn.isNullable = dbColumn[\"notnull\"] === 0; // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n\n                        tableColumn.isPrimary = dbColumn[\"pk\"] > 0;\n                        tableColumn.comment = \"\"; // SQLite does not support column comments\n\n                        tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\n\n                        if (tableColumn.isGenerated) {\n                          tableColumn.generationStrategy = \"increment\";\n                        }\n\n                        if (tableColumn.type === \"varchar\") {\n                          // Check if this is an enum\n                          var enumMatch = sql.match(new RegExp(\"\\\"(\" + tableColumn.name + \")\\\" varchar CHECK\\\\s*\\\\(\\\\s*\\\\1\\\\s+IN\\\\s*\\\\(('[^']+'(?:\\\\s*,\\\\s*'[^']+')+)\\\\s*\\\\)\\\\s*\\\\)\"));\n\n                          if (enumMatch) {\n                            // This is an enum\n                            tableColumn.enum = enumMatch[2].substr(1, enumMatch[2].length - 2).split(\"','\");\n                          }\n                        } // parse datatype and attempt to retrieve length, precision and scale\n\n\n                        var pos = tableColumn.type.indexOf(\"(\");\n\n                        if (pos !== -1) {\n                          var fullType = tableColumn.type;\n                          var dataType_1 = fullType.substr(0, pos);\n\n                          if (!!_this.driver.withLengthColumnTypes.find(function (col) {\n                            return col === dataType_1;\n                          })) {\n                            var len = parseInt(fullType.substring(pos + 1, fullType.length - 1));\n\n                            if (len) {\n                              tableColumn.length = len.toString();\n                              tableColumn.type = dataType_1; // remove the length part from the datatype\n                            }\n                          }\n\n                          if (!!_this.driver.withPrecisionColumnTypes.find(function (col) {\n                            return col === dataType_1;\n                          })) {\n                            var re = new RegExp(\"^\" + dataType_1 + \"\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)\");\n                            var matches = fullType.match(re);\n\n                            if (matches && matches[1]) {\n                              tableColumn.precision = +matches[1];\n                            }\n\n                            if (!!_this.driver.withScaleColumnTypes.find(function (col) {\n                              return col === dataType_1;\n                            })) {\n                              if (matches && matches[2]) {\n                                tableColumn.scale = +matches[2];\n                              }\n                            }\n\n                            tableColumn.type = dataType_1; // remove the precision/scale part from the datatype\n                          }\n                        }\n\n                        return tableColumn;\n                      });\n                      tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, function (dbForeignKey) {\n                        return dbForeignKey[\"id\"];\n                      });\n                      table.foreignKeys = tableForeignKeyConstraints.map(function (foreignKey) {\n                        var ownForeignKeys = dbForeignKeys.filter(function (dbForeignKey) {\n                          return dbForeignKey[\"id\"] === foreignKey[\"id\"] && dbForeignKey[\"table\"] === foreignKey[\"table\"];\n                        });\n                        var columnNames = ownForeignKeys.map(function (dbForeignKey) {\n                          return dbForeignKey[\"from\"];\n                        });\n                        var referencedColumnNames = ownForeignKeys.map(function (dbForeignKey) {\n                          return dbForeignKey[\"to\"];\n                        }); // build foreign key name, because we can not get it directly.\n\n                        var fkName = _this.connection.namingStrategy.foreignKeyName(table, columnNames, foreignKey.referencedTableName, foreignKey.referencedColumnNames);\n\n                        return new TableForeignKey({\n                          name: fkName,\n                          columnNames: columnNames,\n                          referencedTableName: foreignKey[\"table\"],\n                          referencedColumnNames: referencedColumnNames,\n                          onDelete: foreignKey[\"on_delete\"],\n                          onUpdate: foreignKey[\"on_update\"]\n                        });\n                      });\n                      uniqueMappings = [];\n                      uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE \\((.*?)\\)/g;\n\n                      while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n                        uniqueMappings.push({\n                          name: uniqueRegexResult[1],\n                          columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(\"\\\", \\\"\")\n                        });\n                      }\n\n                      tableUniquePromises = dbIndices.filter(function (dbIndex) {\n                        return dbIndex[\"origin\"] === \"u\";\n                      }).map(function (dbIndex) {\n                        return dbIndex[\"name\"];\n                      }).filter(function (value, index, self) {\n                        return self.indexOf(value) === index;\n                      }).map(function (dbIndexName) {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var dbIndex, indexInfos, indexColumns, column, foundMapping;\n                          return __generator(this, function (_a) {\n                            switch (_a.label) {\n                              case 0:\n                                dbIndex = dbIndices.find(function (dbIndex) {\n                                  return dbIndex[\"name\"] === dbIndexName;\n                                });\n                                return [4\n                                /*yield*/\n                                , this.query(\"PRAGMA index_info(\\\"\" + dbIndex[\"name\"] + \"\\\")\")];\n\n                              case 1:\n                                indexInfos = _a.sent();\n                                indexColumns = indexInfos.sort(function (indexInfo1, indexInfo2) {\n                                  return parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"]);\n                                }).map(function (indexInfo) {\n                                  return indexInfo[\"name\"];\n                                });\n\n                                if (indexColumns.length === 1) {\n                                  column = table.columns.find(function (column) {\n                                    return !!indexColumns.find(function (indexColumn) {\n                                      return indexColumn === column.name;\n                                    });\n                                  });\n                                  if (column) column.isUnique = true;\n                                }\n\n                                foundMapping = uniqueMappings.find(function (mapping) {\n                                  return mapping.columns.every(function (column) {\n                                    return indexColumns.indexOf(column) !== -1;\n                                  });\n                                });\n                                return [2\n                                /*return*/\n                                , new TableUnique({\n                                  name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),\n                                  columnNames: indexColumns\n                                })];\n                            }\n                          });\n                        });\n                      });\n                      _b = table;\n                      return [4\n                      /*yield*/\n                      , Promise.all(tableUniquePromises)];\n\n                    case 2:\n                      _b.uniques = _c.sent();\n                      regexp = /CONSTRAINT \"([^\"]*)\" CHECK (\\(.*?\\))([,]|[)]$)/g;\n\n                      while ((result = regexp.exec(sql)) !== null) {\n                        table.checks.push(new TableCheck({\n                          name: result[1],\n                          expression: result[2]\n                        }));\n                      }\n\n                      indicesPromises = dbIndices.filter(function (dbIndex) {\n                        return dbIndex[\"origin\"] === \"c\";\n                      }).map(function (dbIndex) {\n                        return dbIndex[\"name\"];\n                      }).filter(function (value, index, self) {\n                        return self.indexOf(value) === index;\n                      }) // unqiue\n                      .map(function (dbIndexName) {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var indexDef, condition, dbIndex, indexInfos, indexColumns, isUnique;\n                          return __generator(this, function (_a) {\n                            switch (_a.label) {\n                              case 0:\n                                indexDef = dbIndicesDef.find(function (dbIndexDef) {\n                                  return dbIndexDef[\"name\"] === dbIndexName;\n                                });\n                                condition = /WHERE (.*)/.exec(indexDef[\"sql\"]);\n                                dbIndex = dbIndices.find(function (dbIndex) {\n                                  return dbIndex[\"name\"] === dbIndexName;\n                                });\n                                return [4\n                                /*yield*/\n                                , this.query(\"PRAGMA index_info(\\\"\" + dbIndex[\"name\"] + \"\\\")\")];\n\n                              case 1:\n                                indexInfos = _a.sent();\n                                indexColumns = indexInfos.sort(function (indexInfo1, indexInfo2) {\n                                  return parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"]);\n                                }).map(function (indexInfo) {\n                                  return indexInfo[\"name\"];\n                                });\n                                isUnique = dbIndex[\"unique\"] === \"1\" || dbIndex[\"unique\"] === 1;\n                                return [2\n                                /*return*/\n                                , new TableIndex({\n                                  table: table,\n                                  name: dbIndex[\"name\"],\n                                  columnNames: indexColumns,\n                                  isUnique: isUnique,\n                                  where: condition ? condition[1] : undefined\n                                })];\n                            }\n                          });\n                        });\n                      });\n                      return [4\n                      /*yield*/\n                      , Promise.all(indicesPromises)];\n\n                    case 3:\n                      indices = _c.sent();\n                      table.indices = indices.filter(function (index) {\n                        return !!index;\n                      });\n                      return [2\n                      /*return*/\n                      , table];\n                  }\n                });\n              });\n            }))];\n        }\n      });\n    });\n  };\n  /**\n   * Builds create table sql.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createTableSql = function (table, createForeignKeys) {\n    var _this = this;\n\n    var primaryColumns = table.columns.filter(function (column) {\n      return column.isPrimary;\n    });\n    var hasAutoIncrement = primaryColumns.find(function (column) {\n      return column.isGenerated && column.generationStrategy === \"increment\";\n    });\n    var skipPrimary = primaryColumns.length > 1;\n    if (skipPrimary && hasAutoIncrement) throw new Error(\"Sqlite does not support AUTOINCREMENT on composite primary key\");\n    var columnDefinitions = table.columns.map(function (column) {\n      return _this.buildCreateColumnSql(column, skipPrimary);\n    }).join(\", \");\n    var sql = \"CREATE TABLE \\\"\" + table.name + \"\\\" (\" + columnDefinitions; // need for `addColumn()` method, because it recreates table.\n\n    table.columns.filter(function (column) {\n      return column.isUnique;\n    }).forEach(function (column) {\n      var isUniqueExist = table.uniques.some(function (unique) {\n        return unique.columnNames.length === 1 && unique.columnNames[0] === column.name;\n      });\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: _this.connection.namingStrategy.uniqueConstraintName(table.name, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n\n    if (table.uniques.length > 0) {\n      var uniquesSql = table.uniques.map(function (unique) {\n        var uniqueName = unique.name ? unique.name : _this.connection.namingStrategy.uniqueConstraintName(table.name, unique.columnNames);\n        var columnNames = unique.columnNames.map(function (columnName) {\n          return \"\\\"\" + columnName + \"\\\"\";\n        }).join(\", \");\n        return \"CONSTRAINT \\\"\" + uniqueName + \"\\\" UNIQUE (\" + columnNames + \")\";\n      }).join(\", \");\n      sql += \", \" + uniquesSql;\n    }\n\n    if (table.checks.length > 0) {\n      var checksSql = table.checks.map(function (check) {\n        var checkName = check.name ? check.name : _this.connection.namingStrategy.checkConstraintName(table.name, check.expression);\n        return \"CONSTRAINT \\\"\" + checkName + \"\\\" CHECK (\" + check.expression + \")\";\n      }).join(\", \");\n      sql += \", \" + checksSql;\n    }\n\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      var foreignKeysSql = table.foreignKeys.map(function (fk) {\n        var columnNames = fk.columnNames.map(function (columnName) {\n          return \"\\\"\" + columnName + \"\\\"\";\n        }).join(\", \");\n        if (!fk.name) fk.name = _this.connection.namingStrategy.foreignKeyName(table.name, fk.columnNames, fk.referencedTableName, fk.referencedColumnNames);\n        var referencedColumnNames = fk.referencedColumnNames.map(function (columnName) {\n          return \"\\\"\" + columnName + \"\\\"\";\n        }).join(\", \");\n        var constraint = \"CONSTRAINT \\\"\" + fk.name + \"\\\" FOREIGN KEY (\" + columnNames + \") REFERENCES \\\"\" + fk.referencedTableName + \"\\\" (\" + referencedColumnNames + \")\";\n        if (fk.onDelete) constraint += \" ON DELETE \" + fk.onDelete;\n        if (fk.onUpdate) constraint += \" ON UPDATE \" + fk.onUpdate;\n        return constraint;\n      }).join(\", \");\n      sql += \", \" + foreignKeysSql;\n    }\n\n    if (primaryColumns.length > 1) {\n      var columnNames = primaryColumns.map(function (column) {\n        return \"\\\"\" + column.name + \"\\\"\";\n      }).join(\", \");\n      sql += \", PRIMARY KEY (\" + columnNames + \")\";\n    }\n\n    sql += \")\";\n    var tableMetadata = this.connection.entityMetadatas.find(function (metadata) {\n      return metadata.tableName === table.name;\n    });\n\n    if (tableMetadata && tableMetadata.withoutRowid) {\n      sql += \" WITHOUT ROWID\";\n    }\n\n    return new Query(sql);\n  };\n  /**\n   * Builds drop table sql.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropTableSql = function (tableOrName, ifExist) {\n    var tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n    var query = ifExist ? \"DROP TABLE IF EXISTS \\\"\" + tableName + \"\\\"\" : \"DROP TABLE \\\"\" + tableName + \"\\\"\";\n    return new Query(query);\n  };\n\n  AbstractSqliteQueryRunner.prototype.createViewSql = function (view) {\n    if (typeof view.expression === \"string\") {\n      return new Query(\"CREATE VIEW \\\"\" + view.name + \"\\\" AS \" + view.expression);\n    } else {\n      return new Query(\"CREATE VIEW \\\"\" + view.name + \"\\\" AS \" + view.expression(this.connection).getQuery());\n    }\n  };\n\n  AbstractSqliteQueryRunner.prototype.insertViewDefinitionSql = function (view) {\n    var expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n\n    var _a = __read(this.connection.createQueryBuilder().insert().into(this.getTypeormMetadataTableName()).values({\n      type: \"VIEW\",\n      name: view.name,\n      value: expression\n    }).getQueryAndParameters(), 2),\n        query = _a[0],\n        parameters = _a[1];\n\n    return new Query(query, parameters);\n  };\n  /**\n   * Builds drop view sql.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropViewSql = function (viewOrPath) {\n    var viewName = viewOrPath instanceof View ? viewOrPath.name : viewOrPath;\n    return new Query(\"DROP VIEW \\\"\" + viewName + \"\\\"\");\n  };\n  /**\n   * Builds remove view sql.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.deleteViewDefinitionSql = function (viewOrPath) {\n    var viewName = viewOrPath instanceof View ? viewOrPath.name : viewOrPath;\n    var qb = this.connection.createQueryBuilder();\n\n    var _a = __read(qb.delete().from(this.getTypeormMetadataTableName()).where(qb.escape(\"type\") + \" = 'VIEW'\").andWhere(qb.escape(\"name\") + \" = :name\", {\n      name: viewName\n    }).getQueryAndParameters(), 2),\n        query = _a[0],\n        parameters = _a[1];\n\n    return new Query(query, parameters);\n  };\n  /**\n   * Builds create index sql.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.createIndexSql = function (table, index) {\n    var columns = index.columnNames.map(function (columnName) {\n      return \"\\\"\" + columnName + \"\\\"\";\n    }).join(\", \");\n    return new Query(\"CREATE \" + (index.isUnique ? \"UNIQUE \" : \"\") + \"INDEX \\\"\" + index.name + \"\\\" ON \\\"\" + table.name + \"\\\" (\" + columns + \") \" + (index.where ? \"WHERE \" + index.where : \"\"));\n  };\n  /**\n   * Builds drop index sql.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.dropIndexSql = function (indexOrName) {\n    var indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n    return new Query(\"DROP INDEX \\\"\" + indexName + \"\\\"\");\n  };\n  /**\n   * Builds a query for create column.\n   */\n\n\n  AbstractSqliteQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {\n    var c = \"\\\"\" + column.name + \"\\\"\";\n\n    if (column instanceof ColumnMetadata) {\n      c += \" \" + this.driver.normalizeType(column);\n    } else {\n      c += \" \" + this.connection.driver.createFullType(column);\n    }\n\n    if (column.enum) c += \" CHECK( \" + column.name + \" IN (\" + column.enum.map(function (val) {\n      return \"'\" + val + \"'\";\n    }).join(\",\") + \") )\";\n    if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n    if (column.isGenerated === true && column.generationStrategy === \"increment\") // don't use skipPrimary here since updates can update already exist primary without auto inc.\n      c += \" AUTOINCREMENT\";\n    if (column.collation) c += \" COLLATE \" + column.collation;\n    if (column.isNullable !== true) c += \" NOT NULL\";\n    if (column.default !== undefined && column.default !== null) c += \" DEFAULT (\" + column.default + \")\";\n    return c;\n  };\n\n  AbstractSqliteQueryRunner.prototype.recreateTable = function (newTable, oldTable, migrateData) {\n    if (migrateData === void 0) {\n      migrateData = true;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var upQueries, downQueries, newColumnNames, oldColumnNames;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            upQueries = [];\n            downQueries = []; // drop old table indices\n\n            oldTable.indices.forEach(function (index) {\n              upQueries.push(_this.dropIndexSql(index));\n              downQueries.push(_this.createIndexSql(oldTable, index));\n            }); // change table name into 'temporary_table'\n\n            newTable.name = \"temporary_\" + newTable.name; // create new table\n\n            upQueries.push(this.createTableSql(newTable, true));\n            downQueries.push(this.dropTableSql(newTable)); // migrate all data from the old table into new table\n\n            if (migrateData) {\n              newColumnNames = newTable.columns.map(function (column) {\n                return \"\\\"\" + column.name + \"\\\"\";\n              }).join(\", \");\n              oldColumnNames = oldTable.columns.map(function (column) {\n                return \"\\\"\" + column.name + \"\\\"\";\n              }).join(\", \");\n\n              if (oldTable.columns.length < newTable.columns.length) {\n                newColumnNames = newTable.columns.filter(function (column) {\n                  return oldTable.columns.find(function (c) {\n                    return c.name === column.name;\n                  });\n                }).map(function (column) {\n                  return \"\\\"\" + column.name + \"\\\"\";\n                }).join(\", \");\n              } else if (oldTable.columns.length > newTable.columns.length) {\n                oldColumnNames = oldTable.columns.filter(function (column) {\n                  return newTable.columns.find(function (c) {\n                    return c.name === column.name;\n                  });\n                }).map(function (column) {\n                  return \"\\\"\" + column.name + \"\\\"\";\n                }).join(\", \");\n              }\n\n              upQueries.push(new Query(\"INSERT INTO \\\"\" + newTable.name + \"\\\"(\" + newColumnNames + \") SELECT \" + oldColumnNames + \" FROM \\\"\" + oldTable.name + \"\\\"\"));\n              downQueries.push(new Query(\"INSERT INTO \\\"\" + oldTable.name + \"\\\"(\" + oldColumnNames + \") SELECT \" + newColumnNames + \" FROM \\\"\" + newTable.name + \"\\\"\"));\n            } // drop old table\n\n\n            upQueries.push(this.dropTableSql(oldTable));\n            downQueries.push(this.createTableSql(oldTable, true)); // rename old table\n\n            upQueries.push(new Query(\"ALTER TABLE \\\"\" + newTable.name + \"\\\" RENAME TO \\\"\" + oldTable.name + \"\\\"\"));\n            downQueries.push(new Query(\"ALTER TABLE \\\"\" + oldTable.name + \"\\\" RENAME TO \\\"\" + newTable.name + \"\\\"\"));\n            newTable.name = oldTable.name; // recreate table indices\n\n            newTable.indices.forEach(function (index) {\n              // new index may be passed without name. In this case we generate index name manually.\n              if (!index.name) index.name = _this.connection.namingStrategy.indexName(newTable.name, index.columnNames, index.where);\n              upQueries.push(_this.createIndexSql(newTable, index));\n              downQueries.push(_this.dropIndexSql(index));\n            });\n            return [4\n            /*yield*/\n            , this.executeQueries(upQueries, downQueries)];\n\n          case 1:\n            _a.sent();\n\n            this.replaceCachedTable(oldTable, newTable);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return AbstractSqliteQueryRunner;\n}(BaseQueryRunner);\n\nexport { AbstractSqliteQueryRunner };","map":{"version":3,"sources":["../browser/src/driver/sqlite-abstract/AbstractSqliteQueryRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\nimport {TableColumn} from \"../../schema-builder/table/TableColumn\";\nimport {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\nimport {Table} from \"../../schema-builder/table/Table\";\nimport {TableIndex} from \"../../schema-builder/table/TableIndex\";\nimport {TableForeignKey} from \"../../schema-builder/table/TableForeignKey\";\nimport {View} from \"../../schema-builder/view/View\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\nimport {Query} from \"../Query\";\nimport {AbstractSqliteDriver} from \"./AbstractSqliteDriver\";\nimport {ReadStream} from \"../../platform/PlatformTools\";\nimport {TableIndexOptions} from \"../../schema-builder/options/TableIndexOptions\";\nimport {TableUnique} from \"../../schema-builder/table/TableUnique\";\nimport {BaseQueryRunner} from \"../../query-runner/BaseQueryRunner\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {TableCheck} from \"../../schema-builder/table/TableCheck\";\nimport {IsolationLevel} from \"../types/IsolationLevel\";\nimport {TableExclusion} from \"../../schema-builder/table/TableExclusion\";\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport abstract class AbstractSqliteQueryRunner extends BaseQueryRunner implements QueryRunner {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: AbstractSqliteDriver;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor() {\n        super();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        return Promise.resolve(this.driver.databaseConnection);\n    }\n\n    /**\n     * Releases used database connection.\n     * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n     */\n    release(): Promise<void> {\n        this.loadedTables = [];\n        this.clearSqlMemory();\n        return Promise.resolve();\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        if (this.isTransactionActive)\n            throw new TransactionAlreadyStartedError();\n\n        if (isolationLevel) {\n            if (isolationLevel !== \"READ UNCOMMITTED\" && isolationLevel !== \"SERIALIZABLE\") {\n                throw new Error(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);\n            }\n\n            if (isolationLevel === \"READ UNCOMMITTED\") {\n                await this.query(\"PRAGMA read_uncommitted = true\");\n            } else {\n                await this.query(\"PRAGMA read_uncommitted = false\");\n            }\n        }\n\n        const beforeBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastBeforeTransactionStartEvent(beforeBroadcastResult);\n        if (beforeBroadcastResult.promises.length > 0) await Promise.all(beforeBroadcastResult.promises);\n\n        this.isTransactionActive = true;\n\n        await this.query(\"BEGIN TRANSACTION\");\n\n        const afterBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastAfterTransactionStartEvent(afterBroadcastResult);\n        if (afterBroadcastResult.promises.length > 0) await Promise.all(afterBroadcastResult.promises);\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n\n        const beforeBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastBeforeTransactionCommitEvent(beforeBroadcastResult);\n        if (beforeBroadcastResult.promises.length > 0) await Promise.all(beforeBroadcastResult.promises);\n\n        await this.query(\"COMMIT\");\n        this.isTransactionActive = false;\n\n        const afterBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastAfterTransactionCommitEvent(afterBroadcastResult);\n        if (afterBroadcastResult.promises.length > 0) await Promise.all(afterBroadcastResult.promises);\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n\n        const beforeBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastBeforeTransactionRollbackEvent(beforeBroadcastResult);\n        if (beforeBroadcastResult.promises.length > 0) await Promise.all(beforeBroadcastResult.promises);\n\n        await this.query(\"ROLLBACK\");\n\n        this.isTransactionActive = false;\n\n        const afterBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastAfterTransactionRollbackEvent(afterBroadcastResult);\n        if (afterBroadcastResult.promises.length > 0) await Promise.all(afterBroadcastResult.promises);\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    stream(query: string, parameters?: any[], onEnd?: Function, onError?: Function): Promise<ReadStream> {\n        throw new Error(`Stream is not supported by sqlite driver.`);\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([]);\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([]);\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        return Promise.resolve(false);\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<undefined> {\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        throw new Error(`This driver does not support table schemas`);\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<undefined> {\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table|string): Promise<boolean> {\n        const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n        const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(tableOrName: Table|string, columnName: string): Promise<boolean> {\n        const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n        const sql = `PRAGMA table_info(\"${tableName}\")`;\n        const columns: ObjectLiteral[] = await this.query(sql);\n        return !!columns.find(column => column[\"name\"] === columnName);\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(database: string, ifNotExist?: boolean): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(schema: string, ifNotExist?: boolean): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(table: Table, ifNotExist: boolean = false, createForeignKeys: boolean = true, createIndices: boolean = true): Promise<void> {\n        const upQueries: Query[] = [];\n        const downQueries: Query[] = [];\n\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table);\n            if (isTableExist) return Promise.resolve();\n        }\n\n        upQueries.push(this.createTableSql(table, createForeignKeys));\n        downQueries.push(this.dropTableSql(table));\n\n        if (createIndices) {\n            table.indices.forEach(index => {\n\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(table.name, index.columnNames, index.where);\n                upQueries.push(this.createIndexSql(table, index));\n                downQueries.push(this.dropIndexSql(index));\n            });\n        }\n\n        await this.executeQueries(upQueries, downQueries);\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(tableOrName: Table|string, ifExist?: boolean, dropForeignKeys: boolean = true, dropIndices: boolean = true): Promise<void> {\n        if (ifExist) {\n            const isTableExist = await this.hasTable(tableOrName);\n            if (!isTableExist) return Promise.resolve();\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys;\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const upQueries: Query[] = [];\n        const downQueries: Query[] = [];\n\n        if (dropIndices) {\n            table.indices.forEach(index => {\n                upQueries.push(this.dropIndexSql(index));\n                downQueries.push(this.createIndexSql(table, index));\n            });\n        }\n\n        upQueries.push(this.dropTableSql(table, ifExist));\n        downQueries.push(this.createTableSql(table, createForeignKeys));\n\n        await this.executeQueries(upQueries, downQueries);\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(view: View): Promise<void> {\n        const upQueries: Query[] = [];\n        const downQueries: Query[] = [];\n        upQueries.push(this.createViewSql(view));\n        upQueries.push(this.insertViewDefinitionSql(view));\n        downQueries.push(this.dropViewSql(view));\n        downQueries.push(this.deleteViewDefinitionSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View|string): Promise<void> {\n        const viewName = target instanceof View ? target.name : target;\n        const view = await this.getCachedView(viewName);\n\n        const upQueries: Query[] = [];\n        const downQueries: Query[] = [];\n        upQueries.push(this.deleteViewDefinitionSql(view));\n        upQueries.push(this.dropViewSql(view));\n        downQueries.push(this.insertViewDefinitionSql(view));\n        downQueries.push(this.createViewSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(oldTableOrName: Table|string, newTableName: string): Promise<void> {\n        const oldTable = oldTableOrName instanceof Table ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n        const newTable = oldTable.clone();\n        newTable.name = newTableName;\n\n        // rename table\n        const up = new Query(`ALTER TABLE \"${oldTable.name}\" RENAME TO \"${newTableName}\"`);\n        const down = new Query(`ALTER TABLE \"${newTableName}\" RENAME TO \"${oldTable.name}\"`);\n        await this.executeQueries(up, down);\n\n        // rename old table;\n        oldTable.name = newTable.name;\n\n        // rename unique constraints\n        newTable.uniques.forEach(unique => {\n            unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n        });\n\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach(foreignKey => {\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, foreignKey.referencedTableName, foreignKey.referencedColumnNames);\n        });\n\n        // rename indices\n        newTable.indices.forEach(index => {\n            index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n        });\n\n        // recreate table with new constraint names\n        await this.recreateTable(newTable, oldTable);\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(tableOrName: Table|string, column: TableColumn): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        return this.addColumns(table!, [column]);\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(tableOrName: Table|string, columns: TableColumn[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const changedTable = table.clone();\n        columns.forEach(column => changedTable.addColumn(column));\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(tableOrName: Table|string, oldTableColumnOrName: TableColumn|string, newTableColumnOrName: TableColumn|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new Error(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n        let newColumn: TableColumn|undefined = undefined;\n        if (newTableColumnOrName instanceof TableColumn) {\n            newColumn = newTableColumnOrName;\n        } else {\n            newColumn = oldColumn.clone();\n            newColumn.name = newTableColumnOrName;\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn);\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(tableOrName: Table|string, oldTableColumnOrName: TableColumn|string, newColumn: TableColumn): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new Error(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n        await this.changeColumns(table, [{oldColumn, newColumn}]);\n    }\n\n    /**\n     * Changes a column in the table.\n     * Changed column looses all its keys in the db.\n     */\n    async changeColumns(tableOrName: Table|string, changedColumns: { oldColumn: TableColumn, newColumn: TableColumn }[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const changedTable = table.clone();\n        changedColumns.forEach(changedColumnSet => {\n            if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {\n                changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach(unique => {\n                    unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                    unique.columnNames.push(changedColumnSet.newColumn.name);\n                    unique.name = this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);\n                });\n\n                changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach(fk => {\n                    fk.columnNames.splice(fk.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                    fk.columnNames.push(changedColumnSet.newColumn.name);\n                    fk.name = this.connection.namingStrategy.foreignKeyName(changedTable, fk.columnNames, fk.referencedTableName, fk.referencedColumnNames);\n                });\n\n                changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach(index => {\n                    index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                    index.columnNames.push(changedColumnSet.newColumn.name);\n                    index.name = this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);\n                });\n            }\n            const originalColumn = changedTable.columns.find(column => column.name === changedColumnSet.oldColumn.name);\n            if (originalColumn)\n                changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;\n        });\n\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(tableOrName: Table|string, columnOrName: TableColumn|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);\n        if (!column)\n            throw new Error(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n\n        await this.dropColumns(table, [column]);\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(tableOrName: Table|string, columns: TableColumn[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // clone original table and remove column and its constraints from cloned table\n        const changedTable = table.clone();\n        columns.forEach(column => {\n            changedTable.removeColumn(column);\n            changedTable.findColumnUniques(column).forEach(unique => changedTable.removeUniqueConstraint(unique));\n            changedTable.findColumnIndices(column).forEach(index => changedTable.removeIndex(index));\n            changedTable.findColumnForeignKeys(column).forEach(fk => changedTable.removeForeignKey(fk));\n        });\n\n        await this.recreateTable(changedTable, table);\n\n        // remove column and its constraints from original table.\n        columns.forEach(column => {\n            table.removeColumn(column);\n            table.findColumnUniques(column).forEach(unique => table.removeUniqueConstraint(unique));\n            table.findColumnIndices(column).forEach(index => table.removeIndex(index));\n            table.findColumnForeignKeys(column).forEach(fk => table.removeForeignKey(fk));\n        });\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(tableOrName: Table|string, columnNames: string[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        // clone original table and mark columns as primary\n        const changedTable = table.clone();\n        changedTable.columns.forEach(column => {\n            if (columnNames.find(columnName => columnName === column.name))\n                column.isPrimary = true;\n        });\n\n        await this.recreateTable(changedTable, table);\n        // mark columns as primary in original table\n        table.columns.forEach(column => {\n            if (columnNames.find(columnName => columnName === column.name))\n                column.isPrimary = true;\n        });\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(tableOrName: Table|string, columns: TableColumn[]): Promise<void> {\n        await Promise.resolve();\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName: Table|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        // clone original table and mark primary columns as non-primary\n        const changedTable = table.clone();\n        changedTable.primaryColumns.forEach(column => {\n            column.isPrimary = false;\n        });\n\n        await this.recreateTable(changedTable, table);\n        // mark primary columns as non-primary in original table\n        table.primaryColumns.forEach(column => {\n            column.isPrimary = false;\n        });\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(tableOrName: Table|string, uniqueConstraint: TableUnique): Promise<void> {\n        await this.createUniqueConstraints(tableOrName, [uniqueConstraint]);\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(tableOrName: Table|string, uniqueConstraints: TableUnique[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // clone original table and add unique constraints in to cloned table\n        const changedTable = table.clone();\n        uniqueConstraints.forEach(uniqueConstraint => changedTable.addUniqueConstraint(uniqueConstraint));\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(tableOrName: Table|string, uniqueOrName: TableUnique|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const uniqueConstraint = uniqueOrName instanceof TableUnique ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n        if (!uniqueConstraint)\n            throw new Error(`Supplied unique constraint was not found in table ${table.name}`);\n\n        await this.dropUniqueConstraints(table, [uniqueConstraint]);\n    }\n\n    /**\n     * Creates an unique constraints.\n     */\n    async dropUniqueConstraints(tableOrName: Table|string, uniqueConstraints: TableUnique[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // clone original table and remove unique constraints from cloned table\n        const changedTable = table.clone();\n        uniqueConstraints.forEach(uniqueConstraint => changedTable.removeUniqueConstraint(uniqueConstraint));\n\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(tableOrName: Table|string, checkConstraint: TableCheck): Promise<void> {\n        await this.createCheckConstraints(tableOrName, [checkConstraint]);\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(tableOrName: Table|string, checkConstraints: TableCheck[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // clone original table and add check constraints in to cloned table\n        const changedTable = table.clone();\n        checkConstraints.forEach(checkConstraint => changedTable.addCheckConstraint(checkConstraint));\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(tableOrName: Table|string, checkOrName: TableCheck|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const checkConstraint = checkOrName instanceof TableCheck ? checkOrName : table.checks.find(c => c.name === checkOrName);\n        if (!checkConstraint)\n            throw new Error(`Supplied check constraint was not found in table ${table.name}`);\n\n        await this.dropCheckConstraints(table, [checkConstraint]);\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(tableOrName: Table|string, checkConstraints: TableCheck[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // clone original table and remove check constraints from cloned table\n        const changedTable = table.clone();\n        checkConstraints.forEach(checkConstraint => changedTable.removeCheckConstraint(checkConstraint));\n\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(tableOrName: Table|string, exclusionConstraint: TableExclusion): Promise<void> {\n        throw new Error(`Sqlite does not support exclusion constraints.`);\n    }\n\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(tableOrName: Table|string, exclusionConstraints: TableExclusion[]): Promise<void> {\n        throw new Error(`Sqlite does not support exclusion constraints.`);\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(tableOrName: Table|string, exclusionOrName: TableExclusion|string): Promise<void> {\n        throw new Error(`Sqlite does not support exclusion constraints.`);\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(tableOrName: Table|string, exclusionConstraints: TableExclusion[]): Promise<void> {\n        throw new Error(`Sqlite does not support exclusion constraints.`);\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(tableOrName: Table|string, foreignKey: TableForeignKey): Promise<void> {\n        await this.createForeignKeys(tableOrName, [foreignKey]);\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(tableOrName: Table|string, foreignKeys: TableForeignKey[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        // clone original table and add foreign keys in to cloned table\n        const changedTable = table.clone();\n        foreignKeys.forEach(foreignKey => changedTable.addForeignKey(foreignKey));\n\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(tableOrName: Table|string, foreignKeyOrName: TableForeignKey|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n        if (!foreignKey)\n            throw new Error(`Supplied foreign key was not found in table ${table.name}`);\n\n        await this.dropForeignKeys(tableOrName, [foreignKey]);\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(tableOrName: Table|string, foreignKeys: TableForeignKey[]): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // clone original table and remove foreign keys from cloned table\n        const changedTable = table.clone();\n        foreignKeys.forEach(foreignKey => changedTable.removeForeignKey(foreignKey));\n\n        await this.recreateTable(changedTable, table);\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(tableOrName: Table|string, index: TableIndex): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.connection.namingStrategy.indexName(table.name, index.columnNames, index.where);\n\n        const up = this.createIndexSql(table, index);\n        const down = this.dropIndexSql(index);\n        await this.executeQueries(up, down);\n        table.addIndex(index);\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(tableOrName: Table|string, indices: TableIndex[]): Promise<void> {\n        const promises = indices.map(index => this.createIndex(tableOrName, index));\n        await Promise.all(promises);\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(tableOrName: Table|string, indexOrName: TableIndex|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find(i => i.name === indexOrName);\n        if (!index)\n            throw new Error(`Supplied index was not found in table ${table.name}`);\n\n        const up = this.dropIndexSql(index);\n        const down = this.createIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.removeIndex(index);\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(tableOrName: Table|string, indices: TableIndex[]): Promise<void> {\n        const promises = indices.map(index => this.dropIndex(tableOrName, index));\n        await Promise.all(promises);\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`DELETE FROM \"${tableName}\"`);\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF;`);\n        await this.startTransaction();\n        try {\n            const selectViewDropsQuery = `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n            const dropViewQueries: ObjectLiteral[] = await this.query(selectViewDropsQuery);\n            await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n\n            const selectTableDropsQuery = `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n            const dropTableQueries: ObjectLiteral[] = await this.query(selectTableDropsQuery);\n            await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"])));\n            await this.commitTransaction();\n\n        } catch (error) {\n            try { // we throw original error even if rollback thrown an error\n                await this.rollbackTransaction();\n            } catch (rollbackError) { }\n            throw error;\n\n        } finally {\n            await this.query(`PRAGMA foreign_keys = ON;`);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n        if (!hasTable)\n            return Promise.resolve([]);\n\n        const viewNamesString = viewNames.map(name => \"'\" + name + \"'\").join(\", \");\n        let query = `SELECT \"t\".* FROM \"${this.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = 'VIEW'`;\n        if (viewNamesString.length > 0)\n            query += ` AND \"t\".\"name\" IN (${viewNamesString})`;\n        const dbViews = await this.query(query);\n        return dbViews.map((dbView: any) => {\n            const view = new View();\n            view.name = dbView[\"name\"];\n            view.expression = dbView[\"value\"];\n            return view;\n        });\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (!tableNames || !tableNames.length)\n            return [];\n\n        const tableNamesString = tableNames.map(tableName => `'${tableName}'`).join(\", \");\n\n        // load tables\n        const dbTables: ObjectLiteral[] = await this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" IN (${tableNamesString})`);\n\n        // load indices\n        const dbIndicesDef: ObjectLiteral[] = await this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`);\n\n        // if tables were not found in the db, no need to proceed\n        if (!dbTables || !dbTables.length)\n            return [];\n\n        // create table schemas for loaded tables\n        return Promise.all(dbTables.map(async dbTable => {\n            const table = new Table({name: dbTable[\"name\"]});\n            const sql = dbTable[\"sql\"];\n\n            // load columns and indices\n            const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([\n                this.query(`PRAGMA table_info(\"${dbTable[\"name\"]}\")`),\n                this.query(`PRAGMA index_list(\"${dbTable[\"name\"]}\")`),\n                this.query(`PRAGMA foreign_key_list(\"${dbTable[\"name\"]}\")`),\n            ]);\n\n            // find column name with auto increment\n            let autoIncrementColumnName: string|undefined = undefined;\n            const tableSql: string = dbTable[\"sql\"];\n            let autoIncrementIndex = tableSql.toUpperCase().indexOf(\"AUTOINCREMENT\");\n            if (autoIncrementIndex !== -1) {\n                autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);\n                const comma = autoIncrementColumnName.lastIndexOf(\",\");\n                const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n                if (comma !== -1) {\n                    autoIncrementColumnName = autoIncrementColumnName.substr(comma);\n                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\n                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\n\n                } else if (bracket !== -1) {\n                    autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\n                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\n                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\n                }\n            }\n\n            // create columns from the loaded columns\n            table.columns = dbColumns.map(dbColumn => {\n                const tableColumn = new TableColumn();\n                tableColumn.name = dbColumn[\"name\"];\n                tableColumn.type = dbColumn[\"type\"].toLowerCase();\n                tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\n                tableColumn.isNullable = dbColumn[\"notnull\"] === 0;\n                // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n                tableColumn.isPrimary = dbColumn[\"pk\"] > 0;\n                tableColumn.comment = \"\"; // SQLite does not support column comments\n                tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\n                if (tableColumn.isGenerated) {\n                    tableColumn.generationStrategy = \"increment\";\n                }\n\n                if (tableColumn.type === \"varchar\") {\n                    // Check if this is an enum\n                    const enumMatch = sql.match(new RegExp(\"\\\"(\" + tableColumn.name + \")\\\" varchar CHECK\\\\s*\\\\(\\\\s*\\\\1\\\\s+IN\\\\s*\\\\(('[^']+'(?:\\\\s*,\\\\s*'[^']+')+)\\\\s*\\\\)\\\\s*\\\\)\"));\n                    if (enumMatch) {\n                        // This is an enum\n                        tableColumn.enum = enumMatch[2].substr(1, enumMatch[2].length - 2).split(\"','\");\n                    }\n                }\n\n                // parse datatype and attempt to retrieve length, precision and scale\n                let pos = tableColumn.type.indexOf(\"(\");\n                if (pos !== -1) {\n                    const fullType = tableColumn.type;\n                    let dataType = fullType.substr(0, pos);\n                    if (!!this.driver.withLengthColumnTypes.find(col => col === dataType)) {\n                        let len = parseInt(fullType.substring(pos + 1, fullType.length - 1));\n                        if (len) {\n                            tableColumn.length = len.toString();\n                            tableColumn.type = dataType; // remove the length part from the datatype\n                        }\n                    }\n                    if (!!this.driver.withPrecisionColumnTypes.find(col => col === dataType)) {\n                        const re = new RegExp(`^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`);\n                        const matches = fullType.match(re);\n                        if (matches && matches[1]) {\n                            tableColumn.precision = +matches[1];\n                        }\n                        if (!!this.driver.withScaleColumnTypes.find(col => col === dataType)) {\n                            if (matches && matches[2]) {\n                                tableColumn.scale = +matches[2];\n                            }\n                        }\n                        tableColumn.type = dataType; // remove the precision/scale part from the datatype\n                    }\n                }\n\n                return tableColumn;\n            });\n\n            // build foreign keys\n            const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, dbForeignKey => dbForeignKey[\"id\"]);\n            table.foreignKeys = tableForeignKeyConstraints.map(foreignKey => {\n                const ownForeignKeys = dbForeignKeys.filter(dbForeignKey => dbForeignKey[\"id\"] === foreignKey[\"id\"] && dbForeignKey[\"table\"] === foreignKey[\"table\"]);\n                const columnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"from\"]);\n                const referencedColumnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"to\"]);\n                // build foreign key name, because we can not get it directly.\n                const fkName = this.connection.namingStrategy.foreignKeyName(table, columnNames, foreignKey.referencedTableName, foreignKey.referencedColumnNames);\n\n                return new TableForeignKey({\n                    name: fkName,\n                    columnNames: columnNames,\n                    referencedTableName: foreignKey[\"table\"],\n                    referencedColumnNames: referencedColumnNames,\n                    onDelete: foreignKey[\"on_delete\"],\n                    onUpdate: foreignKey[\"on_update\"]\n                });\n            });\n\n            // find unique constraints from CREATE TABLE sql\n            let uniqueRegexResult;\n            const uniqueMappings: { name: string, columns: string[] }[] = []\n            const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE \\((.*?)\\)/g;\n            while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n                uniqueMappings.push({\n                    name: uniqueRegexResult[1],\n                    columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`\", \"`)\n                });\n            }\n\n            // build unique constraints\n            const tableUniquePromises = dbIndices\n                .filter(dbIndex => dbIndex[\"origin\"] === \"u\")\n                .map(dbIndex => dbIndex[\"name\"])\n                .filter((value, index, self) => self.indexOf(value) === index)\n                .map(async dbIndexName => {\n                    const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n                    const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info(\"${dbIndex![\"name\"]}\")`);\n                    const indexColumns = indexInfos\n                        .sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"]))\n                        .map(indexInfo => indexInfo[\"name\"]);\n\n                    if (indexColumns.length === 1) {\n                        const column = table.columns.find(column => {\n                            return !!indexColumns.find(indexColumn => indexColumn === column.name);\n                        });\n                        if (column)\n                            column.isUnique = true;\n                    }\n\n                    // find existent mapping by a column names\n                    const foundMapping = uniqueMappings.find(mapping => {\n                        return mapping!.columns.every(column =>\n                            indexColumns.indexOf(column) !== -1\n                        )\n                    })\n\n                    return new TableUnique({\n                        name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),\n                        columnNames: indexColumns\n                    });\n                });\n            table.uniques = (await Promise.all(tableUniquePromises)) as TableUnique[];\n\n            // build checks\n            let result;\n            const regexp = /CONSTRAINT \"([^\"]*)\" CHECK (\\(.*?\\))([,]|[)]$)/g;\n            while (((result = regexp.exec(sql)) !== null)) {\n                table.checks.push(new TableCheck({ name: result[1], expression: result[2] }));\n            }\n\n            // build indices\n            const indicesPromises = dbIndices\n                .filter(dbIndex => dbIndex[\"origin\"] === \"c\")\n                .map(dbIndex => dbIndex[\"name\"])\n                .filter((value, index, self) => self.indexOf(value) === index) // unqiue\n                .map(async dbIndexName => {\n\n                    const indexDef = dbIndicesDef.find(dbIndexDef => dbIndexDef[\"name\"] === dbIndexName);\n                    const condition = /WHERE (.*)/.exec(indexDef![\"sql\"]);\n                    const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n                    const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info(\"${dbIndex![\"name\"]}\")`);\n                    const indexColumns = indexInfos\n                        .sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"]))\n                        .map(indexInfo => indexInfo[\"name\"]);\n\n                    const isUnique = dbIndex![\"unique\"] === \"1\" || dbIndex![\"unique\"] === 1;\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: dbIndex![\"name\"],\n                        columnNames: indexColumns,\n                        isUnique: isUnique,\n                        where: condition ? condition[1] : undefined\n                    });\n                });\n            const indices = await Promise.all(indicesPromises);\n            table.indices = indices.filter(index => !!index) as TableIndex[];\n\n            return table;\n        }));\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n\n        const primaryColumns = table.columns.filter(column => column.isPrimary);\n        const hasAutoIncrement = primaryColumns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n        const skipPrimary = primaryColumns.length > 1;\n        if (skipPrimary && hasAutoIncrement)\n            throw new Error(`Sqlite does not support AUTOINCREMENT on composite primary key`);\n\n        const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, skipPrimary)).join(\", \");\n        let sql = `CREATE TABLE \"${table.name}\" (${columnDefinitions}`;\n\n        // need for `addColumn()` method, because it recreates table.\n        table.columns\n            .filter(column => column.isUnique)\n            .forEach(column => {\n                const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n                if (!isUniqueExist)\n                    table.uniques.push(new TableUnique({\n                        name: this.connection.namingStrategy.uniqueConstraintName(table.name, [column.name]),\n                        columnNames: [column.name]\n                    }));\n            });\n\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques.map(unique => {\n                const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table.name, unique.columnNames);\n                const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n                return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n            }).join(\", \");\n\n            sql += `, ${uniquesSql}`;\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks.map(check => {\n                const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table.name, check.expression!);\n                return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n            }).join(\", \");\n\n            sql += `, ${checksSql}`;\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys.map(fk => {\n                const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n                if (!fk.name)\n                    fk.name = this.connection.namingStrategy.foreignKeyName(table.name, fk.columnNames, fk.referencedTableName, fk.referencedColumnNames);\n                const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n\n                let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${fk.referencedTableName}\" (${referencedColumnNames})`;\n                if (fk.onDelete)\n                    constraint += ` ON DELETE ${fk.onDelete}`;\n                if (fk.onUpdate)\n                    constraint += ` ON UPDATE ${fk.onUpdate}`;\n\n                return constraint;\n            }).join(\", \");\n\n            sql += `, ${foreignKeysSql}`;\n        }\n\n        if (primaryColumns.length > 1) {\n            const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n            sql += `, PRIMARY KEY (${columnNames})`;\n        }\n\n        sql += `)`;\n\n        const tableMetadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === table.name);\n        if (tableMetadata && tableMetadata.withoutRowid) {\n            sql += \" WITHOUT ROWID\";\n        }\n\n        return new Query(sql);\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(tableOrName: Table|string, ifExist?: boolean): Query {\n        const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n        const query = ifExist ? `DROP TABLE IF EXISTS \"${tableName}\"` : `DROP TABLE \"${tableName}\"`;\n        return new Query(query);\n    }\n\n    protected createViewSql(view: View): Query {\n        if (typeof view.expression === \"string\") {\n            return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`);\n        } else {\n            return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression(this.connection).getQuery()}`);\n        }\n    }\n\n    protected insertViewDefinitionSql(view: View): Query {\n        const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n        const [query, parameters] = this.connection.createQueryBuilder()\n            .insert()\n            .into(this.getTypeormMetadataTableName())\n            .values({ type: \"VIEW\", name: view.name, value: expression })\n            .getQueryAndParameters();\n\n        return new Query(query, parameters);\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(viewOrPath: View|string): Query {\n        const viewName = viewOrPath instanceof View ? viewOrPath.name : viewOrPath;\n        return new Query(`DROP VIEW \"${viewName}\"`);\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected deleteViewDefinitionSql(viewOrPath: View|string): Query {\n        const viewName = viewOrPath instanceof View ? viewOrPath.name : viewOrPath;\n        const qb = this.connection.createQueryBuilder();\n        const [query, parameters] = qb.delete()\n            .from(this.getTypeormMetadataTableName())\n            .where(`${qb.escape(\"type\")} = 'VIEW'`)\n            .andWhere(`${qb.escape(\"name\")} = :name`, { name: viewName })\n            .getQueryAndParameters();\n\n        return new Query(query, parameters);\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON \"${table.name}\" (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(indexOrName: TableIndex|string): Query {\n        let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n        return new Query(`DROP INDEX \"${indexName}\"`);\n    }\n\n    /**\n     * Builds a query for create column.\n     */\n    protected buildCreateColumnSql(column: TableColumn, skipPrimary?: boolean): string {\n        let c = \"\\\"\" + column.name + \"\\\"\";\n        if (column instanceof ColumnMetadata) {\n            c += \" \" + this.driver.normalizeType(column);\n        } else {\n            c += \" \" + this.connection.driver.createFullType(column);\n        }\n\n        if (column.enum)\n            c += \" CHECK( \" + column.name + \" IN (\" + column.enum.map(val => \"'\" + val + \"'\").join(\",\") + \") )\";\n        if (column.isPrimary && !skipPrimary)\n            c += \" PRIMARY KEY\";\n        if (column.isGenerated === true && column.generationStrategy === \"increment\") // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" AUTOINCREMENT\";\n        if (column.collation)\n            c += \" COLLATE \" + column.collation;\n        if (column.isNullable !== true)\n            c += \" NOT NULL\";\n        if (column.default !== undefined && column.default !== null)\n            c += \" DEFAULT (\" + column.default + \")\";\n\n        return c;\n    }\n\n    protected async recreateTable(newTable: Table, oldTable: Table, migrateData = true): Promise<void> {\n        const upQueries: Query[] = [];\n        const downQueries: Query[] = [];\n\n        // drop old table indices\n        oldTable.indices.forEach(index => {\n            upQueries.push(this.dropIndexSql(index));\n            downQueries.push(this.createIndexSql(oldTable, index));\n        });\n\n        // change table name into 'temporary_table'\n        newTable.name = \"temporary_\" + newTable.name;\n\n        // create new table\n        upQueries.push(this.createTableSql(newTable, true));\n        downQueries.push(this.dropTableSql(newTable));\n\n        // migrate all data from the old table into new table\n        if (migrateData) {\n            let newColumnNames = newTable.columns.map(column => `\"${column.name}\"`).join(\", \");\n            let oldColumnNames = oldTable.columns.map(column => `\"${column.name}\"`).join(\", \");\n            if (oldTable.columns.length < newTable.columns.length) {\n                newColumnNames = newTable.columns.filter(column => {\n                    return oldTable.columns.find(c => c.name === column.name);\n                }).map(column => `\"${column.name}\"`).join(\", \");\n\n            } else if (oldTable.columns.length > newTable.columns.length) {\n                oldColumnNames = oldTable.columns.filter(column => {\n                    return newTable.columns.find(c => c.name === column.name);\n                }).map(column => `\"${column.name}\"`).join(\", \");\n            }\n\n            upQueries.push(new Query(`INSERT INTO \"${newTable.name}\"(${newColumnNames}) SELECT ${oldColumnNames} FROM \"${oldTable.name}\"`));\n            downQueries.push(new Query(`INSERT INTO \"${oldTable.name}\"(${oldColumnNames}) SELECT ${newColumnNames} FROM \"${newTable.name}\"`));\n        }\n\n        // drop old table\n        upQueries.push(this.dropTableSql(oldTable));\n        downQueries.push(this.createTableSql(oldTable, true));\n\n        // rename old table\n        upQueries.push(new Query(`ALTER TABLE \"${newTable.name}\" RENAME TO \"${oldTable.name}\"`));\n        downQueries.push(new Query(`ALTER TABLE \"${oldTable.name}\" RENAME TO \"${newTable.name}\"`));\n        newTable.name = oldTable.name;\n\n        // recreate table indices\n        newTable.indices.forEach(index => {\n            // new index may be passed without name. In this case we generate index name manually.\n            if (!index.name)\n                index.name = this.connection.namingStrategy.indexName(newTable.name, index.columnNames, index.where);\n            upQueries.push(this.createIndexSql(newTable, index));\n            downQueries.push(this.dropIndexSql(index));\n        });\n\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(oldTable, newTable);\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}