{"ast":null,"code":"import { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go thought each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\n\nvar RelationJoinColumnBuilder =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationJoinColumnBuilder(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds a foreign key of the many-to-one or one-to-one owner relations.\n   */\n\n\n  RelationJoinColumnBuilder.prototype.build = function (joinColumns, relation) {\n    var referencedColumns = this.collectReferencedColumns(joinColumns, relation);\n    var columns = this.collectColumns(joinColumns, relation, referencedColumns);\n    if (!referencedColumns.length || !relation.createForeignKeyConstraints) return {\n      foreignKey: undefined,\n      columns: columns,\n      uniqueConstraint: undefined\n    }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n\n    var foreignKey = new ForeignKeyMetadata({\n      entityMetadata: relation.entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      namingStrategy: this.connection.namingStrategy,\n      columns: columns,\n      referencedColumns: referencedColumns,\n      onDelete: relation.onDelete,\n      onUpdate: relation.onUpdate,\n      deferrable: relation.deferrable\n    }); // Oracle does not allow both primary and unique constraints on the same column\n\n    if (this.connection.driver instanceof OracleDriver && columns.every(function (column) {\n      return column.isPrimary;\n    })) return {\n      foreignKey: foreignKey,\n      columns: columns,\n      uniqueConstraint: undefined\n    }; // CockroachDB requires UNIQUE constraints on referenced columns\n\n    if (referencedColumns.length > 0 && relation.isOneToOne) {\n      var uniqueConstraint = new UniqueMetadata({\n        entityMetadata: relation.entityMetadata,\n        columns: foreignKey.columns,\n        args: {\n          name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tablePath, foreignKey.columns.map(function (c) {\n            return c.databaseName;\n          })),\n          target: relation.entityMetadata.target\n        }\n      });\n      uniqueConstraint.build(this.connection.namingStrategy);\n      return {\n        foreignKey: foreignKey,\n        columns: columns,\n        uniqueConstraint: uniqueConstraint\n      };\n    }\n\n    return {\n      foreignKey: foreignKey,\n      columns: columns,\n      uniqueConstraint: undefined\n    };\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n\n\n  RelationJoinColumnBuilder.prototype.collectReferencedColumns = function (joinColumns, relation) {\n    var hasAnyReferencedColumnName = joinColumns.find(function (joinColumnArgs) {\n      return !!joinColumnArgs.referencedColumnName;\n    });\n    var manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\n    var hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\n\n    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {\n      // covers case3 and case1\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      // cases with referenced columns defined\n      return joinColumns.map(function (joinColumn) {\n        var referencedColumn = relation.inverseEntityMetadata.ownColumns.find(function (column) {\n          return column.propertyName === joinColumn.referencedColumnName;\n        }); // todo: can we also search in relations?\n\n        if (!referencedColumn) throw new Error(\"Referenced column \" + joinColumn.referencedColumnName + \" was not found in entity \" + relation.inverseEntityMetadata.name);\n        return referencedColumn;\n      });\n    }\n  };\n  /**\n   * Collects columns from the given join column args.\n   */\n\n\n  RelationJoinColumnBuilder.prototype.collectColumns = function (joinColumns, relation, referencedColumns) {\n    var _this = this;\n\n    return referencedColumns.map(function (referencedColumn) {\n      // in the case if relation has join column with only name set we need this check\n      var joinColumnMetadataArg = joinColumns.find(function (joinColumn) {\n        return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;\n      });\n      var joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : _this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\n      var relationalColumn = relation.entityMetadata.ownColumns.find(function (column) {\n        return column.databaseName === joinColumnName;\n      });\n\n      if (!relationalColumn) {\n        relationalColumn = new ColumnMetadata({\n          connection: _this.connection,\n          entityMetadata: relation.entityMetadata,\n          args: {\n            target: \"\",\n            mode: \"virtual\",\n            propertyName: relation.propertyName,\n            options: {\n              name: joinColumnName,\n              type: referencedColumn.type,\n              length: !referencedColumn.length && (_this.connection.driver instanceof MysqlDriver || _this.connection.driver instanceof AuroraDataApiDriver) && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n              width: referencedColumn.width,\n              charset: referencedColumn.charset,\n              collation: referencedColumn.collation,\n              precision: referencedColumn.precision,\n              scale: referencedColumn.scale,\n              zerofill: referencedColumn.zerofill,\n              unsigned: referencedColumn.unsigned,\n              comment: referencedColumn.comment,\n              enum: referencedColumn.enum,\n              enumName: referencedColumn.enumName,\n              primary: relation.isPrimary,\n              nullable: relation.isNullable\n            }\n          }\n        });\n        relation.entityMetadata.registerColumn(relationalColumn);\n      }\n\n      relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\n\n      relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\n\n      relationalColumn.relationMetadata = relation;\n      relationalColumn.build(_this.connection);\n      return relationalColumn;\n    });\n  };\n\n  return RelationJoinColumnBuilder;\n}();\n\nexport { RelationJoinColumnBuilder };","map":{"version":3,"sources":["../browser/src/metadata-builder/RelationJoinColumnBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {UniqueMetadata} from \"../metadata/UniqueMetadata\";\nimport {ForeignKeyMetadata} from \"../metadata/ForeignKeyMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {JoinColumnMetadataArgs} from \"../metadata-args/JoinColumnMetadataArgs\";\nimport {Connection} from \"../connection/Connection\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go thought each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\nexport class RelationJoinColumnBuilder {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\n     */\n    build(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata): {\n      foreignKey: ForeignKeyMetadata|undefined,\n      columns: ColumnMetadata[],\n      uniqueConstraint: UniqueMetadata|undefined,\n    } {\n        const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\n        const columns = this.collectColumns(joinColumns, relation, referencedColumns);\n        if (!referencedColumns.length || !relation.createForeignKeyConstraints)\n            return { foreignKey: undefined, columns, uniqueConstraint: undefined }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n\n        const foreignKey = new ForeignKeyMetadata({\n            entityMetadata: relation.entityMetadata,\n            referencedEntityMetadata: relation.inverseEntityMetadata,\n            namingStrategy: this.connection.namingStrategy,\n            columns: columns,\n            referencedColumns: referencedColumns,\n            onDelete: relation.onDelete,\n            onUpdate: relation.onUpdate,\n            deferrable: relation.deferrable,\n        });\n\n        // Oracle does not allow both primary and unique constraints on the same column\n        if (this.connection.driver instanceof OracleDriver && columns.every(column => column.isPrimary))\n            return { foreignKey, columns, uniqueConstraint: undefined };\n\n        // CockroachDB requires UNIQUE constraints on referenced columns\n        if (referencedColumns.length > 0 && relation.isOneToOne) {\n            const uniqueConstraint = new UniqueMetadata({\n                entityMetadata: relation.entityMetadata,\n                columns: foreignKey.columns,\n                args: {\n                    name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tablePath, foreignKey.columns.map(c => c.databaseName)),\n                    target: relation.entityMetadata.target,\n                }\n            });\n            uniqueConstraint.build(this.connection.namingStrategy);\n            return {foreignKey, columns, uniqueConstraint};\n        }\n\n        return { foreignKey, columns, uniqueConstraint: undefined };\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    protected collectReferencedColumns(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata): ColumnMetadata[] {\n        const hasAnyReferencedColumnName = joinColumns.find(joinColumnArgs => !!joinColumnArgs.referencedColumnName);\n        const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\n        const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\n\n        if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) { // covers case3 and case1\n            return relation.inverseEntityMetadata.primaryColumns;\n\n        } else { // cases with referenced columns defined\n            return joinColumns.map(joinColumn => {\n                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?\n                if (!referencedColumn)\n                    throw new Error(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n\n                return referencedColumn;\n            });\n        }\n    }\n\n    /**\n     * Collects columns from the given join column args.\n     */\n    private collectColumns(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata, referencedColumns: ColumnMetadata[]): ColumnMetadata[] {\n        return referencedColumns.map(referencedColumn => {\n\n            // in the case if relation has join column with only name set we need this check\n            const joinColumnMetadataArg = joinColumns.find(joinColumn => {\n                return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) &&\n                    !!joinColumn.name;\n            });\n            const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\n\n            let relationalColumn = relation.entityMetadata.ownColumns.find(column => column.databaseName === joinColumnName);\n            if (!relationalColumn) {\n                relationalColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: relation.entityMetadata,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: relation.propertyName,\n                        options: {\n                            name: joinColumnName,\n                            type: referencedColumn.type,\n                            length: !referencedColumn.length\n                                        && (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver)\n                                        && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\")\n                                    ? \"36\"\n                                    : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                            width: referencedColumn.width,\n                            charset: referencedColumn.charset,\n                            collation: referencedColumn.collation,\n                            precision: referencedColumn.precision,\n                            scale: referencedColumn.scale,\n                            zerofill: referencedColumn.zerofill,\n                            unsigned: referencedColumn.unsigned,\n                            comment: referencedColumn.comment,\n                            enum: referencedColumn.enum,\n                            enumName: referencedColumn.enumName,\n                            primary: relation.isPrimary,\n                            nullable: relation.isNullable,\n                        }\n                    }\n                });\n                relation.entityMetadata.registerColumn(relationalColumn);\n            }\n            relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\n            relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\n            relationalColumn.relationMetadata = relation;\n            relationalColumn.build(this.connection);\n            return relationalColumn;\n        });\n    }\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}