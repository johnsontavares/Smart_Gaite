{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\n\nvar RawSqlResultsToEntityTransformer =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RawSqlResultsToEntityTransformer(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {\n    this.expressionMap = expressionMap;\n    this.driver = driver;\n    this.rawRelationIdResults = rawRelationIdResults;\n    this.rawRelationCountResults = rawRelationCountResults;\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n\n\n  RawSqlResultsToEntityTransformer.prototype.transform = function (rawResults, alias) {\n    var _this = this;\n\n    var group = this.group(rawResults, alias);\n    var entities = [];\n    group.forEach(function (results) {\n      var entity = _this.transformRawResultsGroup(results, alias);\n\n      if (entity !== undefined && !Object.values(entity).every(function (value) {\n        return value === null;\n      })) entities.push(entity);\n    });\n    return entities;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Groups given raw results by ids of given alias.\n   */\n\n\n  RawSqlResultsToEntityTransformer.prototype.group = function (rawResults, alias) {\n    var _this = this;\n\n    var map = new Map();\n    var keys = [];\n\n    if (alias.metadata.tableType === \"view\") {\n      keys.push.apply(keys, __spreadArray([], __read(alias.metadata.columns.map(function (column) {\n        return DriverUtils.buildAlias(_this.driver, alias.name, column.databaseName);\n      }))));\n    } else {\n      keys.push.apply(keys, __spreadArray([], __read(alias.metadata.primaryColumns.map(function (column) {\n        return DriverUtils.buildAlias(_this.driver, alias.name, column.databaseName);\n      }))));\n    }\n\n    rawResults.forEach(function (rawResult) {\n      var id = keys.map(function (key) {\n        var keyValue = rawResult[key];\n\n        if (Buffer.isBuffer(keyValue)) {\n          return keyValue.toString(\"hex\");\n        }\n\n        if (typeof keyValue === \"object\") {\n          return JSON.stringify(keyValue);\n        }\n\n        return keyValue;\n      }).join(\"_\"); // todo: check partial\n\n      var items = map.get(id);\n\n      if (!items) {\n        map.set(id, [rawResult]);\n      } else {\n        items.push(rawResult);\n      }\n    });\n    return map;\n  };\n  /**\n   * Transforms set of data results into single entity.\n   */\n\n\n  RawSqlResultsToEntityTransformer.prototype.transformRawResultsGroup = function (rawResults, alias) {\n    var _this = this; // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n\n\n    var metadata = alias.metadata;\n\n    if (metadata.discriminatorColumn) {\n      var discriminatorValues_1 = rawResults.map(function (result) {\n        return result[DriverUtils.buildAlias(_this.driver, alias.name, alias.metadata.discriminatorColumn.databaseName)];\n      });\n      var discriminatorMetadata = metadata.childEntityMetadatas.find(function (childEntityMetadata) {\n        return typeof discriminatorValues_1.find(function (value) {\n          return value === childEntityMetadata.discriminatorValue;\n        }) !== 'undefined';\n      });\n      if (discriminatorMetadata) metadata = discriminatorMetadata;\n    }\n\n    var entity = this.expressionMap.options.indexOf(\"create-pojo\") !== -1 ? {} : metadata.create(this.queryRunner); // get value from columns selections and put them into newly created entity\n\n    var hasColumns = this.transformColumns(rawResults, alias, entity, metadata);\n    var hasRelations = this.transformJoins(rawResults, entity, alias, metadata);\n    var hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);\n    var hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity); // if we have at least one selected column then return this entity\n    // since entity must have at least primary columns to be really selected and transformed into entity\n\n    if (hasColumns) return entity; // if we don't have any selected column we should not return entity,\n    // except for the case when entity only contain a primary column as a relation to another entity\n    // in this case its absolutely possible our entity to not have any columns except a single relation\n\n    var hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.filter(function (column) {\n      return column.isVirtual === false;\n    }).length === 0; // todo: create metadata.hasOnlyVirtualPrimaryColumns\n\n    if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts)) return entity;\n    return undefined;\n  }; // get value from columns selections and put them into object\n\n\n  RawSqlResultsToEntityTransformer.prototype.transformColumns = function (rawResults, alias, entity, metadata) {\n    var _this = this;\n\n    var hasData = false;\n    metadata.columns.forEach(function (column) {\n      // if table inheritance is used make sure this column is not child's column\n      if (metadata.childEntityMetadatas.length > 0 && metadata.childEntityMetadatas.map(function (metadata) {\n        return metadata.target;\n      }).indexOf(column.target) !== -1) return;\n      var value = rawResults[0][DriverUtils.buildAlias(_this.driver, alias.name, column.databaseName)];\n      if (value === undefined || column.isVirtual) return; // if user does not selected the whole entity or he used partial selection and does not select this particular column\n      // then we don't add this column and its value into the entity\n\n      if (!_this.expressionMap.selects.find(function (select) {\n        return select.selection === alias.name || select.selection === alias.name + \".\" + column.propertyPath;\n      })) return;\n      column.setEntityValue(entity, _this.driver.prepareHydratedValue(value, column));\n      if (value !== null) // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n        hasData = true;\n    });\n    return hasData;\n  };\n  /**\n   * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n   */\n\n\n  RawSqlResultsToEntityTransformer.prototype.transformJoins = function (rawResults, entity, alias, metadata) {\n    var _this = this;\n\n    var hasData = false; // let discriminatorValue: string = \"\";\n    // if (metadata.discriminatorColumn)\n    //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n\n    this.expressionMap.joinAttributes.forEach(function (join) {\n      // skip joins without metadata\n      if (!join.metadata) return; // if simple left or inner join was performed without selection then we don't need to do anything\n\n      if (!join.isSelected) return; // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n      // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n\n      if (join.relation) {\n        var relation = metadata.relations.find(function (relation) {\n          return relation.propertyPath === join.relation.propertyPath;\n        });\n        if (!relation) return; // Use current entity's type metadata, join might be from an STI parent with a different type\n\n        if (relation.inverseEntityMetadata) join.alias.metadata = relation.inverseEntityMetadata;\n      } // some checks to make sure this join is for current alias\n\n\n      if (join.mapToProperty) {\n        if (join.mapToPropertyParentAlias !== alias.name) return;\n      } else {\n        if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath) return;\n      } // transform joined data into entities\n\n\n      var result = _this.transform(rawResults, join.alias);\n\n      result = !join.isMany ? result[0] : result;\n      result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database\n\n      if (result === undefined) // if nothing was joined then simply return\n        return; // if join was mapped to some property then save result to that property\n\n      if (join.mapToPropertyPropertyName) {\n        entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds\n      } else {\n        // otherwise set to relation\n        join.relation.setEntityValue(entity, result);\n      }\n\n      hasData = true;\n    });\n    return hasData;\n  };\n\n  RawSqlResultsToEntityTransformer.prototype.transformRelationIds = function (rawSqlResults, alias, entity, metadata) {\n    var _this = this;\n\n    var hasData = false;\n    this.rawRelationIdResults.forEach(function (rawRelationIdResult) {\n      if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name) return;\n      var relation = rawRelationIdResult.relationIdAttribute.relation;\n\n      var valueMap = _this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);\n\n      if (valueMap === undefined || valueMap === null) return;\n      var idMaps = rawRelationIdResult.results.map(function (result) {\n        var entityPrimaryIds = _this.extractEntityPrimaryIds(relation, result);\n\n        if (OrmUtils.compareIds(entityPrimaryIds, valueMap) === false) return;\n        var columns;\n\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n          columns = relation.joinColumns.map(function (joinColumn) {\n            return joinColumn;\n          });\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n          columns = relation.inverseEntityMetadata.primaryColumns.map(function (joinColumn) {\n            return joinColumn;\n          }); // columns = relation.inverseRelation!.joinColumns.map(joinColumn => joinColumn.referencedColumn!); //.inverseEntityMetadata.primaryColumns.map(joinColumn => joinColumn);\n        } else {\n          // ManyToMany\n          if (relation.isOwning) {\n            columns = relation.inverseJoinColumns.map(function (joinColumn) {\n              return joinColumn;\n            });\n          } else {\n            columns = relation.inverseRelation.joinColumns.map(function (joinColumn) {\n              return joinColumn;\n            });\n          }\n        }\n\n        var idMap = columns.reduce(function (idMap, column) {\n          var value = result[column.databaseName];\n\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) // if column is a relation\n              value = column.referencedColumn.createValueMap(value);\n            return OrmUtils.mergeDeep(idMap, column.createValueMap(value));\n          } else {\n            if (column.referencedColumn.referencedColumn) // if column is a relation\n              value = column.referencedColumn.referencedColumn.createValueMap(value);\n            return OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(value));\n          }\n        }, {});\n\n        if (columns.length === 1 && rawRelationIdResult.relationIdAttribute.disableMixedMap === false) {\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return columns[0].getEntityValue(idMap);\n          } else {\n            return columns[0].referencedColumn.getEntityValue(idMap);\n          }\n        }\n\n        return idMap;\n      }).filter(function (result) {\n        return result !== undefined;\n      });\n      var properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\".\");\n\n      var mapToProperty = function (properties, map, value) {\n        var property = properties.shift();\n\n        if (property && properties.length === 0) {\n          map[property] = value;\n          return map;\n        } else if (property && properties.length > 0) {\n          mapToProperty(properties, map[property], value);\n        } else {\n          return map;\n        }\n      };\n\n      if (relation.isOneToOne || relation.isManyToOne) {\n        if (idMaps[0] !== undefined) {\n          mapToProperty(properties, entity, idMaps[0]);\n          hasData = true;\n        }\n      } else {\n        mapToProperty(properties, entity, idMaps);\n\n        if (idMaps.length > 0) {\n          hasData = true;\n        }\n      }\n    });\n    return hasData;\n  };\n\n  RawSqlResultsToEntityTransformer.prototype.transformRelationCounts = function (rawSqlResults, alias, entity) {\n    var _this = this;\n\n    var hasData = false;\n    this.rawRelationCountResults.filter(function (rawRelationCountResult) {\n      return rawRelationCountResult.relationCountAttribute.parentAlias === alias.name;\n    }).forEach(function (rawRelationCountResult) {\n      var relation = rawRelationCountResult.relationCountAttribute.relation;\n      var referenceColumnName;\n\n      if (relation.isOneToMany) {\n        referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]\n      } else {\n        referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n      }\n\n      var referenceColumnValue = rawSqlResults[0][DriverUtils.buildAlias(_this.driver, alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n\n      if (referenceColumnValue !== undefined && referenceColumnValue !== null) {\n        entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;\n        rawRelationCountResult.results.filter(function (result) {\n          return result[\"parentId\"] === referenceColumnValue;\n        }).forEach(function (result) {\n          entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result[\"cnt\"]);\n          hasData = true;\n        });\n      }\n    });\n    return hasData;\n  };\n\n  RawSqlResultsToEntityTransformer.prototype.createValueMapFromJoinColumns = function (relation, parentAlias, rawSqlResults) {\n    var _this = this;\n\n    var columns;\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(function (joinColumn) {\n        return joinColumn;\n      });\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(function (joinColumn) {\n        return joinColumn;\n      });\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(function (joinColumn) {\n          return joinColumn;\n        });\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) {\n          return joinColumn;\n        });\n      }\n    }\n\n    return columns.reduce(function (valueMap, column) {\n      rawSqlResults.forEach(function (rawSqlResult) {\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n          valueMap[column.databaseName] = _this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(_this.driver, parentAlias, column.databaseName)], column);\n        } else {\n          valueMap[column.databaseName] = _this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(_this.driver, parentAlias, column.referencedColumn.databaseName)], column);\n        }\n      });\n      return valueMap;\n    }, {});\n  };\n\n  RawSqlResultsToEntityTransformer.prototype.extractEntityPrimaryIds = function (relation, relationIdRawResult) {\n    var columns;\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(function (joinColumn) {\n        return joinColumn;\n      });\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(function (joinColumn) {\n        return joinColumn;\n      });\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(function (joinColumn) {\n          return joinColumn;\n        });\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) {\n          return joinColumn;\n        });\n      }\n    }\n\n    return columns.reduce(function (data, column) {\n      data[column.databaseName] = relationIdRawResult[column.databaseName];\n      return data;\n    }, {});\n  };\n\n  return RawSqlResultsToEntityTransformer;\n}();\n\nexport { RawSqlResultsToEntityTransformer };","map":{"version":3,"sources":["../browser/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["import {Driver} from \"../../driver/Driver\";\nimport {RelationIdLoadResult} from \"../relation-id/RelationIdLoadResult\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\nimport {Alias} from \"../Alias\";\nimport {RelationCountLoadResult} from \"../relation-count/RelationCountLoadResult\";\nimport {RelationMetadata} from \"../../metadata/RelationMetadata\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {QueryExpressionMap} from \"../QueryExpressionMap\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {QueryRunner} from \"../..\";\nimport {DriverUtils} from \"../../driver/DriverUtils\";\n\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected expressionMap: QueryExpressionMap,\n                protected driver: Driver,\n                protected rawRelationIdResults: RelationIdLoadResult[],\n                protected rawRelationCountResults: RelationCountLoadResult[],\n                protected queryRunner?: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    transform(rawResults: any[], alias: Alias): any[] {\n        const group = this.group(rawResults, alias);\n        const entities: any[] = [];\n        group.forEach(results => {\n            const entity = this.transformRawResultsGroup(results, alias);\n            if (entity !== undefined && !Object.values(entity).every((value) => value === null))\n                entities.push(entity);\n        });\n        return entities;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Groups given raw results by ids of given alias.\n     */\n    protected group(rawResults: any[], alias: Alias): Map<string, any[]> {\n        const map = new Map();\n        const keys: string[] = [];\n        if (alias.metadata.tableType === \"view\") {\n            keys.push(...alias.metadata.columns.map(column => DriverUtils.buildAlias(this.driver, alias.name, column.databaseName)));\n        } else {\n            keys.push(...alias.metadata.primaryColumns.map(column => DriverUtils.buildAlias(this.driver, alias.name, column.databaseName)));\n        }\n        rawResults.forEach(rawResult => {\n            const id = keys.map(key => {\n                const keyValue = rawResult[key];\n\n                if (Buffer.isBuffer(keyValue)) {\n                    return keyValue.toString(\"hex\");\n                }\n\n                if (typeof keyValue === \"object\") {\n                    return JSON.stringify(keyValue);\n                }\n\n                return keyValue;\n            }).join(\"_\"); // todo: check partial\n\n            const items = map.get(id);\n            if (!items) {\n                map.set(id, [rawResult]);\n            } else {\n                items.push(rawResult);\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Transforms set of data results into single entity.\n     */\n    protected transformRawResultsGroup(rawResults: any[], alias: Alias): ObjectLiteral|undefined {\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n        let metadata = alias.metadata;\n\n        if (metadata.discriminatorColumn) {\n            const discriminatorValues = rawResults.map(result => result[DriverUtils.buildAlias(this.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)]);\n            const discriminatorMetadata = metadata.childEntityMetadatas.find(childEntityMetadata => {\n                return typeof discriminatorValues.find(value => value === childEntityMetadata.discriminatorValue) !== 'undefined';\n            });\n            if (discriminatorMetadata)\n                metadata = discriminatorMetadata;\n        }\n        let entity: any = this.expressionMap.options.indexOf(\"create-pojo\") !== -1 ? {} : metadata.create(this.queryRunner);\n\n        // get value from columns selections and put them into newly created entity\n        const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);\n        const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);\n        const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);\n        const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);\n\n        // if we have at least one selected column then return this entity\n        // since entity must have at least primary columns to be really selected and transformed into entity\n        if (hasColumns)\n            return entity;\n\n        // if we don't have any selected column we should not return entity,\n        // except for the case when entity only contain a primary column as a relation to another entity\n        // in this case its absolutely possible our entity to not have any columns except a single relation\n        const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.filter(column => column.isVirtual === false).length === 0; // todo: create metadata.hasOnlyVirtualPrimaryColumns\n        if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts))\n            return entity;\n\n        return undefined;\n    }\n\n    // get value from columns selections and put them into object\n    protected transformColumns(rawResults: any[], alias: Alias, entity: ObjectLiteral, metadata: EntityMetadata): boolean {\n        let hasData = false;\n        metadata.columns.forEach(column => {\n\n            // if table inheritance is used make sure this column is not child's column\n            if (metadata.childEntityMetadatas.length > 0 && metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1)\n                return;\n\n            const value = rawResults[0][DriverUtils.buildAlias(this.driver, alias.name, column.databaseName)];\n            if (value === undefined || column.isVirtual)\n                return;\n\n            // if user does not selected the whole entity or he used partial selection and does not select this particular column\n            // then we don't add this column and its value into the entity\n            if (!this.expressionMap.selects.find(select => select.selection === alias.name || select.selection === alias.name + \".\" + column.propertyPath))\n                return;\n\n            column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));\n            if (value !== null) // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n                hasData = true;\n        });\n        return hasData;\n    }\n\n    /**\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n     */\n    protected transformJoins(rawResults: any[], entity: ObjectLiteral, alias: Alias, metadata: EntityMetadata) {\n        let hasData = false;\n\n        // let discriminatorValue: string = \"\";\n        // if (metadata.discriminatorColumn)\n        //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n\n        this.expressionMap.joinAttributes.forEach(join => { // todo: we have problem here - when inner joins are used without selects it still create empty array\n\n            // skip joins without metadata\n            if (!join.metadata)\n                return;\n\n            // if simple left or inner join was performed without selection then we don't need to do anything\n            if (!join.isSelected)\n                return;\n\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n            if (join.relation) {\n                const relation = metadata.relations.find(relation => relation.propertyPath === join.relation!.propertyPath);\n                if (!relation)\n                    return;\n\n                // Use current entity's type metadata, join might be from an STI parent with a different type\n                if (relation.inverseEntityMetadata)\n                    join.alias.metadata = relation.inverseEntityMetadata;\n            }\n\n            // some checks to make sure this join is for current alias\n            if (join.mapToProperty) {\n                if (join.mapToPropertyParentAlias !== alias.name)\n                    return;\n            } else {\n                if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation!.propertyPath)\n                    return;\n            }\n\n            // transform joined data into entities\n            let result: any = this.transform(rawResults, join.alias);\n            result = !join.isMany ? result[0] : result;\n            result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database\n            if (result === undefined) // if nothing was joined then simply return\n                return;\n\n            // if join was mapped to some property then save result to that property\n            if (join.mapToPropertyPropertyName) {\n                entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds\n\n            } else { // otherwise set to relation\n                join.relation!.setEntityValue(entity, result);\n            }\n\n            hasData = true;\n        });\n        return hasData;\n    }\n\n    protected transformRelationIds(rawSqlResults: any[], alias: Alias, entity: ObjectLiteral, metadata: EntityMetadata): boolean {\n        let hasData = false;\n        this.rawRelationIdResults.forEach(rawRelationIdResult => {\n            if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name)\n                return;\n\n            const relation = rawRelationIdResult.relationIdAttribute.relation;\n            const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);\n            if (valueMap === undefined || valueMap === null)\n                return;\n\n            const idMaps = rawRelationIdResult.results.map(result => {\n                const entityPrimaryIds = this.extractEntityPrimaryIds(relation, result);\n                if (OrmUtils.compareIds(entityPrimaryIds, valueMap) === false)\n                    return;\n\n                let columns: ColumnMetadata[];\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    columns = relation.joinColumns.map(joinColumn => joinColumn);\n                } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                    columns = relation.inverseEntityMetadata.primaryColumns.map(joinColumn => joinColumn);\n                    // columns = relation.inverseRelation!.joinColumns.map(joinColumn => joinColumn.referencedColumn!); //.inverseEntityMetadata.primaryColumns.map(joinColumn => joinColumn);\n                } else { // ManyToMany\n                    if (relation.isOwning) {\n                        columns = relation.inverseJoinColumns.map(joinColumn => joinColumn);\n                    } else {\n                        columns = relation.inverseRelation!.joinColumns.map(joinColumn => joinColumn);\n                    }\n                }\n\n                const idMap = columns.reduce((idMap, column) => {\n                    let value = result[column.databaseName];\n                    if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                        if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) // if column is a relation\n                            value = column.referencedColumn.createValueMap(value);\n\n                        return OrmUtils.mergeDeep(idMap, column.createValueMap(value));\n                    } else {\n                        if (column.referencedColumn!.referencedColumn) // if column is a relation\n                            value = column.referencedColumn!.referencedColumn!.createValueMap(value);\n\n                        return OrmUtils.mergeDeep(idMap, column.referencedColumn!.createValueMap(value));\n                    }\n                }, {} as ObjectLiteral);\n\n                if (columns.length === 1 && rawRelationIdResult.relationIdAttribute.disableMixedMap === false) {\n                    if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                        return columns[0].getEntityValue(idMap);\n                    } else {\n                        return columns[0].referencedColumn!.getEntityValue(idMap);\n                    }\n                }\n                return idMap;\n            }).filter(result => result !== undefined);\n\n            const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\".\");\n            const mapToProperty = (properties: string[], map: ObjectLiteral, value: any): any => {\n\n                const property = properties.shift();\n                if (property && properties.length === 0) {\n                    map[property] = value;\n                    return map;\n                } else if (property && properties.length > 0) {\n                    mapToProperty(properties, map[property], value);\n                } else {\n                    return map;\n                }\n            };\n            if (relation.isOneToOne || relation.isManyToOne) {\n                if (idMaps[0] !== undefined) {\n                    mapToProperty(properties, entity, idMaps[0]);\n                    hasData = true;\n                }\n            } else {\n                mapToProperty(properties, entity, idMaps);\n                if (idMaps.length > 0) {\n                    hasData = true;\n                }\n            }\n        });\n\n        return hasData;\n    }\n\n    protected transformRelationCounts(rawSqlResults: any[], alias: Alias, entity: ObjectLiteral): boolean {\n        let hasData = false;\n        this.rawRelationCountResults\n            .filter(rawRelationCountResult => rawRelationCountResult.relationCountAttribute.parentAlias === alias.name)\n            .forEach(rawRelationCountResult => {\n                const relation = rawRelationCountResult.relationCountAttribute.relation;\n                let referenceColumnName: string;\n\n                if (relation.isOneToMany) {\n                    referenceColumnName = relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName;  // todo: fix joinColumns[0]\n\n                } else {\n                    referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn!.databaseName : relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName;\n                }\n\n                const referenceColumnValue = rawSqlResults[0][DriverUtils.buildAlias(this.driver, alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n                if (referenceColumnValue !== undefined && referenceColumnValue !== null) {\n                    entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;\n                    rawRelationCountResult.results\n                        .filter(result => result[\"parentId\"] === referenceColumnValue)\n                        .forEach(result => {\n                            entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result[\"cnt\"]);\n                            hasData = true;\n                        });\n                }\n            });\n\n        return hasData;\n    }\n\n    private createValueMapFromJoinColumns(relation: RelationMetadata, parentAlias: string, rawSqlResults: any[]): ObjectLiteral {\n        let columns: ColumnMetadata[];\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(joinColumn => joinColumn);\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map(joinColumn => joinColumn);\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(joinColumn => joinColumn);\n            }\n        }\n        return columns.reduce((valueMap, column) => {\n            rawSqlResults.forEach(rawSqlResult => {\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, parentAlias, column.databaseName)], column);\n                } else {\n                    valueMap[column.databaseName] =  this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, parentAlias, column.referencedColumn!.databaseName)], column);\n                }\n            });\n            return valueMap;\n        }, {} as ObjectLiteral);\n\n    }\n\n    private extractEntityPrimaryIds(relation: RelationMetadata, relationIdRawResult: any) {\n        let columns: ColumnMetadata[];\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(joinColumn => joinColumn);\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map(joinColumn => joinColumn);\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(joinColumn => joinColumn);\n            }\n        }\n        return columns.reduce((data, column) => {\n            data[column.databaseName] = relationIdRawResult[column.databaseName];\n            return data;\n        }, {} as ObjectLiteral);\n    }\n\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n        const virtualColumns = this.expressionMap.selects\n            .filter(select => select.virtual)\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\n\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n    }*/\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}