{"ast":null,"code":"import { __awaiter, __generator, __values } from \"tslib\";\nimport { Table } from \"../schema-builder/table/Table\";\nimport { Migration } from \"./Migration\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { MongoDriver } from \"../driver/mongodb/MongoDriver\";\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\n\nvar MigrationExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function MigrationExecutor(connection, queryRunner) {\n    this.connection = connection;\n    this.queryRunner = queryRunner; // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n\n    this.transaction = \"all\";\n    var options = this.connection.driver.options;\n    this.migrationsTableName = connection.options.migrationsTableName || \"migrations\";\n    this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, options.schema, options.database);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Tries to execute a single migration given.\n   */\n\n\n  MigrationExecutor.prototype.executeMigration = function (migration) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.withQueryRunner(function (queryRunner) {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , this.createMigrationsTableIfNotExist(queryRunner)];\n\n                case 1:\n                  _a.sent();\n\n                  return [4\n                  /*yield*/\n                  , migration.instance.up(queryRunner)];\n\n                case 2:\n                  _a.sent();\n\n                  return [4\n                  /*yield*/\n                  , this.insertExecutedMigration(queryRunner, migration)];\n\n                case 3:\n                  _a.sent();\n\n                  return [2\n                  /*return*/\n                  , migration];\n              }\n            });\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Returns an array of all migrations.\n   */\n\n\n  MigrationExecutor.prototype.getAllMigrations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.resolve(this.getMigrations())];\n      });\n    });\n  };\n  /**\n   * Returns an array of all executed migrations.\n   */\n\n\n  MigrationExecutor.prototype.getExecutedMigrations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.withQueryRunner(function (queryRunner) {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , this.createMigrationsTableIfNotExist(queryRunner)];\n\n                case 1:\n                  _a.sent();\n\n                  return [4\n                  /*yield*/\n                  , this.loadExecutedMigrations(queryRunner)];\n\n                case 2:\n                  return [2\n                  /*return*/\n                  , _a.sent()];\n              }\n            });\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Returns an array of all pending migrations.\n   */\n\n\n  MigrationExecutor.prototype.getPendingMigrations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allMigrations, executedMigrations;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getAllMigrations()];\n\n          case 1:\n            allMigrations = _a.sent();\n            return [4\n            /*yield*/\n            , this.getExecutedMigrations()];\n\n          case 2:\n            executedMigrations = _a.sent();\n            return [2\n            /*return*/\n            , allMigrations.filter(function (migration) {\n              return !executedMigrations.find(function (executedMigration) {\n                return executedMigration.name === migration.name;\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Inserts an executed migration.\n   */\n\n\n  MigrationExecutor.prototype.insertMigration = function (migration) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.withQueryRunner(function (queryRunner) {\n        _this.insertExecutedMigration(queryRunner, migration).then(resolve).catch(reject);\n      });\n    });\n  };\n  /**\n   * Deletes an executed migration.\n   */\n\n\n  MigrationExecutor.prototype.deleteMigration = function (migration) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.withQueryRunner(function (queryRunner) {\n        _this.deleteExecutedMigration(queryRunner, migration).then(resolve).catch(reject);\n      });\n    });\n  };\n  /**\n   * Lists all migrations and whether they have been executed or not\n   * returns true if there are unapplied migrations\n   */\n\n\n  MigrationExecutor.prototype.showMigrations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var hasUnappliedMigrations, queryRunner, executedMigrations, allMigrations, _loop_1, this_1, allMigrations_1, allMigrations_1_1, migration;\n\n      var e_1, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            hasUnappliedMigrations = false;\n            queryRunner = this.queryRunner || this.connection.createQueryRunner(); // create migrations table if its not created yet\n\n            return [4\n            /*yield*/\n            , this.createMigrationsTableIfNotExist(queryRunner)];\n\n          case 1:\n            // create migrations table if its not created yet\n            _b.sent();\n\n            return [4\n            /*yield*/\n            , this.loadExecutedMigrations(queryRunner)];\n\n          case 2:\n            executedMigrations = _b.sent();\n            allMigrations = this.getMigrations();\n\n            _loop_1 = function (migration) {\n              var executedMigration = executedMigrations.find(function (executedMigration) {\n                return executedMigration.name === migration.name;\n              });\n\n              if (executedMigration) {\n                this_1.connection.logger.logSchemaBuild(\" [X] \" + migration.name);\n              } else {\n                hasUnappliedMigrations = true;\n                this_1.connection.logger.logSchemaBuild(\" [ ] \" + migration.name);\n              }\n            };\n\n            this_1 = this;\n\n            try {\n              for (allMigrations_1 = __values(allMigrations), allMigrations_1_1 = allMigrations_1.next(); !allMigrations_1_1.done; allMigrations_1_1 = allMigrations_1.next()) {\n                migration = allMigrations_1_1.value;\n\n                _loop_1(migration);\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (allMigrations_1_1 && !allMigrations_1_1.done && (_a = allMigrations_1.return)) _a.call(allMigrations_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 3:\n            _b.sent();\n\n            _b.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , hasUnappliedMigrations];\n        }\n      });\n    });\n  };\n  /**\n   * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n   * thus not saved in the database.\n   */\n\n\n  MigrationExecutor.prototype.executePendingMigrations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, executedMigrations, lastTimeExecutedMigration, allMigrations, successMigrations, pendingMigrations, transactionStartedByUs, _loop_2, this_2, pendingMigrations_1, pendingMigrations_1_1, migration, e_2_1, err_1, rollbackError_1;\n\n      var e_2, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            queryRunner = this.queryRunner || this.connection.createQueryRunner(); // create migrations table if its not created yet\n\n            return [4\n            /*yield*/\n            , this.createMigrationsTableIfNotExist(queryRunner)];\n\n          case 1:\n            // create migrations table if its not created yet\n            _b.sent();\n\n            return [4\n            /*yield*/\n            , this.loadExecutedMigrations(queryRunner)];\n\n          case 2:\n            executedMigrations = _b.sent();\n            lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);\n            allMigrations = this.getMigrations();\n            successMigrations = [];\n            pendingMigrations = allMigrations.filter(function (migration) {\n              // check if we already have executed migration\n              var executedMigration = executedMigrations.find(function (executedMigration) {\n                return executedMigration.name === migration.name;\n              });\n              if (executedMigration) return false; // migration is new and not executed. now check if its timestamp is correct\n              // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n              //     throw new Error(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n              // every check is passed means that migration was not run yet and we need to run it\n\n              return true;\n            });\n            if (!!pendingMigrations.length) return [3\n            /*break*/\n            , 5];\n            this.connection.logger.logSchemaBuild(\"No migrations are pending\");\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 3:\n            _b.sent();\n\n            _b.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , []];\n\n          case 5:\n            // log information about migration execution\n            this.connection.logger.logSchemaBuild(executedMigrations.length + \" migrations are already loaded in the database.\");\n            this.connection.logger.logSchemaBuild(allMigrations.length + \" migrations were found in the source code.\");\n            if (lastTimeExecutedMigration) this.connection.logger.logSchemaBuild(lastTimeExecutedMigration.name + \" is the last executed migration. It was executed on \" + new Date(lastTimeExecutedMigration.timestamp).toString() + \".\");\n            this.connection.logger.logSchemaBuild(pendingMigrations.length + \" migrations are new migrations that needs to be executed.\");\n            transactionStartedByUs = false;\n            if (!(this.transaction === \"all\" && !queryRunner.isTransactionActive)) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 6:\n            _b.sent();\n\n            transactionStartedByUs = true;\n            _b.label = 7;\n\n          case 7:\n            _b.trys.push([7, 18, 23, 26]);\n\n            _loop_2 = function (migration) {\n              return __generator(this, function (_c) {\n                switch (_c.label) {\n                  case 0:\n                    if (!(this_2.transaction === \"each\" && !queryRunner.isTransactionActive)) return [3\n                    /*break*/\n                    , 2];\n                    return [4\n                    /*yield*/\n                    , queryRunner.startTransaction()];\n\n                  case 1:\n                    _c.sent();\n\n                    transactionStartedByUs = true;\n                    _c.label = 2;\n\n                  case 2:\n                    return [4\n                    /*yield*/\n                    , migration.instance.up(queryRunner).then(function () {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        return __generator(this, function (_a) {\n                          switch (_a.label) {\n                            case 0:\n                              // now when migration is executed we need to insert record about it into the database\n                              return [4\n                              /*yield*/\n                              , this.insertExecutedMigration(queryRunner, migration)];\n\n                            case 1:\n                              _a.sent();\n\n                              if (!(this.transaction === \"each\" && transactionStartedByUs)) return [3\n                              /*break*/\n                              , 3];\n                              return [4\n                              /*yield*/\n                              , queryRunner.commitTransaction()];\n\n                            case 2:\n                              _a.sent();\n\n                              _a.label = 3;\n\n                            case 3:\n                              return [2\n                              /*return*/\n                              ];\n                          }\n                        });\n                      });\n                    }).then(function () {\n                      successMigrations.push(migration);\n\n                      _this.connection.logger.logSchemaBuild(\"Migration \" + migration.name + \" has been executed successfully.\");\n                    })];\n\n                  case 3:\n                    _c.sent();\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_2 = this;\n            _b.label = 8;\n\n          case 8:\n            _b.trys.push([8, 13, 14, 15]);\n\n            pendingMigrations_1 = __values(pendingMigrations), pendingMigrations_1_1 = pendingMigrations_1.next();\n            _b.label = 9;\n\n          case 9:\n            if (!!pendingMigrations_1_1.done) return [3\n            /*break*/\n            , 12];\n            migration = pendingMigrations_1_1.value;\n            return [5\n            /*yield**/\n            , _loop_2(migration)];\n\n          case 10:\n            _b.sent();\n\n            _b.label = 11;\n\n          case 11:\n            pendingMigrations_1_1 = pendingMigrations_1.next();\n            return [3\n            /*break*/\n            , 9];\n\n          case 12:\n            return [3\n            /*break*/\n            , 15];\n\n          case 13:\n            e_2_1 = _b.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 15];\n\n          case 14:\n            try {\n              if (pendingMigrations_1_1 && !pendingMigrations_1_1.done && (_a = pendingMigrations_1.return)) _a.call(pendingMigrations_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            if (!(this.transaction === \"all\" && transactionStartedByUs)) return [3\n            /*break*/\n            , 17];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 16:\n            _b.sent();\n\n            _b.label = 17;\n\n          case 17:\n            return [3\n            /*break*/\n            , 26];\n\n          case 18:\n            err_1 = _b.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 22];\n            _b.label = 19;\n\n          case 19:\n            _b.trys.push([19, 21,, 22]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 20:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 22];\n\n          case 21:\n            rollbackError_1 = _b.sent();\n            return [3\n            /*break*/\n            , 22];\n\n          case 22:\n            throw err_1;\n\n          case 23:\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 25];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 24:\n            _b.sent();\n\n            _b.label = 25;\n\n          case 25:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 26:\n            return [2\n            /*return*/\n            , successMigrations];\n        }\n      });\n    });\n  };\n  /**\n   * Reverts last migration that were run.\n   */\n\n\n  MigrationExecutor.prototype.undoLastMigration = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, executedMigrations, lastTimeExecutedMigration, allMigrations, migrationToRevert, transactionStartedByUs, err_2, rollbackError_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryRunner = this.queryRunner || this.connection.createQueryRunner(); // create migrations table if its not created yet\n\n            return [4\n            /*yield*/\n            , this.createMigrationsTableIfNotExist(queryRunner)];\n\n          case 1:\n            // create migrations table if its not created yet\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.loadExecutedMigrations(queryRunner)];\n\n          case 2:\n            executedMigrations = _a.sent();\n            lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations); // if no migrations found in the database then nothing to revert\n\n            if (!lastTimeExecutedMigration) {\n              this.connection.logger.logSchemaBuild(\"No migrations was found in the database. Nothing to revert!\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            allMigrations = this.getMigrations();\n            migrationToRevert = allMigrations.find(function (migration) {\n              return migration.name === lastTimeExecutedMigration.name;\n            }); // if no migrations found in the database then nothing to revert\n\n            if (!migrationToRevert) throw new Error(\"No migration \" + lastTimeExecutedMigration.name + \" was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.\"); // log information about migration execution\n\n            this.connection.logger.logSchemaBuild(executedMigrations.length + \" migrations are already loaded in the database.\");\n            this.connection.logger.logSchemaBuild(lastTimeExecutedMigration.name + \" is the last executed migration. It was executed on \" + new Date(lastTimeExecutedMigration.timestamp).toString() + \".\");\n            this.connection.logger.logSchemaBuild(\"Now reverting it...\");\n            transactionStartedByUs = false;\n            if (!(this.transaction !== \"none\" && !queryRunner.isTransactionActive)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 3:\n            _a.sent();\n\n            transactionStartedByUs = true;\n            _a.label = 4;\n\n          case 4:\n            _a.trys.push([4, 9, 14, 17]);\n\n            return [4\n            /*yield*/\n            , migrationToRevert.instance.down(queryRunner)];\n\n          case 5:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.deleteExecutedMigration(queryRunner, migrationToRevert)];\n\n          case 6:\n            _a.sent();\n\n            this.connection.logger.logSchemaBuild(\"Migration \" + migrationToRevert.name + \" has been reverted successfully.\");\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            return [3\n            /*break*/\n            , 17];\n\n          case 9:\n            err_2 = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 13];\n            _a.label = 10;\n\n          case 10:\n            _a.trys.push([10, 12,, 13]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 11:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            rollbackError_2 = _a.sent();\n            return [3\n            /*break*/\n            , 13];\n\n          case 13:\n            throw err_2;\n\n          case 14:\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 15:\n            _a.sent();\n\n            _a.label = 16;\n\n          case 16:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 17:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates table \"migrations\" that will store information about executed migrations.\n   */\n\n\n  MigrationExecutor.prototype.createMigrationsTableIfNotExist = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tableExist;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // If driver is mongo no need to create\n            if (this.connection.driver instanceof MongoDriver) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , queryRunner.hasTable(this.migrationsTable)];\n\n          case 1:\n            tableExist = _a.sent();\n            if (!!tableExist) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.createTable(new Table({\n              name: this.migrationsTable,\n              columns: [{\n                name: \"id\",\n                type: this.connection.driver.normalizeType({\n                  type: this.connection.driver.mappedDataTypes.migrationId\n                }),\n                isGenerated: true,\n                generationStrategy: \"increment\",\n                isPrimary: true,\n                isNullable: false\n              }, {\n                name: \"timestamp\",\n                type: this.connection.driver.normalizeType({\n                  type: this.connection.driver.mappedDataTypes.migrationTimestamp\n                }),\n                isPrimary: false,\n                isNullable: false\n              }, {\n                name: \"name\",\n                type: this.connection.driver.normalizeType({\n                  type: this.connection.driver.mappedDataTypes.migrationName\n                }),\n                isNullable: false\n              }]\n            }))];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Loads all migrations that were executed and saved into the database (sorts by id).\n   */\n\n\n  MigrationExecutor.prototype.loadExecutedMigrations = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mongoRunner, migrationsRaw;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.connection.driver instanceof MongoDriver)) return [3\n            /*break*/\n            , 2];\n            mongoRunner = queryRunner;\n            return [4\n            /*yield*/\n            , mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).find().sort({\n              \"_id\": -1\n            }).toArray()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.connection.manager.createQueryBuilder(queryRunner).select().orderBy(this.connection.driver.escape(\"id\"), \"DESC\").from(this.migrationsTable, this.migrationsTableName).getRawMany()];\n\n          case 3:\n            migrationsRaw = _a.sent();\n            return [2\n            /*return*/\n            , migrationsRaw.map(function (migrationRaw) {\n              return new Migration(parseInt(migrationRaw[\"id\"]), parseInt(migrationRaw[\"timestamp\"]), migrationRaw[\"name\"]);\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Gets all migrations that setup for this connection.\n   */\n\n\n  MigrationExecutor.prototype.getMigrations = function () {\n    var migrations = this.connection.migrations.map(function (migration) {\n      var migrationClassName = migration.name || migration.constructor.name;\n      var migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);\n\n      if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n        throw new Error(migrationClassName + \" migration name is wrong. Migration class name should have a JavaScript timestamp appended.\");\n      }\n\n      return new Migration(undefined, migrationTimestamp, migrationClassName, migration);\n    });\n    this.checkForDuplicateMigrations(migrations); // sort them by timestamp\n\n    return migrations.sort(function (a, b) {\n      return a.timestamp - b.timestamp;\n    });\n  };\n\n  MigrationExecutor.prototype.checkForDuplicateMigrations = function (migrations) {\n    var migrationNames = migrations.map(function (migration) {\n      return migration.name;\n    });\n    var duplicates = Array.from(new Set(migrationNames.filter(function (migrationName, index) {\n      return migrationNames.indexOf(migrationName) < index;\n    })));\n\n    if (duplicates.length > 0) {\n      throw Error(\"Duplicate migrations: \" + duplicates.join(\", \"));\n    }\n  };\n  /**\n   * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n   */\n\n\n  MigrationExecutor.prototype.getLatestTimestampMigration = function (migrations) {\n    var sortedMigrations = migrations.map(function (migration) {\n      return migration;\n    }).sort(function (a, b) {\n      return (a.timestamp - b.timestamp) * -1;\n    });\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  };\n  /**\n   * Finds the latest migration in the given array of migrations.\n   * PRE: Migration array must be sorted by descending id.\n   */\n\n\n  MigrationExecutor.prototype.getLatestExecutedMigration = function (sortedMigrations) {\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  };\n  /**\n   * Inserts new executed migration's data into migrations table.\n   */\n\n\n  MigrationExecutor.prototype.insertExecutedMigration = function (queryRunner, migration) {\n    return __awaiter(this, void 0, void 0, function () {\n      var values, mongoRunner, qb;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            values = {};\n\n            if (this.connection.driver instanceof SqlServerDriver) {\n              values[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes.migrationTimestamp\n              }));\n              values[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes.migrationName\n              }));\n            } else {\n              values[\"timestamp\"] = migration.timestamp;\n              values[\"name\"] = migration.name;\n            }\n\n            if (!(this.connection.driver instanceof MongoDriver)) return [3\n            /*break*/\n            , 2];\n            mongoRunner = queryRunner;\n            return [4\n            /*yield*/\n            , mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).insertOne(values)];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            qb = queryRunner.manager.createQueryBuilder();\n            return [4\n            /*yield*/\n            , qb.insert().into(this.migrationsTable).values(values).execute()];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Delete previously executed migration's data from the migrations table.\n   */\n\n\n  MigrationExecutor.prototype.deleteExecutedMigration = function (queryRunner, migration) {\n    return __awaiter(this, void 0, void 0, function () {\n      var conditions, mongoRunner, qb;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            conditions = {};\n\n            if (this.connection.driver instanceof SqlServerDriver) {\n              conditions[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes.migrationTimestamp\n              }));\n              conditions[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes.migrationName\n              }));\n            } else {\n              conditions[\"timestamp\"] = migration.timestamp;\n              conditions[\"name\"] = migration.name;\n            }\n\n            if (!(this.connection.driver instanceof MongoDriver)) return [3\n            /*break*/\n            , 2];\n            mongoRunner = queryRunner;\n            return [4\n            /*yield*/\n            , mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).deleteOne(conditions)];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            qb = queryRunner.manager.createQueryBuilder();\n            return [4\n            /*yield*/\n            , qb.delete().from(this.migrationsTable).where(qb.escape(\"timestamp\") + \" = :timestamp\").andWhere(qb.escape(\"name\") + \" = :name\").setParameters(conditions).execute()];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  MigrationExecutor.prototype.withQueryRunner = function (callback) {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryRunner = this.queryRunner || this.connection.createQueryRunner();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 2, 5]);\n\n            return [2\n            /*return*/\n            , callback(queryRunner)];\n\n          case 2:\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return MigrationExecutor;\n}();\n\nexport { MigrationExecutor };","map":{"version":3,"sources":["../browser/src/migration/MigrationExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import {Table} from \"../schema-builder/table/Table\";\nimport {Connection} from \"../connection/Connection\";\nimport {Migration} from \"./Migration\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {MssqlParameter} from \"../driver/sqlserver/MssqlParameter\";\nimport {SqlServerConnectionOptions} from \"../driver/sqlserver/SqlServerConnectionOptions\";\nimport {PostgresConnectionOptions} from \"../driver/postgres/PostgresConnectionOptions\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {MongoQueryRunner} from \"../driver/mongodb/MongoQueryRunner\";\n\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\nexport class MigrationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n    transaction: \"all\" | \"none\" | \"each\" = \"all\";\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private readonly migrationsTable: string;\n    private readonly migrationsTableName: string;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunner?: QueryRunner) {\n\n        const options = <SqlServerConnectionOptions|PostgresConnectionOptions>this.connection.driver.options;\n        this.migrationsTableName = connection.options.migrationsTableName || \"migrations\";\n        this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, options.schema, options.database);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Tries to execute a single migration given.\n     */\n    public async executeMigration(migration: Migration): Promise<Migration> {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner);\n            await (migration.instance as any).up(queryRunner);\n            await this.insertExecutedMigration(queryRunner, migration);\n\n            return migration;\n        });\n    }\n\n    /**\n     * Returns an array of all migrations.\n     */\n    public async getAllMigrations(): Promise<Migration[]> {\n        return Promise.resolve(this.getMigrations());\n    }\n\n    /**\n     * Returns an array of all executed migrations.\n     */\n    public async getExecutedMigrations(): Promise<Migration[]> {\n        return this.withQueryRunner(async queryRunner => {\n            await this.createMigrationsTableIfNotExist(queryRunner);\n\n            return await this.loadExecutedMigrations(queryRunner);\n        });\n    }\n\n    /**\n     * Returns an array of all pending migrations.\n     */\n    public async getPendingMigrations(): Promise<Migration[]> {\n        const allMigrations = await this.getAllMigrations();\n        const executedMigrations = await this.getExecutedMigrations();\n\n        return allMigrations.filter(migration =>\n            !executedMigrations.find(\n                executedMigration =>\n                    executedMigration.name === migration.name\n            )\n        );\n    }\n\n    /**\n     * Inserts an executed migration.\n     */\n    public insertMigration(migration: Migration): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.withQueryRunner(queryRunner => {\n                this.insertExecutedMigration(queryRunner, migration)\n                    .then(resolve)\n                    .catch(reject);\n            });\n        });\n    }\n\n    /**\n     * Deletes an executed migration.\n     */\n    public deleteMigration(migration: Migration): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.withQueryRunner(queryRunner => {\n                this.deleteExecutedMigration(queryRunner, migration)\n                    .then(resolve)\n                    .catch(reject);\n            });\n        });\n    }\n\n    /**\n     * Lists all migrations and whether they have been executed or not\n     * returns true if there are unapplied migrations\n     */\n    async showMigrations(): Promise<boolean> {\n        let hasUnappliedMigrations = false;\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner);\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations();\n\n        for (const migration of allMigrations) {\n            const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n\n            if (executedMigration) {\n                this.connection.logger.logSchemaBuild(` [X] ${migration.name}`);\n            } else {\n                hasUnappliedMigrations = true;\n                this.connection.logger.logSchemaBuild(` [ ] ${migration.name}`);\n            }\n        }\n\n        // if query runner was created by us then release it\n        if (!this.queryRunner) {\n            await queryRunner.release();\n        }\n\n        return hasUnappliedMigrations;\n    }\n\n    /**\n     * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n     * thus not saved in the database.\n     */\n    async executePendingMigrations(): Promise<Migration[]> {\n\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner);\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations();\n\n        // variable to store all migrations we did successefuly\n        const successMigrations: Migration[] = [];\n\n        // find all migrations that needs to be executed\n        const pendingMigrations = allMigrations.filter(migration => {\n            // check if we already have executed migration\n            const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n            if (executedMigration)\n                return false;\n\n            // migration is new and not executed. now check if its timestamp is correct\n            // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n            //     throw new Error(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n\n            // every check is passed means that migration was not run yet and we need to run it\n            return true;\n        });\n\n        // if no migrations are pending then nothing to do here\n        if (!pendingMigrations.length) {\n            this.connection.logger.logSchemaBuild(`No migrations are pending`);\n            // if query runner was created by us then release it\n            if (!this.queryRunner)\n                await queryRunner.release();\n            return [];\n        }\n\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n        this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);\n        if (lastTimeExecutedMigration)\n            this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n        this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations that needs to be executed.`);\n\n        // start transaction if its not started yet\n        let transactionStartedByUs = false;\n        if (this.transaction === \"all\" && !queryRunner.isTransactionActive) {\n            await queryRunner.startTransaction();\n            transactionStartedByUs = true;\n        }\n\n        // run all pending migrations in a sequence\n        try {\n            for (const migration of pendingMigrations) {\n                if (this.transaction === \"each\" && !queryRunner.isTransactionActive) {\n                    await queryRunner.startTransaction();\n                    transactionStartedByUs = true;\n                }\n\n                await migration.instance!.up(queryRunner)\n                    .then(async () => { // now when migration is executed we need to insert record about it into the database\n                        await this.insertExecutedMigration(queryRunner, migration);\n                        // commit transaction if we started it\n                        if (this.transaction === \"each\" && transactionStartedByUs)\n                            await queryRunner.commitTransaction();\n                    })\n                    .then(() => { // informative log about migration success\n                        successMigrations.push(migration);\n                        this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been executed successfully.`);\n                    });\n            }\n\n            // commit transaction if we started it\n            if (this.transaction === \"all\" && transactionStartedByUs)\n                await queryRunner.commitTransaction();\n\n        } catch (err) { // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try { // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n\n            throw err;\n\n        } finally {\n\n            // if query runner was created by us then release it\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n        return successMigrations;\n\n    }\n\n    /**\n     * Reverts last migration that were run.\n     */\n    async undoLastMigration(): Promise<void> {\n\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner);\n\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations);\n\n        // if no migrations found in the database then nothing to revert\n        if (!lastTimeExecutedMigration) {\n            this.connection.logger.logSchemaBuild(`No migrations was found in the database. Nothing to revert!`);\n            return;\n        }\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations();\n\n        // find the instance of the migration we need to remove\n        const migrationToRevert = allMigrations.find(migration => migration.name === lastTimeExecutedMigration!.name);\n\n        // if no migrations found in the database then nothing to revert\n        if (!migrationToRevert)\n            throw new Error(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);\n\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n        this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n        this.connection.logger.logSchemaBuild(`Now reverting it...`);\n\n        // start transaction if its not started yet\n        let transactionStartedByUs = false;\n        if ((this.transaction !== \"none\") && !queryRunner.isTransactionActive) {\n            await queryRunner.startTransaction();\n            transactionStartedByUs = true;\n        }\n\n        try {\n            await migrationToRevert.instance!.down(queryRunner);\n            await this.deleteExecutedMigration(queryRunner, migrationToRevert);\n            this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been reverted successfully.`);\n\n            // commit transaction if we started it\n            if (transactionStartedByUs)\n                await queryRunner.commitTransaction();\n\n        } catch (err) { // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try { // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n\n            throw err;\n\n        } finally {\n\n            // if query runner was created by us then release it\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates table \"migrations\" that will store information about executed migrations.\n     */\n    protected async createMigrationsTableIfNotExist(queryRunner: QueryRunner): Promise<void> {\n        // If driver is mongo no need to create\n        if (this.connection.driver instanceof MongoDriver) {\n            return;\n        }\n        const tableExist = await queryRunner.hasTable(this.migrationsTable); // todo: table name should be configurable\n        if (!tableExist) {\n            await queryRunner.createTable(new Table(\n                {\n                    name: this.migrationsTable,\n                    columns: [\n                        {\n                            name: \"id\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationId}),\n                            isGenerated: true,\n                            generationStrategy: \"increment\",\n                            isPrimary: true,\n                            isNullable: false\n                        },\n                        {\n                            name: \"timestamp\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationTimestamp}),\n                            isPrimary: false,\n                            isNullable: false\n                        },\n                        {\n                            name: \"name\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationName}),\n                            isNullable: false\n                        },\n                    ]\n                },\n            ));\n        }\n    }\n\n    /**\n     * Loads all migrations that were executed and saved into the database (sorts by id).\n     */\n    protected async loadExecutedMigrations(queryRunner: QueryRunner): Promise<Migration[]> {\n        if (this.connection.driver instanceof MongoDriver) {\n            const mongoRunner = queryRunner as MongoQueryRunner;\n            return await mongoRunner.databaseConnection\n            .db(this.connection.driver.database!)\n            .collection(this.migrationsTableName)\n            .find<Migration>()\n            .sort({\"_id\": -1})\n            .toArray();\n        } else {\n            const migrationsRaw: ObjectLiteral[] = await this.connection.manager\n            .createQueryBuilder(queryRunner)\n            .select()\n            .orderBy(this.connection.driver.escape(\"id\"), \"DESC\")\n            .from(this.migrationsTable, this.migrationsTableName)\n            .getRawMany();\n            return migrationsRaw.map(migrationRaw => {\n                return new Migration(parseInt(migrationRaw[\"id\"]), parseInt(migrationRaw[\"timestamp\"]), migrationRaw[\"name\"]);\n            });\n        }\n    }\n\n    /**\n     * Gets all migrations that setup for this connection.\n     */\n    protected getMigrations(): Migration[] {\n        const migrations = this.connection.migrations.map(migration => {\n            const migrationClassName = migration.name || (migration.constructor as any).name;\n            const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);\n            if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n                throw new Error(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);\n            }\n\n            return new Migration(undefined, migrationTimestamp, migrationClassName, migration);\n        });\n\n        this.checkForDuplicateMigrations(migrations);\n\n        // sort them by timestamp\n        return migrations.sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    protected checkForDuplicateMigrations(migrations: Migration[]) {\n        const migrationNames = migrations.map(migration => migration.name);\n        const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));\n        if (duplicates.length > 0) {\n            throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`);\n        }\n    }\n\n    /**\n     * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n     */\n    protected getLatestTimestampMigration(migrations: Migration[]): Migration|undefined {\n        const sortedMigrations = migrations.map(migration => migration).sort((a, b) => (a.timestamp - b.timestamp) * -1);\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n    }\n\n    /**\n     * Finds the latest migration in the given array of migrations.\n     * PRE: Migration array must be sorted by descending id.\n     */\n    protected getLatestExecutedMigration(sortedMigrations: Migration[]): Migration|undefined {\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n    }\n\n    /**\n     * Inserts new executed migration's data into migrations table.\n     */\n    protected async insertExecutedMigration(queryRunner: QueryRunner, migration: Migration): Promise<void> {\n        const values: ObjectLiteral = {};\n        if (this.connection.driver instanceof SqlServerDriver) {\n            values[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationTimestamp }) as any);\n            values[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationName }) as any);\n        } else {\n            values[\"timestamp\"] = migration.timestamp;\n            values[\"name\"] = migration.name;\n        }\n        if (this.connection.driver instanceof MongoDriver) {\n            const mongoRunner = queryRunner as MongoQueryRunner;\n            await mongoRunner.databaseConnection.db(this.connection.driver.database!).collection(this.migrationsTableName).insertOne(values);\n        } else {\n            const qb = queryRunner.manager.createQueryBuilder();\n            await qb.insert()\n                .into(this.migrationsTable)\n                .values(values)\n                .execute();\n        }\n    }\n\n    /**\n     * Delete previously executed migration's data from the migrations table.\n     */\n    protected async deleteExecutedMigration(queryRunner: QueryRunner, migration: Migration): Promise<void> {\n\n        const conditions: ObjectLiteral = {};\n        if (this.connection.driver instanceof SqlServerDriver) {\n            conditions[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationTimestamp }) as any);\n            conditions[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationName }) as any);\n        } else {\n            conditions[\"timestamp\"] = migration.timestamp;\n            conditions[\"name\"] = migration.name;\n        }\n\n        if (this.connection.driver instanceof MongoDriver) {\n            const mongoRunner = queryRunner as MongoQueryRunner;\n            await mongoRunner.databaseConnection.db(this.connection.driver.database!).collection(this.migrationsTableName).deleteOne(conditions);\n        } else {\n            const qb = queryRunner.manager.createQueryBuilder();\n            await qb.delete()\n                .from(this.migrationsTable)\n                .where(`${qb.escape(\"timestamp\")} = :timestamp`)\n                .andWhere(`${qb.escape(\"name\")} = :name`)\n                .setParameters(conditions)\n                .execute();\n        }\n\n    }\n\n    protected async withQueryRunner<T extends any>(callback: (queryRunner: QueryRunner) => T) {\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n        try {\n            return callback(queryRunner);\n        } finally {\n            if (!this.queryRunner) {\n                await queryRunner.release();\n            }\n        }\n    }\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}