{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { TransactionAlreadyStartedError } from \"../../error/TransactionAlreadyStartedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nvar ExpoQueryRunner =\n/** @class */\nfunction (_super) {\n  __extends(ExpoQueryRunner, _super); // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n\n  function ExpoQueryRunner(driver) {\n    var _this = _super.call(this) || this;\n\n    _this.driver = driver;\n    _this.connection = driver.connection;\n    _this.broadcaster = new Broadcaster(_this);\n    return _this;\n  }\n  /**\n   * Starts transaction. Within Expo, all database operations happen in a\n   * transaction context, so issuing a `BEGIN TRANSACTION` command is\n   * redundant and will result in the following error:\n   *\n   * `Error: Error code 1: cannot start a transaction within a transaction`\n   *\n   * Instead, we keep track of a `Transaction` object in `this.transaction`\n   * and continue using the same object until we wish to commit the\n   * transaction.\n   */\n\n\n  ExpoQueryRunner.prototype.startTransaction = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var beforeBroadcastResult, afterBroadcastResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.isTransactionActive && typeof this.transaction !== \"undefined\") throw new TransactionAlreadyStartedError();\n            beforeBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastBeforeTransactionStartEvent(beforeBroadcastResult);\n            if (!(beforeBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all(beforeBroadcastResult.promises)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.isTransactionActive = true;\n            afterBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastAfterTransactionStartEvent(afterBroadcastResult);\n            if (!(afterBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , Promise.all(afterBroadcastResult.promises)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   * Since Expo will automatically commit the transaction once all the\n   * callbacks of the transaction object have been completed, \"committing\" a\n   * transaction in this driver's context means that we delete the transaction\n   * object and set the stage for the next transaction.\n   */\n\n\n  ExpoQueryRunner.prototype.commitTransaction = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var beforeBroadcastResult, afterBroadcastResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.isTransactionActive && typeof this.transaction === \"undefined\") throw new TransactionNotStartedError();\n            beforeBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastBeforeTransactionCommitEvent(beforeBroadcastResult);\n            if (!(beforeBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all(beforeBroadcastResult.promises)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.isTransactionActive = false;\n            this.transaction = undefined;\n            afterBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastAfterTransactionCommitEvent(afterBroadcastResult);\n            if (!(afterBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , Promise.all(afterBroadcastResult.promises)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   * This method's functionality is identical to `commitTransaction()` because\n   * the transaction lifecycle is handled within the Expo transaction object.\n   * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n   */\n\n\n  ExpoQueryRunner.prototype.rollbackTransaction = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var beforeBroadcastResult, afterBroadcastResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.isTransactionActive && typeof this.transaction === \"undefined\") throw new TransactionNotStartedError();\n            beforeBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastBeforeTransactionRollbackEvent(beforeBroadcastResult);\n            if (!(beforeBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all(beforeBroadcastResult.promises)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.isTransactionActive = false;\n            this.transaction = undefined;\n            afterBroadcastResult = new BroadcasterResult();\n            this.broadcaster.broadcastAfterTransactionRollbackEvent(afterBroadcastResult);\n            if (!(afterBroadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , Promise.all(afterBroadcastResult.promises)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  ExpoQueryRunner.prototype.query = function (query, parameters) {\n    var _this = this;\n\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(function (ok, fail) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var databaseConnection, queryStartTime;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.connect()];\n\n            case 1:\n              databaseConnection = _a.sent();\n              this.driver.connection.logger.logQuery(query, parameters, this);\n              queryStartTime = +new Date(); // All Expo SQL queries are executed in a transaction context\n\n              databaseConnection.transaction(function (transaction) {\n                if (typeof _this.transaction === \"undefined\") {\n                  _this.startTransaction();\n\n                  _this.transaction = transaction;\n                }\n\n                _this.transaction.executeSql(query, parameters, function (t, result) {\n                  // log slow queries if maxQueryExecution time is set\n                  var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;\n                  var queryEndTime = +new Date();\n                  var queryExecutionTime = queryEndTime - queryStartTime;\n\n                  if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n                    _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);\n                  } // return id of inserted row, if query was insert statement.\n\n\n                  if (query.substr(0, 11) === \"INSERT INTO\") {\n                    ok(result.insertId);\n                  } else {\n                    var resultSet = [];\n\n                    for (var i = 0; i < result.rows.length; i++) {\n                      resultSet.push(result.rows.item(i));\n                    }\n\n                    ok(resultSet);\n                  }\n                }, function (t, err) {\n                  _this.driver.connection.logger.logQueryError(err, query, parameters, _this);\n\n                  fail(new QueryFailedError(query, parameters, err));\n                });\n              }, function (err) {\n                _this.rollbackTransaction();\n              }, function () {\n                _this.isTransactionActive = false;\n                _this.transaction = undefined;\n              });\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n\n  return ExpoQueryRunner;\n}(AbstractSqliteQueryRunner);\n\nexport { ExpoQueryRunner };","map":{"version":3,"sources":["../browser/src/driver/expo/ExpoQueryRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\nimport {AbstractSqliteQueryRunner} from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\nimport {ExpoDriver} from \"./ExpoDriver\";\nimport {Broadcaster} from \"../../subscriber/Broadcaster\";\nimport {BroadcasterResult} from \"../../subscriber/BroadcasterResult\";\n\n// Needed to satisfy the Typescript compiler\ninterface IResultSet {\n    insertId: number | undefined;\n    rowsAffected: number;\n    rows: {\n        length: number;\n        item: (idx: number) => any;\n        _array: any[];\n    };\n}\ninterface ITransaction {\n    executeSql: (\n        sql: string,\n        args: any[] | undefined,\n        ok: (tsx: ITransaction, resultSet: IResultSet) => void,\n        fail: (tsx: ITransaction, err: any) => void\n    ) => void;\n}\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: ExpoDriver;\n\n    /**\n     * Database transaction object\n     */\n    private transaction?: ITransaction;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: ExpoDriver) {\n        super();\n        this.driver = driver;\n        this.connection = driver.connection;\n        this.broadcaster = new Broadcaster(this);\n    }\n\n    /**\n     * Starts transaction. Within Expo, all database operations happen in a\n     * transaction context, so issuing a `BEGIN TRANSACTION` command is\n     * redundant and will result in the following error:\n     *\n     * `Error: Error code 1: cannot start a transaction within a transaction`\n     *\n     * Instead, we keep track of a `Transaction` object in `this.transaction`\n     * and continue using the same object until we wish to commit the\n     * transaction.\n     */\n    async startTransaction(): Promise<void> {\n        if (this.isTransactionActive && typeof this.transaction !== \"undefined\")\n            throw new TransactionAlreadyStartedError();\n\n        const beforeBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastBeforeTransactionStartEvent(beforeBroadcastResult);\n        if (beforeBroadcastResult.promises.length > 0) await Promise.all(beforeBroadcastResult.promises);\n\n        this.isTransactionActive = true;\n\n        const afterBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastAfterTransactionStartEvent(afterBroadcastResult);\n        if (afterBroadcastResult.promises.length > 0) await Promise.all(afterBroadcastResult.promises);\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     * Since Expo will automatically commit the transaction once all the\n     * callbacks of the transaction object have been completed, \"committing\" a\n     * transaction in this driver's context means that we delete the transaction\n     * object and set the stage for the next transaction.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive && typeof this.transaction === \"undefined\")\n            throw new TransactionNotStartedError();\n\n        const beforeBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastBeforeTransactionCommitEvent(beforeBroadcastResult);\n        if (beforeBroadcastResult.promises.length > 0) await Promise.all(beforeBroadcastResult.promises);\n\n        this.isTransactionActive = false;\n        this.transaction = undefined;\n\n        const afterBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastAfterTransactionCommitEvent(afterBroadcastResult);\n        if (afterBroadcastResult.promises.length > 0) await Promise.all(afterBroadcastResult.promises);\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     * This method's functionality is identical to `commitTransaction()` because\n     * the transaction lifecycle is handled within the Expo transaction object.\n     * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive && typeof this.transaction === \"undefined\")\n            throw new TransactionNotStartedError();\n\n        const beforeBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastBeforeTransactionRollbackEvent(beforeBroadcastResult);\n        if (beforeBroadcastResult.promises.length > 0) await Promise.all(beforeBroadcastResult.promises);\n\n        this.isTransactionActive = false;\n        this.transaction = undefined;\n\n        const afterBroadcastResult = new BroadcasterResult();\n        this.broadcaster.broadcastAfterTransactionRollbackEvent(afterBroadcastResult);\n        if (afterBroadcastResult.promises.length > 0) await Promise.all(afterBroadcastResult.promises);\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        return new Promise<any>(async (ok, fail) => {\n            const databaseConnection = await this.connect();\n            this.driver.connection.logger.logQuery(query, parameters, this);\n            const queryStartTime = +new Date();\n            // All Expo SQL queries are executed in a transaction context\n            databaseConnection.transaction((transaction: ITransaction) => {\n                if (typeof this.transaction === \"undefined\") {\n                    this.startTransaction();\n                    this.transaction = transaction;\n                }\n                this.transaction.executeSql(query, parameters, (t: ITransaction, result: IResultSet) => {\n                    // log slow queries if maxQueryExecution time is set\n                    const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\n                    const queryEndTime = +new Date();\n                    const queryExecutionTime = queryEndTime - queryStartTime;\n                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n                        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n                    }\n\n                    // return id of inserted row, if query was insert statement.\n                    if (query.substr(0, 11) === \"INSERT INTO\") {\n                        ok(result.insertId);\n                    }\n                    else {\n                        let resultSet = [];\n                        for (let i = 0; i < result.rows.length; i++) {\n                            resultSet.push(result.rows.item(i));\n                        }\n                        ok(resultSet);\n                    }\n                }, (t: ITransaction, err: any) => {\n                    this.driver.connection.logger.logQueryError(err, query, parameters, this);\n                    fail(new QueryFailedError(query, parameters, err));\n                });\n            }, (err: any) => {\n                this.rollbackTransaction();\n            }, () => {\n                this.isTransactionActive = false;\n                this.transaction = undefined;\n            });\n        });\n    }\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}