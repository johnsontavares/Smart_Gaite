{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { SapDriver } from \"../driver/sap/SapDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\n\nvar RelationUpdater =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationUpdater(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs set or add operation on a relation.\n   */\n\n\n  RelationUpdater.prototype.update = function (value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var relation, updateSet, updateSet_1, ofs, parameters_1, conditions_1, condition, of_1, updateSet, junctionMetadata_1, ofs, values, firstColumnValues, secondColumnValues_1, bulkInserted_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            relation = this.expressionMap.relationMetadata;\n            if (!(relation.isManyToOne || relation.isOneToOneOwner)) return [3\n            /*break*/\n            , 2];\n            updateSet = relation.joinColumns.reduce(function (updateSet, joinColumn) {\n              var relationValue = value instanceof Object ? joinColumn.referencedColumn.getEntityValue(value) : value;\n              joinColumn.setEntityValue(updateSet, relationValue);\n              return updateSet;\n            }, {});\n            if (!this.expressionMap.of || Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length) return [2\n            /*return*/\n            ];\n            return [4\n            /*yield*/\n            , this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(this.expressionMap.of).execute()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 2:\n            if (!((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null)) return [3\n            /*break*/\n            , 4];\n            updateSet_1 = {};\n            relation.inverseRelation.joinColumns.forEach(function (column) {\n              updateSet_1[column.propertyName] = null;\n            });\n            ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            parameters_1 = {};\n            conditions_1 = [];\n            ofs.forEach(function (of, ofIndex) {\n              relation.inverseRelation.joinColumns.map(function (column, columnIndex) {\n                var parameterName = \"joinColumn_\" + ofIndex + \"_\" + columnIndex;\n                parameters_1[parameterName] = of instanceof Object ? column.referencedColumn.getEntityValue(of) : of;\n                conditions_1.push(column.propertyPath + \" = :\" + parameterName);\n              });\n            });\n            condition = conditions_1.map(function (str) {\n              return \"(\" + str + \")\";\n            }).join(\" OR \");\n            if (!condition) return [2\n            /*return*/\n            ];\n            return [4\n            /*yield*/\n            , this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet_1).where(condition).setParameters(parameters_1).execute()];\n\n          case 3:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 4:\n            if (!(relation.isOneToOneNotOwner || relation.isOneToMany)) return [3\n            /*break*/\n            , 6];\n            if (Array.isArray(this.expressionMap.of)) throw new Error(\"You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.\");\n            of_1 = this.expressionMap.of;\n            updateSet = relation.inverseRelation.joinColumns.reduce(function (updateSet, joinColumn) {\n              var relationValue = of_1 instanceof Object ? joinColumn.referencedColumn.getEntityValue(of_1) : of_1;\n              joinColumn.setEntityValue(updateSet, relationValue);\n              return updateSet;\n            }, {});\n            if (!value || Array.isArray(value) && !value.length) return [2\n            /*return*/\n            ];\n            return [4\n            /*yield*/\n            , this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute()];\n\n          case 5:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 6:\n            junctionMetadata_1 = relation.junctionEntityMetadata;\n            ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            values = Array.isArray(value) ? value : [value];\n            firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            secondColumnValues_1 = relation.isManyToManyOwner ? values : ofs;\n            bulkInserted_1 = [];\n            firstColumnValues.forEach(function (firstColumnVal) {\n              secondColumnValues_1.forEach(function (secondColumnVal) {\n                var inserted = {};\n                junctionMetadata_1.ownerColumns.forEach(function (column) {\n                  inserted[column.databaseName] = firstColumnVal instanceof Object ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n                });\n                junctionMetadata_1.inverseColumns.forEach(function (column) {\n                  inserted[column.databaseName] = secondColumnVal instanceof Object ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n                });\n                bulkInserted_1.push(inserted);\n              });\n            });\n            if (!bulkInserted_1.length) return [2\n            /*return*/\n            ];\n            if (!(this.queryBuilder.connection.driver instanceof OracleDriver || this.queryBuilder.connection.driver instanceof SapDriver)) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , Promise.all(bulkInserted_1.map(function (value) {\n              return _this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata_1.tableName).values(value).execute();\n            }))];\n\n          case 7:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 8:\n            return [4\n            /*yield*/\n            , this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata_1.tableName).values(bulkInserted_1).execute()];\n\n          case 9:\n            _a.sent();\n\n            _a.label = 10;\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return RelationUpdater;\n}();\n\nexport { RelationUpdater };","map":{"version":3,"sources":["../browser/src/query-builder/RelationUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import {SapDriver} from \"../driver/sap/SapDriver\";\nimport {QueryBuilder} from \"./QueryBuilder\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryBuilder: QueryBuilder<any>,\n                protected expressionMap: QueryExpressionMap) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs set or add operation on a relation.\n     */\n    async update(value: any|any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata;\n\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n\n            const updateSet = relation.joinColumns.reduce((updateSet, joinColumn) => {\n                const relationValue = value instanceof Object ? joinColumn.referencedColumn!.getEntityValue(value) : value;\n                joinColumn.setEntityValue(updateSet, relationValue);\n                return updateSet;\n            }, {} as any);\n\n            if (!this.expressionMap.of || (Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length)) return;\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.entityMetadata.target)\n                .set(updateSet)\n                .whereInIds(this.expressionMap.of)\n                .execute();\n\n        } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) { // we handle null a bit different way\n\n            const updateSet: ObjectLiteral = {};\n            relation.inverseRelation!.joinColumns.forEach(column => {\n                updateSet[column.propertyName] = null;\n            });\n\n            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            const parameters: ObjectLiteral = {};\n            const conditions: string[] = [];\n            ofs.forEach((of, ofIndex) => {\n                relation.inverseRelation!.joinColumns.map((column, columnIndex) => {\n                    const parameterName = \"joinColumn_\" + ofIndex + \"_\" + columnIndex;\n                    parameters[parameterName] = of instanceof Object ? column.referencedColumn!.getEntityValue(of) : of;\n                    conditions.push(`${column.propertyPath} = :${parameterName}`);\n                });\n            });\n            const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n            if (!condition) return;\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute();\n\n        } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n\n            if (Array.isArray(this.expressionMap.of))\n                throw new Error(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n\n            const of = this.expressionMap.of;\n            const updateSet = relation.inverseRelation!.joinColumns.reduce((updateSet, joinColumn) => {\n                const relationValue = of instanceof Object ? joinColumn.referencedColumn!.getEntityValue(of) : of;\n                joinColumn.setEntityValue(updateSet, relationValue);\n                return updateSet;\n            }, {} as any);\n\n            if (!value || (Array.isArray(value) && !value.length)) return;\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .whereInIds(value)\n                .execute();\n\n        } else { // many to many\n            const junctionMetadata = relation.junctionEntityMetadata!;\n            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            const values = Array.isArray(value) ? value : [value];\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n\n            const bulkInserted: ObjectLiteral[] = [];\n            firstColumnValues.forEach(firstColumnVal => {\n                secondColumnValues.forEach(secondColumnVal => {\n                    const inserted: ObjectLiteral = {};\n                    junctionMetadata.ownerColumns.forEach(column => {\n                        inserted[column.databaseName] = firstColumnVal instanceof Object ? column.referencedColumn!.getEntityValue(firstColumnVal) : firstColumnVal;\n                    });\n                    junctionMetadata.inverseColumns.forEach(column => {\n                        inserted[column.databaseName] = secondColumnVal instanceof Object ? column.referencedColumn!.getEntityValue(secondColumnVal) : secondColumnVal;\n                    });\n                    bulkInserted.push(inserted);\n                });\n            });\n\n            if (!bulkInserted.length) return;\n\n            if (this.queryBuilder.connection.driver instanceof OracleDriver || this.queryBuilder.connection.driver instanceof SapDriver) {\n                await Promise.all(bulkInserted.map(value => {\n                    return this.queryBuilder\n                        .createQueryBuilder()\n                        .insert()\n                        .into(junctionMetadata.tableName)\n                        .values(value)\n                        .execute();\n                }));\n            } else {\n                await this.queryBuilder\n                    .createQueryBuilder()\n                    .insert()\n                    .into(junctionMetadata.tableName)\n                    .values(bulkInserted)\n                    .execute();\n            }\n        }\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}