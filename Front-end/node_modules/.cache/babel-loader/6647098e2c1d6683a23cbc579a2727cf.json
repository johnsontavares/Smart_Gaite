{"ast":null,"code":"import { CustomRepositoryDoesNotHaveEntityError } from \"../error/CustomRepositoryDoesNotHaveEntityError\";\nimport { getMetadataArgsStorage } from \"../index\";\nimport { CustomRepositoryNotFoundError } from \"../error/CustomRepositoryNotFoundError\";\n/**\n * Provides abstract class for custom repositories that do not inherit from original orm Repository.\n * Contains all most-necessary methods to simplify code in the custom repository.\n * All methods are protected thus not exposed and it allows to create encapsulated custom repository.\n *\n * @experimental\n */\n\nvar AbstractRepository =\n/** @class */\nfunction () {\n  function AbstractRepository() {}\n\n  Object.defineProperty(AbstractRepository.prototype, \"repository\", {\n    // -------------------------------------------------------------------------\n    // Protected Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the original ORM repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    get: function () {\n      var target = this.getCustomRepositoryTarget(this);\n      if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n      return this.manager.getRepository(target);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractRepository.prototype, \"treeRepository\", {\n    /**\n     * Gets the original ORM tree repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    get: function () {\n      var target = this.getCustomRepositoryTarget(this);\n      if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n      return this.manager.getTreeRepository(target);\n    },\n    enumerable: false,\n    configurable: true\n  }); // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a new query builder for the repository's entity that can be used to build a sql query.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n\n  AbstractRepository.prototype.createQueryBuilder = function (alias) {\n    var target = this.getCustomRepositoryTarget(this.constructor);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getRepository(target).createQueryBuilder(alias);\n  };\n  /**\n   * Creates a new query builder for the given entity that can be used to build a sql query.\n   */\n\n\n  AbstractRepository.prototype.createQueryBuilderFor = function (entity, alias) {\n    return this.getRepositoryFor(entity).createQueryBuilder(alias);\n  };\n  /**\n   * Gets the original ORM repository for the given entity class.\n   */\n\n\n  AbstractRepository.prototype.getRepositoryFor = function (entity) {\n    return this.manager.getRepository(entity);\n  };\n  /**\n   * Gets the original ORM tree repository for the given entity class.\n   */\n\n\n  AbstractRepository.prototype.getTreeRepositoryFor = function (entity) {\n    return this.manager.getTreeRepository(entity);\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets custom repository's managed entity.\n   * If given custom repository does not manage any entity then undefined will be returned.\n   */\n\n\n  AbstractRepository.prototype.getCustomRepositoryTarget = function (customRepository) {\n    var entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(function (repository) {\n      return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);\n    });\n    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);\n    return entityRepositoryMetadataArgs.entity;\n  };\n\n  return AbstractRepository;\n}();\n\nexport { AbstractRepository };","map":{"version":3,"sources":["../browser/src/repository/AbstractRepository.ts"],"names":[],"mappings":"AAMA,SAAQ,sCAAR,QAAqD,iDAArD;AACA,SAAQ,sBAAR,QAAqC,UAArC;AACA,SAAQ,6BAAR,QAA4C,wCAA5C;AAGA;;;;;;AAMG;;AACH,IAAA,kBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,kBAAA,GAAA,CA8FC;;AA3EG,EAAA,MAAA,CAAA,cAAA,CAAc,kBAAA,CAAA,SAAd,EAAc,YAAd,EAAwB;AARxB;AACA;AACA;;AAEA;;;AAGG;SACH,YAAA;AACI,UAAM,MAAM,GAAG,KAAK,yBAAL,CAA+B,IAA/B,CAAf;AACA,UAAI,CAAC,MAAL,EACI,MAAM,IAAI,sCAAJ,CAA2C,KAAK,WAAhD,CAAN;AAEJ,aAAO,KAAK,OAAL,CAAa,aAAb,CAAmC,MAAnC,CAAP;AACH,KANuB;qBAAA;;AAAA,GAAxB;AAYA,EAAA,MAAA,CAAA,cAAA,CAAc,kBAAA,CAAA,SAAd,EAAc,gBAAd,EAA4B;AAJ5B;;;AAGG;SACH,YAAA;AACI,UAAM,MAAM,GAAG,KAAK,yBAAL,CAA+B,IAA/B,CAAf;AACA,UAAI,CAAC,MAAL,EACI,MAAM,IAAI,sCAAJ,CAA2C,KAAK,WAAhD,CAAN;AAEJ,aAAO,KAAK,OAAL,CAAa,iBAAb,CAAuC,MAAvC,CAAP;AACH,KAN2B;qBAAA;;AAAA,GAA5B,EA/BJ,CAuCI;AACA;AACA;;AAEA;;;AAGG;;AACO,EAAA,kBAAA,CAAA,SAAA,CAAA,kBAAA,GAAV,UAA6B,KAA7B,EAA0C;AACtC,QAAM,MAAM,GAAG,KAAK,yBAAL,CAA+B,KAAK,WAApC,CAAf;AACA,QAAI,CAAC,MAAL,EACI,MAAM,IAAI,sCAAJ,CAA2C,KAAK,WAAhD,CAAN;AAEJ,WAAO,KAAK,OAAL,CAAa,aAAb,CAAmC,MAAnC,EAA2C,kBAA3C,CAA8D,KAA9D,CAAP;AACH,GANS;AAQV;;AAEG;;;AACO,EAAA,kBAAA,CAAA,SAAA,CAAA,qBAAA,GAAV,UAAmC,MAAnC,EAA0D,KAA1D,EAAuE;AACnE,WAAO,KAAK,gBAAL,CAAsB,MAAtB,EAA8B,kBAA9B,CAAiD,KAAjD,CAAP;AACH,GAFS;AAIV;;AAEG;;;AACO,EAAA,kBAAA,CAAA,SAAA,CAAA,gBAAA,GAAV,UAA8B,MAA9B,EAAmD;AAC/C,WAAO,KAAK,OAAL,CAAa,aAAb,CAA2B,MAA3B,CAAP;AACH,GAFS;AAIV;;AAEG;;;AACO,EAAA,kBAAA,CAAA,SAAA,CAAA,oBAAA,GAAV,UAAkC,MAAlC,EAAuD;AACnD,WAAO,KAAK,OAAL,CAAa,iBAAb,CAA+B,MAA/B,CAAP;AACH,GAFS,CAxEd,CA4EI;AACA;AACA;;AAEA;;;AAGG;;;AACK,EAAA,kBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,gBAAlC,EAAuD;AACnD,QAAM,4BAA4B,GAAG,sBAAsB,GAAG,kBAAzB,CAA4C,IAA5C,CAAiD,UAAA,UAAA,EAAU;AAC5F,aAAO,UAAU,CAAC,MAAX,MAAuB,gBAAgB,YAAY,QAA5B,GAAuC,gBAAvC,GAA2D,gBAAwB,CAAC,WAA3G,CAAP;AACH,KAFoC,CAArC;AAGA,QAAI,CAAC,4BAAL,EACI,MAAM,IAAI,6BAAJ,CAAkC,gBAAlC,CAAN;AAEJ,WAAO,4BAA4B,CAAC,MAApC;AACH,GARO;;AAUZ,SAAA,kBAAA;AAAC,CA9FD,EAAA","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityManager} from \"../entity-manager/EntityManager\";\nimport {Repository} from \"./Repository\";\nimport {TreeRepository} from \"./TreeRepository\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {CustomRepositoryDoesNotHaveEntityError} from \"../error/CustomRepositoryDoesNotHaveEntityError\";\nimport {getMetadataArgsStorage} from \"../index\";\nimport {CustomRepositoryNotFoundError} from \"../error/CustomRepositoryNotFoundError\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\n\n/**\n * Provides abstract class for custom repositories that do not inherit from original orm Repository.\n * Contains all most-necessary methods to simplify code in the custom repository.\n * All methods are protected thus not exposed and it allows to create encapsulated custom repository.\n *\n * @experimental\n */\nexport class AbstractRepository<Entity extends ObjectLiteral> {\n\n    // -------------------------------------------------------------------------\n    // Protected Methods Set Dynamically\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets entity manager that allows to perform repository operations with any entity.\n     */\n    protected manager: EntityManager;\n\n    // -------------------------------------------------------------------------\n    // Protected Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the original ORM repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    protected get repository(): Repository<Entity> {\n        const target = this.getCustomRepositoryTarget(this as any);\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n\n        return this.manager.getRepository<Entity>(target);\n    }\n\n    /**\n     * Gets the original ORM tree repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    protected get treeRepository(): TreeRepository<Entity> {\n        const target = this.getCustomRepositoryTarget(this as any);\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n\n        return this.manager.getTreeRepository<Entity>(target);\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new query builder for the repository's entity that can be used to build a sql query.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    protected createQueryBuilder(alias: string): SelectQueryBuilder<Entity> {\n        const target = this.getCustomRepositoryTarget(this.constructor);\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n\n        return this.manager.getRepository<Entity>(target).createQueryBuilder(alias);\n    }\n\n    /**\n     * Creates a new query builder for the given entity that can be used to build a sql query.\n     */\n    protected createQueryBuilderFor<T>(entity: ObjectType<T>, alias: string): SelectQueryBuilder<T> {\n        return this.getRepositoryFor(entity).createQueryBuilder(alias);\n    }\n\n    /**\n     * Gets the original ORM repository for the given entity class.\n     */\n    protected getRepositoryFor<T>(entity: ObjectType<T>): Repository<T> {\n        return this.manager.getRepository(entity);\n    }\n\n    /**\n     * Gets the original ORM tree repository for the given entity class.\n     */\n    protected getTreeRepositoryFor<T>(entity: ObjectType<T>): TreeRepository<T> {\n        return this.manager.getTreeRepository(entity);\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets custom repository's managed entity.\n     * If given custom repository does not manage any entity then undefined will be returned.\n     */\n    private getCustomRepositoryTarget(customRepository: any): EntityTarget<any>|undefined {\n        const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n            return repository.target === (customRepository instanceof Function ? customRepository : (customRepository as any).constructor);\n        });\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository);\n\n        return entityRepositoryMetadataArgs.entity;\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}