{"ast":null,"code":"import { __assign, __read } from \"tslib\";\nimport { Alias } from \"./Alias\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\n\nvar QueryExpressionMap =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function QueryExpressionMap(connection) {\n    this.connection = connection; // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n\n    this.queryEntity = false;\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n\n    this.aliases = [];\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n\n    this.queryType = \"select\";\n    /**\n     * Data needs to be SELECT-ed.\n     */\n\n    this.selects = [];\n    /**\n     * Max execution time in millisecond.\n     */\n\n    this.maxExecutionTime = 0;\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n\n    this.selectDistinct = false;\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n\n    this.selectDistinctOn = [];\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n\n    this.extraReturningColumns = [];\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n\n    this.onConflict = \"\";\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n\n    this.onIgnore = false;\n    /**\n     * JOIN queries.\n     */\n\n    this.joinAttributes = [];\n    /**\n     * RelationId queries.\n     */\n\n    this.relationIdAttributes = [];\n    /**\n     * Relation count queries.\n     */\n\n    this.relationCountAttributes = [];\n    /**\n     * WHERE queries.\n     */\n\n    this.wheres = [];\n    /**\n     * HAVING queries.\n     */\n\n    this.havings = [];\n    /**\n     * ORDER BY queries.\n     */\n\n    this.orderBys = {};\n    /**\n     * GROUP BY queries.\n     */\n\n    this.groupBys = [];\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n\n    this.withDeleted = false;\n    /**\n     * Parameters used to be escaped in final query.\n     */\n\n    this.parameters = {};\n    /**\n     * Indicates if alias, table names and column names will be ecaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n\n    this.disableEscaping = true;\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n\n    this.enableRelationIdValues = false;\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n\n    this.extraAppendedAndWhereCondition = \"\";\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n\n    this.subQuery = false;\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n\n    this.aliasNamePrefixingEnabled = true;\n    /**\n     * Indicates if query result cache is enabled or not.\n     */\n\n    this.cache = false;\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n\n    this.options = [];\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n\n    this.insertColumns = [];\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n\n    this.whereEntities = [];\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n\n    this.updateEntity = true;\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n\n    this.callListeners = true;\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n\n    this.useTransaction = false;\n    /**\n     * Extra parameters.\n     * Used in InsertQueryBuilder to avoid default parameters mechanizm and execute high performance insertions.\n     */\n\n    this.nativeParameters = {};\n  }\n\n  Object.defineProperty(QueryExpressionMap.prototype, \"allOrderBys\", {\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Get all ORDER BY queries - if order by is specified by user then it uses them,\n     * otherwise it uses default entity order by if it was set.\n     */\n    get: function () {\n      var _this = this;\n\n      if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata && this.options.indexOf(\"disable-global-order\") === -1) {\n        var entityOrderBy_1 = this.mainAlias.metadata.orderBy || {};\n        return Object.keys(entityOrderBy_1).reduce(function (orderBy, key) {\n          orderBy[_this.mainAlias.name + \".\" + key] = entityOrderBy_1[key];\n          return orderBy;\n        }, {});\n      }\n\n      return this.orderBys;\n    },\n    enumerable: false,\n    configurable: true\n  }); // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a main alias and adds it to the current expression map.\n   */\n\n  QueryExpressionMap.prototype.setMainAlias = function (alias) {\n    // if main alias is already set then remove it from the array\n    // if (this.mainAlias)\n    //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n    // set new main alias\n    this.mainAlias = alias;\n    return alias;\n  };\n  /**\n   * Creates a new alias and adds it to the current expression map.\n   */\n\n\n  QueryExpressionMap.prototype.createAlias = function (options) {\n    var aliasName = options.name;\n    if (!aliasName && options.tablePath) aliasName = options.tablePath;\n    if (!aliasName && options.target instanceof Function) aliasName = options.target.name;\n    if (!aliasName && typeof options.target === \"string\") aliasName = options.target;\n    var alias = new Alias();\n    alias.type = options.type;\n    if (aliasName) alias.name = aliasName;\n    if (options.metadata) alias.metadata = options.metadata;\n    if (options.target && !alias.hasMetadata) alias.metadata = this.connection.getMetadata(options.target);\n    if (options.tablePath) alias.tablePath = options.tablePath;\n    if (options.subQuery) alias.subQuery = options.subQuery;\n    this.aliases.push(alias);\n    return alias;\n  };\n  /**\n   * Finds alias with the given name.\n   * If alias was not found it throw an exception.\n   */\n\n\n  QueryExpressionMap.prototype.findAliasByName = function (aliasName) {\n    var alias = this.aliases.find(function (alias) {\n      return alias.name === aliasName;\n    });\n    if (!alias) throw new Error(\"\\\"\" + aliasName + \"\\\" alias was not found. Maybe you forgot to join it?\");\n    return alias;\n  };\n\n  QueryExpressionMap.prototype.findColumnByAliasExpression = function (aliasExpression) {\n    var _a = __read(aliasExpression.split(\".\"), 2),\n        aliasName = _a[0],\n        propertyPath = _a[1];\n\n    var alias = this.findAliasByName(aliasName);\n    return alias.metadata.findColumnWithPropertyName(propertyPath);\n  };\n\n  Object.defineProperty(QueryExpressionMap.prototype, \"relationMetadata\", {\n    /**\n     * Gets relation metadata of the relation this query builder works with.\n     *\n     * todo: add proper exceptions\n     */\n    get: function () {\n      if (!this.mainAlias) throw new Error(\"Entity to work with is not specified!\"); // todo: better message\n\n      var relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n      if (!relationMetadata) throw new Error(\"Relation \" + this.relationPropertyPath + \" was not found in entity \" + this.mainAlias.name); // todo: better message\n\n      return relationMetadata;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Copies all properties of the current QueryExpressionMap into a new one.\n   * Useful when QueryBuilder needs to create a copy of itself.\n   */\n\n  QueryExpressionMap.prototype.clone = function () {\n    var _this = this;\n\n    var map = new QueryExpressionMap(this.connection);\n    map.queryType = this.queryType;\n    map.selects = this.selects.map(function (select) {\n      return select;\n    });\n    map.maxExecutionTime = this.maxExecutionTime;\n    map.selectDistinct = this.selectDistinct;\n    map.selectDistinctOn = this.selectDistinctOn;\n    this.aliases.forEach(function (alias) {\n      return map.aliases.push(new Alias(alias));\n    });\n    map.mainAlias = this.mainAlias;\n    map.valuesSet = this.valuesSet;\n    map.returning = this.returning;\n    map.onConflict = this.onConflict;\n    map.onIgnore = this.onIgnore;\n    map.onUpdate = this.onUpdate;\n    map.joinAttributes = this.joinAttributes.map(function (join) {\n      return new JoinAttribute(_this.connection, _this, join);\n    });\n    map.relationIdAttributes = this.relationIdAttributes.map(function (relationId) {\n      return new RelationIdAttribute(_this, relationId);\n    });\n    map.relationCountAttributes = this.relationCountAttributes.map(function (relationCount) {\n      return new RelationCountAttribute(_this, relationCount);\n    });\n    map.wheres = this.wheres.map(function (where) {\n      return __assign({}, where);\n    });\n    map.havings = this.havings.map(function (having) {\n      return __assign({}, having);\n    });\n    map.orderBys = Object.assign({}, this.orderBys);\n    map.groupBys = this.groupBys.map(function (groupBy) {\n      return groupBy;\n    });\n    map.limit = this.limit;\n    map.offset = this.offset;\n    map.skip = this.skip;\n    map.take = this.take;\n    map.lockMode = this.lockMode;\n    map.lockVersion = this.lockVersion;\n    map.lockTables = this.lockTables;\n    map.withDeleted = this.withDeleted;\n    map.parameters = Object.assign({}, this.parameters);\n    map.disableEscaping = this.disableEscaping;\n    map.enableRelationIdValues = this.enableRelationIdValues;\n    map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;\n    map.subQuery = this.subQuery;\n    map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;\n    map.cache = this.cache;\n    map.cacheId = this.cacheId;\n    map.cacheDuration = this.cacheDuration;\n    map.relationPropertyPath = this.relationPropertyPath;\n    map.of = this.of;\n    map.insertColumns = this.insertColumns;\n    map.whereEntities = this.whereEntities;\n    map.updateEntity = this.updateEntity;\n    map.callListeners = this.callListeners;\n    map.useTransaction = this.useTransaction;\n    map.nativeParameters = Object.assign({}, this.nativeParameters);\n    map.comment = this.comment;\n    return map;\n  };\n\n  return QueryExpressionMap;\n}();\n\nexport { QueryExpressionMap };","map":{"version":3,"sources":["../browser/src/query-builder/QueryExpressionMap.ts"],"names":[],"mappings":"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","sourcesContent":["import {Alias} from \"./Alias\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {JoinAttribute} from \"./JoinAttribute\";\nimport {RelationIdAttribute} from \"./relation-id/RelationIdAttribute\";\nimport {RelationCountAttribute} from \"./relation-count/RelationCountAttribute\";\nimport {Connection} from \"../connection/Connection\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {SelectQuery} from \"./SelectQuery\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {QueryBuilder} from \"./QueryBuilder\";\nimport {SelectQueryBuilderOption} from \"./SelectQueryBuilderOption\";\n\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\nexport class QueryExpressionMap {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n    queryEntity: boolean = false;\n\n    /**\n     * Main alias is a main selection object selected by QueryBuilder.\n     */\n    mainAlias?: Alias;\n\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n    aliases: Alias[] = [];\n\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n    queryType: \"select\"|\"update\"|\"delete\"|\"insert\"|\"relation\"|\"soft-delete\"|\"restore\" = \"select\";\n\n    /**\n     * Data needs to be SELECT-ed.\n     */\n    selects: SelectQuery[] = [];\n\n    /**\n     * Max execution time in millisecond.\n     */\n    maxExecutionTime: number = 0;\n\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n    selectDistinct: boolean = false;\n\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n    selectDistinctOn: string[] = [];\n\n    /**\n     * FROM-s to be selected.\n     */\n    // froms: { target: string, alias: string }[] = [];\n\n    /**\n     * If update query was used, it needs \"update set\" - properties which will be updated by this query.\n     * If insert query was used, it needs \"insert set\" - values that needs to be inserted.\n     */\n    valuesSet?: ObjectLiteral|ObjectLiteral[];\n\n    /**\n     * Optional returning (or output) clause for insert, update or delete queries.\n     */\n    returning: string|string[];\n\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n    extraReturningColumns: ColumnMetadata[] = [];\n\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n    onConflict: string = \"\";\n\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n    onIgnore: string|boolean = false;\n\n    /**\n     * Optional on update statement used in insertion query in databases.\n     */\n    onUpdate: { columns?: string, conflict?: string, overwrite?: string };\n\n    /**\n     * JOIN queries.\n     */\n    joinAttributes: JoinAttribute[] = [];\n\n    /**\n     * RelationId queries.\n     */\n    relationIdAttributes: RelationIdAttribute[] = [];\n\n    /**\n     * Relation count queries.\n     */\n    relationCountAttributes: RelationCountAttribute[] = [];\n\n    /**\n     * WHERE queries.\n     */\n    wheres: { type: \"simple\"|\"and\"|\"or\", condition: string }[] = [];\n\n    /**\n     * HAVING queries.\n     */\n    havings: { type: \"simple\"|\"and\"|\"or\", condition: string }[] = [];\n\n    /**\n     * ORDER BY queries.\n     */\n    orderBys: OrderByCondition = {};\n\n    /**\n     * GROUP BY queries.\n     */\n    groupBys: string[] = [];\n\n    /**\n     * LIMIT query.\n     */\n    limit?: number;\n\n    /**\n     * OFFSET query.\n     */\n    offset?: number;\n\n    /**\n     * Number of rows to skip of result using pagination.\n     */\n    skip?: number;\n\n    /**\n     * Number of rows to take using pagination.\n     */\n    take?: number;\n\n    /**\n     * Locking mode.\n     */\n    lockMode?: \"optimistic\"|\"pessimistic_read\"|\"pessimistic_write\"|\"dirty_read\"|\"pessimistic_partial_write\"|\"pessimistic_write_or_fail\"|\"for_no_key_update\";\n\n    /**\n     * Current version of the entity, used for locking.\n     */\n    lockVersion?: number|Date;\n\n    /**\n     * Tables to be specified in the \"FOR UPDATE OF\" clause, referred by their alias\n     */\n    lockTables?: string[];\n\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n    withDeleted: boolean = false;\n\n    /**\n     * Parameters used to be escaped in final query.\n     */\n    parameters: ObjectLiteral = {};\n\n    /**\n     * Indicates if alias, table names and column names will be ecaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n    disableEscaping: boolean = true;\n\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n    enableRelationIdValues: boolean = false;\n\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n    extraAppendedAndWhereCondition: string = \"\";\n\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n    subQuery: boolean = false;\n\n    /**\n     * If QueryBuilder was created in a subquery mode then its parent QueryBuilder (who created subquery) will be stored here.\n     */\n    parentQueryBuilder: QueryBuilder<any>;\n\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n    aliasNamePrefixingEnabled: boolean = true;\n\n    /**\n     * Indicates if query result cache is enabled or not.\n     */\n    cache: boolean = false;\n\n    /**\n     * Time in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cacheDuration: number;\n\n    /**\n     * Cache id.\n     * Used to identifier your cache queries.\n     */\n    cacheId: string;\n\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n    options: SelectQueryBuilderOption[] = [];\n\n    /**\n     * Property path of relation to work with.\n     * Used in relational query builder.\n     */\n    relationPropertyPath: string;\n\n    /**\n     * Entity (target) which relations will be updated.\n     */\n    of: any|any[];\n\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n    insertColumns: string[] = [];\n\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n    whereEntities: ObjectLiteral[] = [];\n\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n    updateEntity: boolean = true;\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n    callListeners: boolean = true;\n\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n    useTransaction: boolean = false;\n\n    /**\n     * Extra parameters.\n     * Used in InsertQueryBuilder to avoid default parameters mechanizm and execute high performance insertions.\n     */\n    nativeParameters: ObjectLiteral = {};\n\n    /**\n     * Query Comment to include extra information for debugging or other purposes.\n     */\n    comment?: string;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Get all ORDER BY queries - if order by is specified by user then it uses them,\n     * otherwise it uses default entity order by if it was set.\n     */\n    get allOrderBys() {\n        if (!Object.keys(this.orderBys).length && this.mainAlias!.hasMetadata && this.options.indexOf(\"disable-global-order\") === -1) {\n            const entityOrderBy = this.mainAlias!.metadata.orderBy || {};\n            return Object.keys(entityOrderBy).reduce((orderBy, key) => {\n                orderBy[this.mainAlias!.name + \".\" + key] = entityOrderBy[key];\n                return orderBy;\n            }, {} as OrderByCondition);\n        }\n\n        return this.orderBys;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a main alias and adds it to the current expression map.\n     */\n    setMainAlias(alias: Alias): Alias {\n\n        // if main alias is already set then remove it from the array\n        // if (this.mainAlias)\n        //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n\n        // set new main alias\n        this.mainAlias = alias;\n\n        return alias;\n    }\n\n    /**\n     * Creates a new alias and adds it to the current expression map.\n     */\n    createAlias(options: { type: \"from\"|\"select\"|\"join\"|\"other\", name?: string, target?: Function|string, tablePath?: string, subQuery?: string, metadata?: EntityMetadata }): Alias {\n\n        let aliasName = options.name;\n        if (!aliasName && options.tablePath)\n            aliasName = options.tablePath;\n        if (!aliasName && options.target instanceof Function)\n            aliasName = options.target.name;\n        if (!aliasName && typeof options.target === \"string\")\n            aliasName = options.target;\n\n        const alias = new Alias();\n        alias.type = options.type;\n        if (aliasName)\n            alias.name = aliasName;\n        if (options.metadata)\n            alias.metadata = options.metadata;\n        if (options.target && !alias.hasMetadata)\n            alias.metadata = this.connection.getMetadata(options.target);\n        if (options.tablePath)\n            alias.tablePath = options.tablePath;\n        if (options.subQuery)\n            alias.subQuery = options.subQuery;\n\n        this.aliases.push(alias);\n        return alias;\n    }\n\n    /**\n     * Finds alias with the given name.\n     * If alias was not found it throw an exception.\n     */\n    findAliasByName(aliasName: string): Alias {\n        const alias = this.aliases.find(alias => alias.name === aliasName);\n        if (!alias)\n            throw new Error(`\"${aliasName}\" alias was not found. Maybe you forgot to join it?`);\n\n        return alias;\n    }\n\n    findColumnByAliasExpression(aliasExpression: string): ColumnMetadata|undefined {\n        const [aliasName, propertyPath] = aliasExpression.split(\".\");\n        const alias = this.findAliasByName(aliasName);\n        return alias.metadata.findColumnWithPropertyName(propertyPath);\n    }\n\n    /**\n     * Gets relation metadata of the relation this query builder works with.\n     *\n     * todo: add proper exceptions\n     */\n    get relationMetadata(): RelationMetadata {\n        if (!this.mainAlias)\n            throw new Error(`Entity to work with is not specified!`); // todo: better message\n\n        const relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n        if (!relationMetadata)\n            throw new Error(`Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`); // todo: better message\n\n        return relationMetadata;\n    }\n\n    /**\n     * Copies all properties of the current QueryExpressionMap into a new one.\n     * Useful when QueryBuilder needs to create a copy of itself.\n     */\n    clone(): QueryExpressionMap {\n        const map = new QueryExpressionMap(this.connection);\n        map.queryType = this.queryType;\n        map.selects = this.selects.map(select => select);\n        map.maxExecutionTime = this.maxExecutionTime;\n        map.selectDistinct = this.selectDistinct;\n        map.selectDistinctOn = this.selectDistinctOn;\n        this.aliases.forEach(alias => map.aliases.push(new Alias(alias)));\n        map.mainAlias = this.mainAlias;\n        map.valuesSet = this.valuesSet;\n        map.returning = this.returning;\n        map.onConflict = this.onConflict;\n        map.onIgnore = this.onIgnore;\n        map.onUpdate = this.onUpdate;\n        map.joinAttributes = this.joinAttributes.map(join => new JoinAttribute(this.connection, this, join));\n        map.relationIdAttributes = this.relationIdAttributes.map(relationId => new RelationIdAttribute(this, relationId));\n        map.relationCountAttributes = this.relationCountAttributes.map(relationCount => new RelationCountAttribute(this, relationCount));\n        map.wheres = this.wheres.map(where => ({ ...where }));\n        map.havings = this.havings.map(having => ({ ...having }));\n        map.orderBys = Object.assign({}, this.orderBys);\n        map.groupBys = this.groupBys.map(groupBy => groupBy);\n        map.limit = this.limit;\n        map.offset = this.offset;\n        map.skip = this.skip;\n        map.take = this.take;\n        map.lockMode = this.lockMode;\n        map.lockVersion = this.lockVersion;\n        map.lockTables = this.lockTables;\n        map.withDeleted = this.withDeleted;\n        map.parameters = Object.assign({}, this.parameters);\n        map.disableEscaping = this.disableEscaping;\n        map.enableRelationIdValues = this.enableRelationIdValues;\n        map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;\n        map.subQuery = this.subQuery;\n        map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;\n        map.cache = this.cache;\n        map.cacheId = this.cacheId;\n        map.cacheDuration = this.cacheDuration;\n        map.relationPropertyPath = this.relationPropertyPath;\n        map.of = this.of;\n        map.insertColumns = this.insertColumns;\n        map.whereEntities = this.whereEntities;\n        map.updateEntity = this.updateEntity;\n        map.callListeners = this.callListeners;\n        map.useTransaction = this.useTransaction;\n        map.nativeParameters = Object.assign({}, this.nativeParameters);\n        map.comment = this.comment;\n        return map;\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}