{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\n\nvar RelationLoader =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationLoader(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads relation data for the given entity and its relation.\n   */\n\n\n  RelationLoader.prototype.load = function (relation, entityOrEntities, queryRunner) {\n    if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed\n\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner);\n    } else if (relation.isManyToManyOwner) {\n      return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner);\n    } else {\n      // many-to-many non owner\n      return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner);\n    }\n  };\n  /**\n   * Loads data for many-to-one and one-to-one owner relations.\n   *\n   * (ow) post.category<=>category.post\n   * loaded: category from post\n   * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n   *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n   */\n\n\n  RelationLoader.prototype.loadManyToOneOrOneToOneOwner = function (relation, entityOrEntities, queryRunner) {\n    var entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    var columns = relation.entityMetadata.primaryColumns;\n    var joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n    var conditions = joinColumns.map(function (joinColumn) {\n      return relation.entityMetadata.name + \".\" + joinColumn.propertyName + \" = \" + relation.propertyName + \".\" + joinColumn.referencedColumn.propertyName;\n    }).join(\" AND \");\n    var joinAliasName = relation.entityMetadata.name;\n    var qb = this.connection.createQueryBuilder(queryRunner).select(relation.propertyName) // category\n    .from(relation.type, relation.propertyName) // Category, category\n    .innerJoin(relation.entityMetadata.target, joinAliasName, conditions);\n\n    if (columns.length === 1) {\n      qb.where(joinAliasName + \".\" + columns[0].propertyPath + \" IN (:...\" + (joinAliasName + \"_\" + columns[0].propertyName) + \")\");\n      qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, entities.map(function (entity) {\n        return columns[0].getEntityValue(entity);\n      }));\n    } else {\n      var condition = entities.map(function (entity, entityIndex) {\n        return columns.map(function (column, columnIndex) {\n          var paramName = joinAliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity));\n          return joinAliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(function (condition) {\n        return \"(\" + condition + \")\";\n      }).join(\" OR \");\n      qb.where(condition);\n    }\n\n    return qb.getMany(); // return qb.getOne(); todo: fix all usages\n  };\n  /**\n   * Loads data for one-to-many and one-to-one not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n   */\n\n\n  RelationLoader.prototype.loadOneToManyOrOneToOneNotOwner = function (relation, entityOrEntities, queryRunner) {\n    var entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    var aliasName = relation.propertyName;\n    var columns = relation.inverseRelation.joinColumns;\n    var qb = this.connection.createQueryBuilder(queryRunner).select(aliasName).from(relation.inverseRelation.entityMetadata.target, aliasName);\n\n    if (columns.length === 1) {\n      qb.where(aliasName + \".\" + columns[0].propertyPath + \" IN (:...\" + (aliasName + \"_\" + columns[0].propertyName) + \")\");\n      qb.setParameter(aliasName + \"_\" + columns[0].propertyName, entities.map(function (entity) {\n        return columns[0].referencedColumn.getEntityValue(entity);\n      }));\n    } else {\n      var condition = entities.map(function (entity, entityIndex) {\n        return columns.map(function (column, columnIndex) {\n          var paramName = aliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n          return aliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(function (condition) {\n        return \"(\" + condition + \")\";\n      }).join(\" OR \");\n      qb.where(condition);\n    }\n\n    return qb.getMany(); // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n  };\n  /**\n   * Loads data for many-to-many owner relations.\n   *\n   * SELECT category\n   * FROM category category\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = :postId\n   * AND post_categories.categoryId = category.id\n   */\n\n\n  RelationLoader.prototype.loadManyToManyOwner = function (relation, entityOrEntities, queryRunner) {\n    var entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    var mainAlias = relation.propertyName;\n    var joinAlias = relation.junctionEntityMetadata.tableName;\n    var joinColumnConditions = relation.joinColumns.map(function (joinColumn) {\n      return joinAlias + \".\" + joinColumn.propertyName + \" IN (:...\" + joinColumn.propertyName + \")\";\n    });\n    var inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {\n      return joinAlias + \".\" + inverseJoinColumn.propertyName + \"=\" + mainAlias + \".\" + inverseJoinColumn.referencedColumn.propertyName;\n    });\n    var parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {\n      parameters[joinColumn.propertyName] = entities.map(function (entity) {\n        return joinColumn.referencedColumn.getEntityValue(entity);\n      });\n      return parameters;\n    }, {});\n    return this.connection.createQueryBuilder(queryRunner).select(mainAlias).from(relation.type, mainAlias).innerJoin(joinAlias, joinAlias, __spreadArray(__spreadArray([], __read(joinColumnConditions)), __read(inverseJoinColumnConditions)).join(\" AND \")).setParameters(parameters).getMany();\n  };\n  /**\n   * Loads data for many-to-many not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = post.id\n   * AND post_categories.categoryId = post_categories.categoryId\n   */\n\n\n  RelationLoader.prototype.loadManyToManyNotOwner = function (relation, entityOrEntities, queryRunner) {\n    var entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    var mainAlias = relation.propertyName;\n    var joinAlias = relation.junctionEntityMetadata.tableName;\n    var joinColumnConditions = relation.inverseRelation.joinColumns.map(function (joinColumn) {\n      return joinAlias + \".\" + joinColumn.propertyName + \" = \" + mainAlias + \".\" + joinColumn.referencedColumn.propertyName;\n    });\n    var inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map(function (inverseJoinColumn) {\n      return joinAlias + \".\" + inverseJoinColumn.propertyName + \" IN (:...\" + inverseJoinColumn.propertyName + \")\";\n    });\n    var parameters = relation.inverseRelation.inverseJoinColumns.reduce(function (parameters, joinColumn) {\n      parameters[joinColumn.propertyName] = entities.map(function (entity) {\n        return joinColumn.referencedColumn.getEntityValue(entity);\n      });\n      return parameters;\n    }, {});\n    return this.connection.createQueryBuilder(queryRunner).select(mainAlias).from(relation.type, mainAlias).innerJoin(joinAlias, joinAlias, __spreadArray(__spreadArray([], __read(joinColumnConditions)), __read(inverseJoinColumnConditions)).join(\" AND \")).setParameters(parameters).getMany();\n  };\n  /**\n   * Wraps given entity and creates getters/setters for its given relation\n   * to be able to lazily load data when accessing this relation.\n   */\n\n\n  RelationLoader.prototype.enableLazyLoad = function (relation, entity, queryRunner) {\n    var relationLoader = this;\n    var dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n\n    var promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n\n    var resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n    var setData = function (entity, value) {\n      entity[dataIndex] = value;\n      entity[resolveIndex] = true;\n      delete entity[promiseIndex];\n      return value;\n    };\n\n    var setPromise = function (entity, value) {\n      delete entity[resolveIndex];\n      delete entity[dataIndex];\n      entity[promiseIndex] = value;\n      value.then( // ensure different value is not assigned yet\n      function (result) {\n        return entity[promiseIndex] === value ? setData(entity, result) : result;\n      });\n      return value;\n    };\n\n    Object.defineProperty(entity, relation.propertyName, {\n      get: function () {\n        if (this[resolveIndex] === true || this[dataIndex] !== undefined) // if related data already was loaded then simply return it\n          return Promise.resolve(this[dataIndex]);\n        if (this[promiseIndex]) // if related data is loading then return a promise relationLoader loads it\n          return this[promiseIndex]; // nothing is loaded yet, load relation data and save it in the model once they are loaded\n\n        var loader = relationLoader.load(relation, this, queryRunner).then(function (result) {\n          return relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result;\n        });\n        return setPromise(this, loader);\n      },\n      set: function (value) {\n        if (value instanceof Promise) {\n          // if set data is a promise then wait for its resolve and save in the object\n          setPromise(this, value);\n        } else {\n          // if its direct data set (non promise, probably not safe-typed)\n          setData(this, value);\n        }\n      },\n      configurable: true\n    });\n  };\n\n  return RelationLoader;\n}();\n\nexport { RelationLoader };","map":{"version":3,"sources":["../browser/src/query-builder/RelationLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import {Connection, ObjectLiteral, QueryRunner} from \"../\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\n\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation data for the given entity and its relation.\n     */\n    load(relation: RelationMetadata, entityOrEntities: ObjectLiteral|ObjectLiteral[], queryRunner?: QueryRunner): Promise<any[]> { // todo: check all places where it uses non array\n        if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner);\n\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner);\n\n        } else if (relation.isManyToManyOwner) {\n            return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner);\n\n        } else { // many-to-many non owner\n            return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner);\n        }\n    }\n\n    /**\n     * Loads data for many-to-one and one-to-one owner relations.\n     *\n     * (ow) post.category<=>category.post\n     * loaded: category from post\n     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n     */\n    loadManyToOneOrOneToOneOwner(relation: RelationMetadata, entityOrEntities: ObjectLiteral|ObjectLiteral[], queryRunner?: QueryRunner): Promise<any> {\n        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n        const columns = relation.entityMetadata.primaryColumns;\n        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation!.joinColumns;\n        const conditions = joinColumns.map(joinColumn => {\n            return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${relation.propertyName}.${joinColumn.referencedColumn!.propertyName}`;\n        }).join(\" AND \");\n\n        const joinAliasName = relation.entityMetadata.name;\n        const qb = this.connection\n            .createQueryBuilder(queryRunner)\n            .select(relation.propertyName) // category\n            .from(relation.type, relation.propertyName) // Category, category\n            .innerJoin(relation.entityMetadata.target as Function, joinAliasName, conditions);\n\n        if (columns.length === 1) {\n            qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + \"_\" + columns[0].propertyName})`);\n            qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].getEntityValue(entity)));\n\n        } else {\n            const condition = entities.map((entity, entityIndex) => {\n                return columns.map((column, columnIndex) => {\n                    const paramName = joinAliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n                    qb.setParameter(paramName, column.getEntityValue(entity));\n                    return joinAliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n                }).join(\" AND \");\n            }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n            qb.where(condition);\n        }\n\n        return qb.getMany();\n        // return qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for one-to-many and one-to-one not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n     */\n    loadOneToManyOrOneToOneNotOwner(relation: RelationMetadata, entityOrEntities: ObjectLiteral|ObjectLiteral[], queryRunner?: QueryRunner): Promise<any> {\n        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n        const aliasName = relation.propertyName;\n        const columns = relation.inverseRelation!.joinColumns;\n        const qb = this.connection\n            .createQueryBuilder(queryRunner)\n            .select(aliasName)\n            .from(relation.inverseRelation!.entityMetadata.target, aliasName);\n\n        if (columns.length === 1) {\n            qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + \"_\" + columns[0].propertyName})`);\n            qb.setParameter(aliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].referencedColumn!.getEntityValue(entity)));\n\n        } else {\n            const condition = entities.map((entity, entityIndex) => {\n                return columns.map((column, columnIndex) => {\n                    const paramName = aliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n                    qb.setParameter(paramName, column.referencedColumn!.getEntityValue(entity));\n                    return aliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n                }).join(\" AND \");\n            }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n            qb.where(condition);\n        }\n        return qb.getMany();\n        // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for many-to-many owner relations.\n     *\n     * SELECT category\n     * FROM category category\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = :postId\n     * AND post_categories.categoryId = category.id\n     */\n    loadManyToManyOwner(relation: RelationMetadata, entityOrEntities: ObjectLiteral|ObjectLiteral[], queryRunner?: QueryRunner): Promise<any> {\n        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n        const mainAlias = relation.propertyName;\n        const joinAlias = relation.junctionEntityMetadata!.tableName;\n        const joinColumnConditions = relation.joinColumns.map(joinColumn => {\n            return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;\n        });\n        const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\n            return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn!.propertyName}`;\n        });\n        const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n            parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn!.getEntityValue(entity));\n            return parameters;\n        }, {} as ObjectLiteral);\n\n        return this.connection\n            .createQueryBuilder(queryRunner)\n            .select(mainAlias)\n            .from(relation.type, mainAlias)\n            .innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \"))\n            .setParameters(parameters)\n            .getMany();\n    }\n\n    /**\n     * Loads data for many-to-many not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = post.id\n     * AND post_categories.categoryId = post_categories.categoryId\n     */\n    loadManyToManyNotOwner(relation: RelationMetadata, entityOrEntities: ObjectLiteral|ObjectLiteral[], queryRunner?: QueryRunner): Promise<any> {\n        const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n        const mainAlias = relation.propertyName;\n        const joinAlias = relation.junctionEntityMetadata!.tableName;\n        const joinColumnConditions = relation.inverseRelation!.joinColumns.map(joinColumn => {\n            return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`;\n        });\n        const inverseJoinColumnConditions = relation.inverseRelation!.inverseJoinColumns.map(inverseJoinColumn => {\n            return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;\n        });\n        const parameters = relation.inverseRelation!.inverseJoinColumns.reduce((parameters, joinColumn) => {\n            parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn!.getEntityValue(entity));\n            return parameters;\n        }, {} as ObjectLiteral);\n\n        return this.connection\n            .createQueryBuilder(queryRunner)\n            .select(mainAlias)\n            .from(relation.type, mainAlias)\n            .innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \"))\n            .setParameters(parameters)\n            .getMany();\n    }\n\n    /**\n     * Wraps given entity and creates getters/setters for its given relation\n     * to be able to lazily load data when accessing this relation.\n     */\n    enableLazyLoad(relation: RelationMetadata, entity: ObjectLiteral, queryRunner?: QueryRunner) {\n        const relationLoader = this;\n        const dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n        const promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n        const resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n        const setData = (entity: ObjectLiteral, value: any) => {\n            entity[dataIndex] = value;\n            entity[resolveIndex] = true;\n            delete entity[promiseIndex];\n            return value;\n        };\n        const setPromise = (entity: ObjectLiteral, value: Promise<any>) => {\n            delete entity[resolveIndex];\n            delete entity[dataIndex];\n            entity[promiseIndex] = value;\n            value.then(\n              // ensure different value is not assigned yet\n              result => entity[promiseIndex] === value ? setData(entity, result) : result\n            );\n            return value;\n        };\n\n        Object.defineProperty(entity, relation.propertyName, {\n            get: function() {\n                if (this[resolveIndex] === true || this[dataIndex] !== undefined) // if related data already was loaded then simply return it\n                    return Promise.resolve(this[dataIndex]);\n\n                if (this[promiseIndex]) // if related data is loading then return a promise relationLoader loads it\n                    return this[promiseIndex];\n\n                // nothing is loaded yet, load relation data and save it in the model once they are loaded\n                const loader = relationLoader.load(relation, this, queryRunner).then(\n                    result => relation.isOneToOne || relation.isManyToOne ? (result.length === 0 ? null : result[0]) : result\n                );\n                return setPromise(this, loader);\n            },\n            set: function(value: any|Promise<any>) {\n                if (value instanceof Promise) { // if set data is a promise then wait for its resolve and save in the object\n                    setPromise(this, value);\n                } else { // if its direct data set (non promise, probably not safe-typed)\n                    setData(this, value);\n                }\n            },\n            configurable: true\n        });\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}