{"ast":null,"code":"import { __awaiter, __generator, __read, __values } from \"tslib\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\";\n\nvar NestedSetIds =\n/** @class */\nfunction () {\n  function NestedSetIds() {}\n\n  return NestedSetIds;\n}();\n/**\n * Executes subject operations for nested set tree entities.\n */\n\n\nvar NestedSetSubjectExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function NestedSetSubjectExecutor(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes operations when subject is being inserted.\n   */\n\n\n  NestedSetSubjectExecutor.prototype.insert = function (subject) {\n    return __awaiter(this, void 0, void 0, function () {\n      var escape, tableName, leftColumnName, rightColumnName, parent, parentId, parentNsRight, isUniqueRoot;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            escape = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            tableName = this.getTableName(subject.metadata.tablePath);\n            leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n            rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n            parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);\n            if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n              parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n            parentId = subject.metadata.getEntityIdMap(parent);\n            parentNsRight = undefined;\n            if (!parentId) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn.propertyPath, \"right\").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then(function (result) {\n              var value = result ? result[\"right\"] : undefined; // CockroachDB returns numeric types as string\n\n              return typeof value === \"string\" ? parseInt(value) : value;\n            })];\n\n          case 1:\n            parentNsRight = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (!(parentNsRight !== undefined)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"UPDATE \" + tableName + \" SET \" + (leftColumnName + \" = CASE WHEN \" + leftColumnName + \" > \" + parentNsRight + \" THEN \" + leftColumnName + \" + 2 ELSE \" + leftColumnName + \" END,\") + (rightColumnName + \" = \" + rightColumnName + \" + 2 \") + (\"WHERE \" + rightColumnName + \" >= \" + parentNsRight))];\n\n          case 3:\n            _a.sent();\n\n            OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            return [4\n            /*yield*/\n            , this.isUniqueRootEntity(subject, parent)];\n\n          case 5:\n            isUniqueRoot = _a.sent(); // Validate if a root entity already exits and throw an exception\n\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n            OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes operations when subject is being updated.\n   */\n\n\n  NestedSetSubjectExecutor.prototype.update = function (subject) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parent, entity, oldParent, oldParentId, parentId, escape_1, tableName, leftColumnName, rightColumnName, entityId, entityNs, parentNs, isMovingUp, treeSize, entitySize, updateLeftSide, updateRightSide, isUniqueRoot;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);\n            if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n              parent = subject.parentSubject.entity;\n            entity = subject.databaseEntity;\n            if (!entity && parent) // if entity was attached via children\n              entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(function (child) {\n                return Object.entries(subject.identifier).every(function (_a) {\n                  var _b = __read(_a, 2),\n                      key = _b[0],\n                      value = _b[1];\n\n                  return child[key] === value;\n                });\n              }); // Exit if the parent or the entity where never set\n\n            if (entity === undefined || parent === undefined) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n            oldParentId = subject.metadata.getEntityIdMap(oldParent);\n            parentId = subject.metadata.getEntityIdMap(parent); // Exit if the new and old parents are the same\n\n            if (OrmUtils.compareIds(oldParentId, parentId)) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!parent) return [3\n            /*break*/\n            , 9];\n\n            escape_1 = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            tableName = this.getTableName(subject.metadata.tablePath);\n            leftColumnName = escape_1(subject.metadata.nestedSetLeftColumn.databaseName);\n            rightColumnName = escape_1(subject.metadata.nestedSetRightColumn.databaseName);\n            entityId = subject.metadata.getEntityIdMap(entity);\n            entityNs = undefined;\n            if (!entityId) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.getNestedSetIds(subject.metadata, entityId)];\n\n          case 1:\n            entityNs = _a.sent()[0];\n            _a.label = 2;\n\n          case 2:\n            parentNs = undefined;\n            if (!parentId) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.getNestedSetIds(subject.metadata, parentId)];\n\n          case 3:\n            parentNs = _a.sent()[0];\n            _a.label = 4;\n\n          case 4:\n            if (!(entityNs !== undefined && parentNs !== undefined)) return [3\n            /*break*/\n            , 8];\n            isMovingUp = parentNs.left > entityNs.left;\n            treeSize = entityNs.right - entityNs.left + 1;\n            entitySize = void 0;\n\n            if (isMovingUp) {\n              entitySize = parentNs.left - entityNs.right;\n            } else {\n              entitySize = parentNs.right - entityNs.left;\n            }\n\n            updateLeftSide = \"WHEN \" + leftColumnName + \" >= \" + entityNs.left + \" AND \" + (leftColumnName + \" < \" + entityNs.right + \" \") + (\"THEN \" + leftColumnName + \" + \" + entitySize + \" \");\n            updateRightSide = \"WHEN \" + rightColumnName + \" > \" + entityNs.left + \" AND \" + (rightColumnName + \" <= \" + entityNs.right + \" \") + (\"THEN \" + rightColumnName + \" + \" + entitySize + \" \");\n            if (!isMovingUp) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"UPDATE \" + tableName + \" \" + (\"SET \" + leftColumnName + \" = CASE \") + (\"WHEN \" + leftColumnName + \" > \" + entityNs.right + \" AND \") + (leftColumnName + \" <= \" + parentNs.left + \" \") + (\"THEN \" + leftColumnName + \" - \" + treeSize + \" \") + updateLeftSide + (\"ELSE \" + leftColumnName + \" \") + \"END, \" + (rightColumnName + \" = CASE \") + (\"WHEN \" + rightColumnName + \" > \" + entityNs.right + \" AND \") + (rightColumnName + \" < \" + parentNs.left + \" \") + (\"THEN \" + rightColumnName + \" - \" + treeSize + \" \") + updateRightSide + (\"ELSE \" + rightColumnName + \" \") + \"END\")];\n\n          case 5:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"UPDATE \" + tableName + \" \" + (\"SET \" + leftColumnName + \" = CASE \") + (\"WHEN \" + leftColumnName + \" < \" + entityNs.left + \" AND \") + (leftColumnName + \" > \" + parentNs.right + \" \") + (\"THEN \" + leftColumnName + \" + \" + treeSize + \" \") + updateLeftSide + (\"ELSE \" + leftColumnName + \" \") + \"END, \" + (rightColumnName + \" = CASE \") + (\"WHEN \" + rightColumnName + \" < \" + entityNs.left + \" AND \") + (rightColumnName + \" >= \" + parentNs.right + \" \") + (\"THEN \" + rightColumnName + \" + \" + treeSize + \" \") + updateRightSide + (\"ELSE \" + rightColumnName + \" \") + \"END\")];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            return [3\n            /*break*/\n            , 11];\n\n          case 9:\n            return [4\n            /*yield*/\n            , this.isUniqueRootEntity(subject, parent)];\n\n          case 10:\n            isUniqueRoot = _a.sent(); // Validate if a root entity already exits and throw an exception\n\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n            _a.label = 11;\n\n          case 11:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n  * Executes operations when subject is being removed.\n  */\n\n\n  NestedSetSubjectExecutor.prototype.remove = function (subjects) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, escape, tableName, leftColumnName, rightColumnName, entitiesIds, subjects_1, subjects_1_1, subject, entityId, entitiesNs, entitiesNs_1, entitiesNs_1_1, entity, treeSize, e_1_1;\n\n      var e_2, _a, e_1, _b;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!Array.isArray(subjects)) subjects = [subjects];\n            metadata = subjects[0].metadata;\n\n            escape = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            tableName = this.getTableName(metadata.tablePath);\n            leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);\n            rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);\n            entitiesIds = [];\n\n            try {\n              for (subjects_1 = __values(subjects), subjects_1_1 = subjects_1.next(); !subjects_1_1.done; subjects_1_1 = subjects_1.next()) {\n                subject = subjects_1_1.value;\n                entityId = metadata.getEntityIdMap(subject.entity);\n\n                if (entityId) {\n                  entitiesIds.push(entityId);\n                }\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (subjects_1_1 && !subjects_1_1.done && (_a = subjects_1.return)) _a.call(subjects_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.getNestedSetIds(metadata, entitiesIds)];\n\n          case 1:\n            entitiesNs = _c.sent();\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 7, 8, 9]);\n\n            entitiesNs_1 = __values(entitiesNs), entitiesNs_1_1 = entitiesNs_1.next();\n            _c.label = 3;\n\n          case 3:\n            if (!!entitiesNs_1_1.done) return [3\n            /*break*/\n            , 6];\n            entity = entitiesNs_1_1.value;\n            treeSize = entity.right - entity.left + 1;\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"UPDATE \" + tableName + \" \" + (\"SET \" + leftColumnName + \" = CASE \") + (\"WHEN \" + leftColumnName + \" > \" + entity.left + \" THEN \" + leftColumnName + \" - \" + treeSize + \" \") + (\"ELSE \" + leftColumnName + \" \") + \"END, \" + (rightColumnName + \" = CASE \") + (\"WHEN \" + rightColumnName + \" > \" + entity.right + \" THEN \" + rightColumnName + \" - \" + treeSize + \" \") + (\"ELSE \" + rightColumnName + \" \") + \"END\")];\n\n          case 4:\n            _c.sent();\n\n            _c.label = 5;\n\n          case 5:\n            entitiesNs_1_1 = entitiesNs_1.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 6:\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            e_1_1 = _c.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            try {\n              if (entitiesNs_1_1 && !entitiesNs_1_1.done && (_b = entitiesNs_1.return)) _b.call(entitiesNs_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Get the nested set ids for a given entity\n   */\n\n\n  NestedSetSubjectExecutor.prototype.getNestedSetIds = function (metadata, ids) {\n    var select = {\n      left: metadata.targetName + \".\" + metadata.nestedSetLeftColumn.propertyPath,\n      right: metadata.targetName + \".\" + metadata.nestedSetRightColumn.propertyPath\n    };\n    var queryBuilder = this.queryRunner.manager.createQueryBuilder();\n    Object.entries(select).forEach(function (_a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      queryBuilder.addSelect(value, key);\n    });\n    return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, \"DESC\").getRawMany().then(function (results) {\n      var e_3, _a, e_4, _b;\n\n      var data = [];\n\n      try {\n        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n          var result = results_1_1.value;\n          var entry = {};\n\n          try {\n            for (var _c = (e_4 = void 0, __values(Object.keys(select))), _d = _c.next(); !_d.done; _d = _c.next()) {\n              var key = _d.value;\n              var value = result ? result[key] : undefined; // CockroachDB returns numeric types as string\n\n              entry[key] = typeof value === \"string\" ? parseInt(value) : value;\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n\n          data.push(entry);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return data;\n    });\n  };\n\n  NestedSetSubjectExecutor.prototype.isUniqueRootEntity = function (subject, parent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var escape, tableName, parameters, whereCondition, countAlias, result;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            escape = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            tableName = this.getTableName(subject.metadata.tablePath);\n            parameters = [];\n            whereCondition = subject.metadata.treeParentRelation.joinColumns.map(function (column) {\n              var columnName = escape(column.databaseName);\n              var parameter = column.getEntityValue(parent);\n\n              if (parameter == null) {\n                return columnName + \" IS NULL\";\n              }\n\n              parameters.push(parameter);\n\n              var parameterName = _this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n\n              return columnName + \" = \" + parameterName;\n            }).join(\" AND \");\n            countAlias = \"count\";\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"SELECT COUNT(1) AS \" + escape(countAlias) + \" FROM \" + tableName + \" WHERE \" + whereCondition, parameters)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , parseInt(result[0][countAlias]) === 0];\n        }\n      });\n    });\n  };\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n\n\n  NestedSetSubjectExecutor.prototype.getTableName = function (tablePath) {\n    var _this = this;\n\n    return tablePath.split(\".\").map(function (i) {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : _this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  };\n\n  return NestedSetSubjectExecutor;\n}();\n\nexport { NestedSetSubjectExecutor };","map":{"version":3,"sources":["../browser/src/persistence/tree/NestedSetSubjectExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"../Subject\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {NestedSetMultipleRootError} from \"../../error/NestedSetMultipleRootError\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\n\nclass NestedSetIds {\n    left: number;\n    right: number;\n}\n\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(subject.metadata.tablePath);\n        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn!.databaseName);\n        const rightColumnName = escape(subject.metadata.nestedSetRightColumn!.databaseName);\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n        const parentId = subject.metadata.getEntityIdMap(parent);\n\n        let parentNsRight: number|undefined = undefined;\n        if (parentId) {\n            parentNsRight = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn!.propertyPath, \"right\")\n                .from(subject.metadata.target, subject.metadata.targetName)\n                .whereInIds(parentId)\n                .getRawOne()\n                .then(result => {\n                    const value: any = result ? result[\"right\"] : undefined;\n                    // CockroachDB returns numeric types as string\n                    return typeof value === \"string\" ? parseInt(value) : value;\n                });\n        }\n\n        if (parentNsRight !== undefined) {\n            await this.queryRunner.query(`UPDATE ${tableName} SET ` +\n                `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\n                `${rightColumnName} = ${rightColumnName} + 2 ` +\n                `WHERE ${rightColumnName} >= ${parentNsRight}`);\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(parentNsRight),\n                subject.metadata.nestedSetRightColumn!.createValueMap(parentNsRight + 1),\n            );\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n            \n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot)\n                throw new NestedSetMultipleRootError();\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\n            );\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.entity;\n\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && parent) // if entity was attached via children\n            entity = subject.metadata.treeChildrenRelation!.getEntityValue(parent).find((child: any) => {\n                return Object.entries(subject.identifier!).every(([key, value]) => child[key] === value);\n            });\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return;\n        }\n\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(entity!);\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n        const parentId = subject.metadata.getEntityIdMap(parent);\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return;\n        }\n\n        if (parent) {\n            const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n            const tableName = this.getTableName(subject.metadata.tablePath);\n            const leftColumnName = escape(subject.metadata.nestedSetLeftColumn!.databaseName);\n            const rightColumnName = escape(subject.metadata.nestedSetRightColumn!.databaseName);\n\n            const entityId = subject.metadata.getEntityIdMap(entity);\n\n            let entityNs: NestedSetIds | undefined = undefined;\n            if (entityId) {\n                entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];\n            }\n\n            let parentNs: NestedSetIds | undefined = undefined;\n            if (parentId) {\n                parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];\n            }\n\n            if (entityNs !== undefined && parentNs !== undefined) {\n                const isMovingUp = parentNs.left > entityNs.left;\n                const treeSize = entityNs.right - entityNs.left + 1;\n\n                let entitySize: number;\n                if (isMovingUp) {\n                    entitySize = parentNs.left - entityNs.right;\n                } else {\n                    entitySize = parentNs.right - entityNs.left;\n                }\n                \n                // Moved entity logic\n                const updateLeftSide = \n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\n                        `${leftColumnName} < ${entityNs.right} ` +\n                    `THEN ${leftColumnName} + ${entitySize} `;\n\n                const updateRightSide = \n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\n                        `${rightColumnName} <= ${entityNs.right} ` +\n                    `THEN ${rightColumnName} + ${entitySize} `;\n                \n                // Update the surrounding entities\n                if (isMovingUp) {\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\n                        `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\n                                `${leftColumnName} <= ${parentNs.left} ` +\n                            `THEN ${leftColumnName} - ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                        `END, ` +\n                        `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\n                                `${rightColumnName} < ${parentNs.left} ` +\n                            `THEN ${rightColumnName} - ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                        `END`);\n                } else {\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\n                        `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\n                                `${leftColumnName} > ${parentNs.right} ` +\n                            `THEN ${leftColumnName} + ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                        `END, ` +\n                        `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\n                                `${rightColumnName} >= ${parentNs.right} ` +\n                            `THEN ${rightColumnName} + ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                        `END`);\n                }\n            }\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n            \n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot)\n                throw new NestedSetMultipleRootError();\n        }\n    }\n\n    /**\n    * Executes operations when subject is being removed.\n    */\n    async remove(subjects: Subject|Subject[]): Promise<void> {\n        if (!Array.isArray(subjects))\n            subjects = [subjects];\n\n        const metadata = subjects[0].metadata;\n\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(metadata.tablePath);\n        const leftColumnName = escape(metadata.nestedSetLeftColumn!.databaseName);\n        const rightColumnName = escape(metadata.nestedSetRightColumn!.databaseName);\n\n        let entitiesIds: ObjectLiteral[] = [];\n        for (const subject of subjects) {\n            const entityId = metadata.getEntityIdMap(subject.entity);\n            \n            if (entityId) {\n                entitiesIds.push(entityId);\n            }\n        }\n\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);\n\n        for (const entity of entitiesNs) {\n            const treeSize = entity.right - entity.left + 1;\n\n            await this.queryRunner.query(`UPDATE ${tableName} ` +\n                `SET ${leftColumnName} = CASE ` +\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\n                    `ELSE ${leftColumnName} ` +\n                `END, ` +\n                `${rightColumnName} = CASE ` +\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\n                    `ELSE ${rightColumnName} ` +\n                `END`);\n        }\n    }\n\n    /**\n     * Get the nested set ids for a given entity\n     */\n    protected getNestedSetIds(metadata: EntityMetadata, ids: ObjectLiteral | ObjectLiteral[]): Promise<NestedSetIds[]> {\n        const select = {\n            left: `${metadata.targetName}.${metadata.nestedSetLeftColumn!.propertyPath}`,\n            right: `${metadata.targetName}.${metadata.nestedSetRightColumn!.propertyPath}`\n        };\n\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder();\n\n        Object.entries(select).forEach(([key, value]) => {\n            queryBuilder.addSelect(value, key);\n        });\n\n        return queryBuilder\n            .from(metadata.target, metadata.targetName)\n            .whereInIds(ids)\n            .orderBy(select.right, \"DESC\")\n            .getRawMany()\n            .then(results => {\n                const data: NestedSetIds[] = [];\n\n                for (const result of results) {\n                    const entry: any = {};\n                    for (const key of Object.keys(select)) {\n                        const value = result ? result[key] : undefined;\n\n                        // CockroachDB returns numeric types as string\n                        entry[key] = typeof value === \"string\" ? parseInt(value) : value;\n                    }\n                    data.push(entry);\n                }\n                \n                return data;\n            });\n    }\n\n    private async isUniqueRootEntity(subject: Subject, parent: any): Promise<boolean> {\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(subject.metadata.tablePath);\n        const parameters: any[] = [];\n        const whereCondition = subject.metadata.treeParentRelation!.joinColumns.map(column => {\n            const columnName = escape(column.databaseName);\n            const parameter = column.getEntityValue(parent);\n\n            if (parameter == null) {\n                return `${columnName} IS NULL`;\n            }\n\n            parameters.push(parameter);\n            const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n            return `${columnName} = ${parameterName}`;\n        }).join(\" AND \");\n\n        const countAlias = \"count\";\n        const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters);\n\n        return parseInt(result[0][countAlias]) === 0;\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath.split(\".\")\n            .map(i => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n            }).join(\".\");\n    }\n}"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}