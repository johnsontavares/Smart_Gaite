{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Builds operations needs to be executed for many-to-many relations of the given subjects.\n *\n * by example: post contains owner many-to-many relation with categories in the property called \"categories\", e.g.\n *             @ManyToMany(type => Category, category => category.posts) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of junction table.\n */\n\nvar ManyToManySubjectBuilder =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function ManyToManySubjectBuilder(subjects) {\n    this.subjects = subjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds operations for any changes in the many-to-many relations of the subjects.\n   */\n\n\n  ManyToManySubjectBuilder.prototype.build = function () {\n    var _this = this;\n\n    this.subjects.forEach(function (subject) {\n      // if subject doesn't have entity then no need to find something that should be inserted or removed\n      if (!subject.entity) return; // go through all persistence enabled many-to-many relations and build subject operations for them\n\n      subject.metadata.manyToManyRelations.forEach(function (relation) {\n        // skip relations for which persistence is disabled\n        if (relation.persistenceEnabled === false) return;\n\n        _this.buildForSubjectRelation(subject, relation);\n      });\n    });\n  };\n  /**\n   * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.\n   */\n\n\n  ManyToManySubjectBuilder.prototype.buildForAllRemoval = function (subject) {\n    var _this = this; // if subject does not have a database entity then it means it does not exist in the database\n    // if it does not exist in the database then we don't have anything for deletion\n\n\n    if (!subject.databaseEntity) return; // go through all persistence enabled many-to-many relations and build subject operations for them\n\n    subject.metadata.manyToManyRelations.forEach(function (relation) {\n      // skip relations for which persistence is disabled\n      if (relation.persistenceEnabled === false) return; // get all related entities (actually related entity relation ids) bind to this subject entity\n      // by example: returns category ids of the post we are currently working with (subject.entity is post)\n\n      var relatedEntityRelationIdsInDatabase = relation.getEntityValue(subject.databaseEntity); // go through all related entities and create a new junction subject for each row in junction table\n\n      relatedEntityRelationIdsInDatabase.forEach(function (relationId) {\n        var junctionSubject = new Subject({\n          metadata: relation.junctionEntityMetadata,\n          parentSubject: subject,\n          mustBeRemoved: true,\n          identifier: _this.buildJunctionIdentifier(subject, relation, relationId)\n        }); // we use unshift because we need to perform those operations before post deletion is performed\n        // but post deletion was already added as an subject\n        // this is temporary solution, later we need to implement proper sorting of subjects before their removal\n\n        _this.subjects.push(junctionSubject);\n      });\n    });\n  }; // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds operations for a given subject and relation.\n   *\n   * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n   */\n\n\n  ManyToManySubjectBuilder.prototype.buildForSubjectRelation = function (subject, relation) {\n    var _this = this; // load from db all relation ids of inverse entities that are \"bind\" to the subject's entity\n    // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n\n\n    var databaseRelatedEntityIds = []; // if subject don't have database entity it means all related entities in persisted subject are new and must be bind\n    // and we don't need to remove something that is not exist\n\n    if (subject.databaseEntity) databaseRelatedEntityIds = relation.getEntityValue(subject.databaseEntity); // extract entity's relation value\n    // by example: categories inside our post (subject.entity is post)\n\n    var relatedEntities = relation.getEntityValue(subject.entity);\n    if (relatedEntities === null) // if value set to null its equal if we set it to empty array - all items must be removed from the database\n      relatedEntities = [];\n    if (!Array.isArray(relatedEntities)) return; // from all related entities find only those which aren't found in the db - for them we will create operation subjects\n\n    relatedEntities.forEach(function (relatedEntity) {\n      // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet\n      // extract only relation id from the related entities, since we only need it for comparision\n      // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n      var relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n\n      var relatedEntitySubject = _this.subjects.find(function (subject) {\n        return subject.entity === relatedEntity;\n      }); // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n\n\n      if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier; // if related entity relation id map is empty it means related entity is newly persisted\n\n      if (!relatedEntityRelationIdMap) {\n        // we decided to remove this error because it brings complications when saving object with non-saved entities\n        // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n        // in this persistence because he didn't pass this entity for save or he did not set cascades\n        // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n        // we decided to remove this error because it brings complications when saving object with non-saved entities\n        // if (!relatedEntitySubject)\n        //     throw new Error(`Many-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n        //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n        //         `Please setup cascade insertion or save entities before binding it.`);\n        if (!relatedEntitySubject) return;\n      } // try to find related entity in the database\n      // by example: find post's category in the database post's categories\n\n\n      var relatedEntityExistInDatabase = databaseRelatedEntityIds.find(function (databaseRelatedEntityRelationId) {\n        return OrmUtils.compareIds(databaseRelatedEntityRelationId, relatedEntityRelationIdMap);\n      }); // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything\n\n      if (relatedEntityExistInDatabase) return;\n      var ownerValue = relation.isOwning ? subject : relatedEntitySubject || relatedEntity; // by example: ownerEntityMap is post from subject here\n\n      var inverseValue = relation.isOwning ? relatedEntitySubject || relatedEntity : subject; // by example: inverseEntityMap is category from categories array here\n      // create a new subject for insert operation of junction rows\n\n      var junctionSubject = new Subject({\n        metadata: relation.junctionEntityMetadata,\n        parentSubject: subject,\n        canBeInserted: true\n      });\n\n      _this.subjects.push(junctionSubject);\n\n      relation.junctionEntityMetadata.ownerColumns.forEach(function (column) {\n        junctionSubject.changeMaps.push({\n          column: column,\n          value: ownerValue // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),\n\n        });\n      });\n      relation.junctionEntityMetadata.inverseColumns.forEach(function (column) {\n        junctionSubject.changeMaps.push({\n          column: column,\n          value: inverseValue // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),\n\n        });\n      });\n    }); // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n\n    var changedInverseEntityRelationIds = [];\n    relatedEntities.forEach(function (relatedEntity) {\n      // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n      var relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n\n      var relatedEntitySubject = _this.subjects.find(function (subject) {\n        return subject.entity === relatedEntity;\n      }); // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n\n\n      if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;\n      if (relatedEntityRelationIdMap !== undefined && relatedEntityRelationIdMap !== null) changedInverseEntityRelationIds.push(relatedEntityRelationIdMap);\n    }); // now from all entities in the persisted entity find only those which aren't found in the db\n\n    var removedJunctionEntityIds = databaseRelatedEntityIds.filter(function (existRelationId) {\n      return !changedInverseEntityRelationIds.find(function (changedRelationId) {\n        return OrmUtils.compareIds(changedRelationId, existRelationId);\n      });\n    }); // finally create a new junction remove operations for missing related entities\n\n    removedJunctionEntityIds.forEach(function (removedEntityRelationId) {\n      var junctionSubject = new Subject({\n        metadata: relation.junctionEntityMetadata,\n        parentSubject: subject,\n        mustBeRemoved: true,\n        identifier: _this.buildJunctionIdentifier(subject, relation, removedEntityRelationId)\n      });\n\n      _this.subjects.push(junctionSubject);\n    });\n  };\n  /**\n   * Creates identifiers for junction table.\n   * Example: { postId: 1, categoryId: 2 }\n   */\n\n\n  ManyToManySubjectBuilder.prototype.buildJunctionIdentifier = function (subject, relation, relationId) {\n    var ownerEntityMap = relation.isOwning ? subject.entity : relationId;\n    var inverseEntityMap = relation.isOwning ? relationId : subject.entity;\n    var identifier = {};\n    relation.junctionEntityMetadata.ownerColumns.forEach(function (column) {\n      OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(ownerEntityMap)));\n    });\n    relation.junctionEntityMetadata.inverseColumns.forEach(function (column) {\n      OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(inverseEntityMap)));\n    });\n    return identifier;\n  };\n\n  return ManyToManySubjectBuilder;\n}();\n\nexport { ManyToManySubjectBuilder };","map":{"version":3,"sources":["../browser/src/persistence/subject-builder/ManyToManySubjectBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"../Subject\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {RelationMetadata} from \"../../metadata/RelationMetadata\";\n\n/**\n * Builds operations needs to be executed for many-to-many relations of the given subjects.\n *\n * by example: post contains owner many-to-many relation with categories in the property called \"categories\", e.g.\n *             @ManyToMany(type => Category, category => category.posts) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of junction table.\n */\nexport class ManyToManySubjectBuilder {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for any changes in the many-to-many relations of the subjects.\n     */\n    build(): void {\n        this.subjects.forEach(subject => {\n\n            // if subject doesn't have entity then no need to find something that should be inserted or removed\n            if (!subject.entity)\n                return;\n\n            // go through all persistence enabled many-to-many relations and build subject operations for them\n            subject.metadata.manyToManyRelations.forEach(relation => {\n\n                // skip relations for which persistence is disabled\n                if (relation.persistenceEnabled === false)\n                    return;\n\n                this.buildForSubjectRelation(subject, relation);\n            });\n        });\n    }\n\n    /**\n     * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.\n     */\n    buildForAllRemoval(subject: Subject) {\n\n        // if subject does not have a database entity then it means it does not exist in the database\n        // if it does not exist in the database then we don't have anything for deletion\n        if (!subject.databaseEntity)\n            return;\n\n        // go through all persistence enabled many-to-many relations and build subject operations for them\n        subject.metadata.manyToManyRelations.forEach(relation => {\n\n            // skip relations for which persistence is disabled\n            if (relation.persistenceEnabled === false)\n                return;\n\n            // get all related entities (actually related entity relation ids) bind to this subject entity\n            // by example: returns category ids of the post we are currently working with (subject.entity is post)\n            const relatedEntityRelationIdsInDatabase: ObjectLiteral[] = relation.getEntityValue(subject.databaseEntity!);\n\n            // go through all related entities and create a new junction subject for each row in junction table\n            relatedEntityRelationIdsInDatabase.forEach(relationId => {\n                const junctionSubject = new Subject({\n                    metadata: relation.junctionEntityMetadata!,\n                    parentSubject: subject,\n                    mustBeRemoved: true,\n                    identifier: this.buildJunctionIdentifier(subject, relation, relationId)\n                });\n\n                // we use unshift because we need to perform those operations before post deletion is performed\n                // but post deletion was already added as an subject\n                // this is temporary solution, later we need to implement proper sorting of subjects before their removal\n                this.subjects.push(junctionSubject);\n            });\n        });\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n     */\n    protected buildForSubjectRelation(subject: Subject, relation: RelationMetadata) {\n\n        // load from db all relation ids of inverse entities that are \"bind\" to the subject's entity\n        // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n        let databaseRelatedEntityIds: ObjectLiteral[] = [];\n\n        // if subject don't have database entity it means all related entities in persisted subject are new and must be bind\n        // and we don't need to remove something that is not exist\n        if (subject.databaseEntity)\n            databaseRelatedEntityIds = relation.getEntityValue(subject.databaseEntity);\n\n        // extract entity's relation value\n        // by example: categories inside our post (subject.entity is post)\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(subject.entity!);\n        if (relatedEntities === null) // if value set to null its equal if we set it to empty array - all items must be removed from the database\n            relatedEntities = [];\n        if (!(Array.isArray(relatedEntities)))\n            return;\n\n        // from all related entities find only those which aren't found in the db - for them we will create operation subjects\n        relatedEntities.forEach(relatedEntity => { // by example: relatedEntity is category from categories saved with post\n\n            // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet\n\n            // extract only relation id from the related entities, since we only need it for comparision\n            // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n            let relatedEntityRelationIdMap = relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity);\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            const relatedEntitySubject = this.subjects.find(subject => {\n                return subject.entity === relatedEntity;\n            });\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier;\n\n            // if related entity relation id map is empty it means related entity is newly persisted\n            if (!relatedEntityRelationIdMap) {\n\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n                // in this persistence because he didn't pass this entity for save or he did not set cascades\n                // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if (!relatedEntitySubject)\n                //     throw new Error(`Many-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n                //         `Please setup cascade insertion or save entities before binding it.`);\n                if (!relatedEntitySubject)\n                    return;\n            }\n\n            // try to find related entity in the database\n            // by example: find post's category in the database post's categories\n            const relatedEntityExistInDatabase = databaseRelatedEntityIds.find(databaseRelatedEntityRelationId => {\n                return OrmUtils.compareIds(databaseRelatedEntityRelationId, relatedEntityRelationIdMap);\n            });\n\n            // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything\n            if (relatedEntityExistInDatabase)\n                return;\n\n            const ownerValue = relation.isOwning ? subject : (relatedEntitySubject || relatedEntity); // by example: ownerEntityMap is post from subject here\n            const inverseValue = relation.isOwning ? (relatedEntitySubject || relatedEntity) : subject; // by example: inverseEntityMap is category from categories array here\n\n            // create a new subject for insert operation of junction rows\n            const junctionSubject = new Subject({\n                metadata: relation.junctionEntityMetadata!,\n                parentSubject: subject,\n                canBeInserted: true,\n            });\n            this.subjects.push(junctionSubject);\n\n            relation.junctionEntityMetadata!.ownerColumns.forEach(column => {\n                junctionSubject.changeMaps.push({\n                    column: column,\n                    value: ownerValue,\n                    // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),\n                });\n            });\n\n            relation.junctionEntityMetadata!.inverseColumns.forEach(column => {\n                junctionSubject.changeMaps.push({\n                    column: column,\n                    value: inverseValue,\n                    // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),\n                });\n            });\n        });\n\n        // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n        const changedInverseEntityRelationIds: ObjectLiteral[] = [];\n        relatedEntities.forEach(relatedEntity => {\n            // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n            let relatedEntityRelationIdMap = relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity);\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            const relatedEntitySubject = this.subjects.find(subject => {\n                return subject.entity === relatedEntity;\n            });\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier;\n\n            if (relatedEntityRelationIdMap !== undefined && relatedEntityRelationIdMap !== null)\n                changedInverseEntityRelationIds.push(relatedEntityRelationIdMap);\n        });\n\n        // now from all entities in the persisted entity find only those which aren't found in the db\n        const removedJunctionEntityIds = databaseRelatedEntityIds.filter(existRelationId => {\n            return !changedInverseEntityRelationIds.find(changedRelationId => {\n                return OrmUtils.compareIds(changedRelationId, existRelationId);\n            });\n        });\n\n        // finally create a new junction remove operations for missing related entities\n        removedJunctionEntityIds.forEach(removedEntityRelationId => {\n            const junctionSubject = new Subject({\n                metadata: relation.junctionEntityMetadata!,\n                parentSubject: subject,\n                mustBeRemoved: true,\n                identifier: this.buildJunctionIdentifier(subject, relation, removedEntityRelationId)\n            });\n            this.subjects.push(junctionSubject);\n        });\n    }\n\n    /**\n     * Creates identifiers for junction table.\n     * Example: { postId: 1, categoryId: 2 }\n     */\n    protected buildJunctionIdentifier(subject: Subject, relation: RelationMetadata, relationId: ObjectLiteral) {\n        const ownerEntityMap = relation.isOwning ? subject.entity! : relationId;\n        const inverseEntityMap = relation.isOwning ? relationId : subject.entity!;\n\n        const identifier: ObjectLiteral = {};\n        relation.junctionEntityMetadata!.ownerColumns.forEach(column => {\n            OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn!.getEntityValue(ownerEntityMap)));\n        });\n        relation.junctionEntityMetadata!.inverseColumns.forEach(column => {\n            OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn!.getEntityValue(inverseEntityMap)));\n        });\n        return identifier;\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}