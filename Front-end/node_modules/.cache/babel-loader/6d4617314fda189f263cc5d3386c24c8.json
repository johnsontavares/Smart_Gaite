{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\n\nvar RelationCountLoader =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationCountLoader(connection, queryRunner, relationCountAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationCountAttributes = relationCountAttributes;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  RelationCountLoader.prototype.load = function (rawEntities) {\n    return __awaiter(this, void 0, void 0, function () {\n      var onlyUnique, promises;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        onlyUnique = function (value, index, self) {\n          return self.indexOf(value) === index;\n        };\n\n        promises = this.relationCountAttributes.map(function (relationCountAttr) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var relation, inverseRelation, referenceColumnName_1, inverseSideTable, inverseSideTableName, inverseSideTableAlias, inverseSidePropertyName, referenceColumnValues, qb, joinTableColumnName_1, inverseJoinColumnName, firstJunctionColumn, secondJunctionColumn, referenceColumnValues, junctionAlias, inverseSideTableName, inverseSideTableAlias, junctionTableName, condition, qb;\n\n            var _a, _b;\n\n            return __generator(this, function (_c) {\n              switch (_c.label) {\n                case 0:\n                  if (!relationCountAttr.relation.isOneToMany) return [3\n                  /*break*/\n                  , 2];\n                  relation = relationCountAttr.relation;\n                  inverseRelation = relation.inverseRelation;\n                  referenceColumnName_1 = inverseRelation.joinColumns[0].referencedColumn.propertyName;\n                  inverseSideTable = relation.inverseEntityMetadata.target;\n                  inverseSideTableName = relation.inverseEntityMetadata.tableName;\n                  inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n                  inverseSidePropertyName = inverseRelation.propertyName;\n                  referenceColumnValues = rawEntities.map(function (rawEntity) {\n                    return rawEntity[relationCountAttr.parentAlias + \"_\" + referenceColumnName_1];\n                  }).filter(function (value) {\n                    return !!value;\n                  });\n                  referenceColumnValues = referenceColumnValues.filter(onlyUnique); // ensure we won't perform redundant queries for joined data which was not found in selection\n                  // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n                  if (referenceColumnValues.length === 0) return [2\n                  /*return*/\n                  , {\n                    relationCountAttribute: relationCountAttr,\n                    results: []\n                  }];\n                  qb = this.connection.createQueryBuilder(this.queryRunner);\n                  qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\").addSelect(\"COUNT(*)\", \"cnt\").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + \".\" + inverseSidePropertyName + \" IN (:...ids)\").addGroupBy(inverseSideTableAlias + \".\" + inverseSidePropertyName).setParameter(\"ids\", referenceColumnValues); // apply condition (custom query builder factory)\n\n                  if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n                  _a = {\n                    relationCountAttribute: relationCountAttr\n                  };\n                  return [4\n                  /*yield*/\n                  , qb.getRawMany()];\n\n                case 1:\n                  return [2\n                  /*return*/\n                  , (_a.results = _c.sent(), _a)];\n\n                case 2:\n                  inverseJoinColumnName = void 0;\n                  firstJunctionColumn = void 0;\n                  secondJunctionColumn = void 0;\n\n                  if (relationCountAttr.relation.isOwning) {\n                    // todo fix joinColumns[0] and inverseJoinColumns[0].\n                    joinTableColumnName_1 = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;\n                    inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;\n                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n                  } else {\n                    joinTableColumnName_1 = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;\n                    inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n                  }\n\n                  referenceColumnValues = rawEntities.map(function (rawEntity) {\n                    return rawEntity[relationCountAttr.parentAlias + \"_\" + joinTableColumnName_1];\n                  }).filter(function (value) {\n                    return !!value;\n                  });\n                  referenceColumnValues = referenceColumnValues.filter(onlyUnique); // ensure we won't perform redundant queries for joined data which was not found in selection\n                  // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n                  if (referenceColumnValues.length === 0) return [2\n                  /*return*/\n                  , {\n                    relationCountAttribute: relationCountAttr,\n                    results: []\n                  }];\n                  junctionAlias = relationCountAttr.junctionAlias;\n                  inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n                  inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n                  junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;\n                  condition = junctionAlias + \".\" + firstJunctionColumn.propertyName + \" IN (\" + referenceColumnValues.map(function (vals) {\n                    return isNaN(vals) ? \"'\" + vals + \"'\" : vals;\n                  }) + \")\" + \" AND \" + junctionAlias + \".\" + secondJunctionColumn.propertyName + \" = \" + inverseSideTableAlias + \".\" + inverseJoinColumnName;\n                  qb = this.connection.createQueryBuilder(this.queryRunner);\n                  qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\").addSelect(\"COUNT(\" + qb.escape(inverseSideTableAlias) + \".\" + qb.escape(inverseJoinColumnName) + \")\", \"cnt\").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + \".\" + firstJunctionColumn.propertyName); // apply condition (custom query builder factory)\n\n                  if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n                  _b = {\n                    relationCountAttribute: relationCountAttr\n                  };\n                  return [4\n                  /*yield*/\n                  , qb.getRawMany()];\n\n                case 3:\n                  return [2\n                  /*return*/\n                  , (_b.results = _c.sent(), _b)];\n              }\n            });\n          });\n        });\n        return [2\n        /*return*/\n        , Promise.all(promises)];\n      });\n    });\n  };\n\n  return RelationCountLoader;\n}();\n\nexport { RelationCountLoader };","map":{"version":3,"sources":["../browser/src/query-builder/relation-count/RelationCountLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\nimport {Connection} from \"../../connection/Connection\";\nimport {RelationCountAttribute} from \"./RelationCountAttribute\";\nimport {RelationCountLoadResult} from \"./RelationCountLoadResult\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\n\nexport class RelationCountLoader {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunner: QueryRunner|undefined,\n                protected relationCountAttributes: RelationCountAttribute[]) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\n\n        const onlyUnique = (value: any, index: number, self: any) => {\n            return self.indexOf(value) === index;\n        };\n\n        const promises = this.relationCountAttributes.map(async relationCountAttr => {\n\n            if (relationCountAttr.relation.isOneToMany) {\n                // example: Post and Category\n                // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                // we expect it to load array of post ids\n\n                // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                const relation = relationCountAttr.relation; // \"category.posts\"\n                const inverseRelation = relation.inverseRelation!; // \"post.category\"\n                const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn!.propertyName; // post id\n                const inverseSideTable = relation.inverseEntityMetadata.target; // Post\n                const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post\n                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                const inverseSidePropertyName = inverseRelation.propertyName; // \"category\" from \"post.category\"\n\n                let referenceColumnValues = rawEntities\n                    .map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + referenceColumnName])\n                    .filter(value => !!value);\n                referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (referenceColumnValues.length === 0)\n                    return { relationCountAttribute: relationCountAttr, results: [] };\n\n                // generate query:\n                // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\")\n                    .addSelect(\"COUNT(*)\", \"cnt\")\n                    .from(inverseSideTable, inverseSideTableAlias)\n                    .where(inverseSideTableAlias + \".\" + inverseSidePropertyName + \" IN (:...ids)\")\n                    .addGroupBy(inverseSideTableAlias + \".\" + inverseSidePropertyName)\n                    .setParameter(\"ids\", referenceColumnValues);\n\n                // apply condition (custom query builder factory)\n                if (relationCountAttr.queryBuilderFactory)\n                    relationCountAttr.queryBuilderFactory(qb);\n\n                return {\n                    relationCountAttribute: relationCountAttr,\n                    results: await qb.getRawMany()\n                };\n\n            } else {\n                // example: Post and Category\n                // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                // we expect it to load array of post ids\n\n                let joinTableColumnName: string;\n                let inverseJoinColumnName: string;\n                let firstJunctionColumn: ColumnMetadata;\n                let secondJunctionColumn: ColumnMetadata;\n\n                if (relationCountAttr.relation.isOwning) { // todo fix joinColumns[0] and inverseJoinColumns[0].\n                    joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn!.databaseName;\n                    inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn!.databaseName;\n                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[0];\n                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[1];\n\n                } else {\n                    joinTableColumnName = relationCountAttr.relation.inverseRelation!.inverseJoinColumns[0].referencedColumn!.databaseName;\n                    inverseJoinColumnName = relationCountAttr.relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName;\n                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[1];\n                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[0];\n                }\n\n                let referenceColumnValues = rawEntities\n                    .map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + joinTableColumnName])\n                    .filter(value => !!value);\n                referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (referenceColumnValues.length === 0)\n                    return { relationCountAttribute: relationCountAttr, results: [] };\n\n                const junctionAlias = relationCountAttr.junctionAlias;\n                const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n                const junctionTableName = relationCountAttr.relation.junctionEntityMetadata!.tableName;\n                \n                const condition = junctionAlias + \".\" + firstJunctionColumn.propertyName + \" IN (\" + referenceColumnValues.map(vals => isNaN(vals) ? \"'\" + vals + \"'\" : vals) + \")\" +\n                    \" AND \" + junctionAlias + \".\" + secondJunctionColumn.propertyName + \" = \" + inverseSideTableAlias + \".\" + inverseJoinColumnName;\n\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\")\n                    .addSelect(\"COUNT(\" + qb.escape(inverseSideTableAlias) + \".\" + qb.escape(inverseJoinColumnName) + \")\", \"cnt\")\n                    .from(inverseSideTableName, inverseSideTableAlias)\n                    .innerJoin(junctionTableName, junctionAlias, condition)\n                    .addGroupBy(junctionAlias + \".\" + firstJunctionColumn.propertyName);\n\n                // apply condition (custom query builder factory)\n                if (relationCountAttr.queryBuilderFactory)\n                    relationCountAttr.queryBuilderFactory(qb);\n\n                return {\n                    relationCountAttribute: relationCountAttr,\n                    results: await qb.getRawMany()\n                };\n            }\n        });\n\n        return Promise.all(promises);\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}