{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport { SapDriver } from \"../driver/sap/SapDriver\";\nimport { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\";\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\";\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\";\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\";\nimport { MongoQueryRunner } from \"../driver/mongodb/MongoQueryRunner\";\nimport { MongoDriver } from \"../driver/mongodb/MongoDriver\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\";\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\";\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\n\nvar SubjectExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function SubjectExecutor(queryRunner, subjects, options) {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    this.hasExecutableOperations = false;\n    /**\n     * Subjects that must be inserted.\n     */\n\n    this.insertSubjects = [];\n    /**\n     * Subjects that must be updated.\n     */\n\n    this.updateSubjects = [];\n    /**\n     * Subjects that must be removed.\n     */\n\n    this.removeSubjects = [];\n    /**\n     * Subjects that must be soft-removed.\n     */\n\n    this.softRemoveSubjects = [];\n    /**\n     * Subjects that must be recovered.\n     */\n\n    this.recoverSubjects = [];\n    this.queryRunner = queryRunner;\n    this.allSubjects = subjects;\n    this.options = options;\n    this.validate();\n    this.recompute();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes all operations over given array of subjects.\n   * Executes queries using given query runner.\n   */\n\n\n  SubjectExecutor.prototype.execute = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var broadcasterResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            broadcasterResult = undefined;\n            if (!(!this.options || this.options.listeners !== false)) return [3\n            /*break*/\n            , 2]; // console.time(\".broadcastBeforeEventsForAll\");\n\n            broadcasterResult = this.broadcastBeforeEventsForAll();\n            if (!(broadcasterResult.promises.length > 0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all(broadcasterResult.promises)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n            // recompute only in the case if any listener or subscriber was really executed\n            if (broadcasterResult && broadcasterResult.count > 0) {\n              // console.time(\".recompute\");\n              this.insertSubjects.forEach(function (subject) {\n                return subject.recompute();\n              });\n              this.updateSubjects.forEach(function (subject) {\n                return subject.recompute();\n              });\n              this.removeSubjects.forEach(function (subject) {\n                return subject.recompute();\n              });\n              this.softRemoveSubjects.forEach(function (subject) {\n                return subject.recompute();\n              });\n              this.recoverSubjects.forEach(function (subject) {\n                return subject.recompute();\n              });\n              this.recompute(); // console.timeEnd(\".recompute\");\n            } // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n            // console.timeEnd(\"prepare\");\n            // execute all insert operations\n            // console.time(\".insertion\");\n\n\n            this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n            return [4\n            /*yield*/\n            , this.executeInsertOperations()];\n\n          case 3:\n            _a.sent(); // console.timeEnd(\".insertion\");\n            // recompute update operations since insertion can create updation operations for the\n            // properties it wasn't able to handle on its own (referenced columns)\n\n\n            this.updateSubjects = this.allSubjects.filter(function (subject) {\n              return subject.mustBeUpdated;\n            }); // execute update operations\n            // console.time(\".updation\");\n\n            return [4\n            /*yield*/\n            , this.executeUpdateOperations()];\n\n          case 4:\n            // execute update operations\n            // console.time(\".updation\");\n            _a.sent(); // console.timeEnd(\".updation\");\n            // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n            // console.time(\".removal\");\n\n\n            this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n            return [4\n            /*yield*/\n            , this.executeRemoveOperations()];\n\n          case 5:\n            _a.sent(); // console.timeEnd(\".removal\");\n            // recompute soft-remove operations\n\n\n            this.softRemoveSubjects = this.allSubjects.filter(function (subject) {\n              return subject.mustBeSoftRemoved;\n            }); // execute soft-remove operations\n\n            return [4\n            /*yield*/\n            , this.executeSoftRemoveOperations()];\n\n          case 6:\n            // execute soft-remove operations\n            _a.sent(); // recompute recover operations\n\n\n            this.recoverSubjects = this.allSubjects.filter(function (subject) {\n              return subject.mustBeRecovered;\n            }); // execute recover operations\n\n            return [4\n            /*yield*/\n            , this.executeRecoverOperations()];\n\n          case 7:\n            // execute recover operations\n            _a.sent(); // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n            // console.time(\".updateSpecialColumnsInPersistedEntities\");\n\n\n            return [4\n            /*yield*/\n            , this.updateSpecialColumnsInPersistedEntities()];\n\n          case 8:\n            // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n            // console.time(\".updateSpecialColumnsInPersistedEntities\");\n            _a.sent();\n\n            if (!(!this.options || this.options.listeners !== false)) return [3\n            /*break*/\n            , 10]; // console.time(\".broadcastAfterEventsForAll\");\n\n            broadcasterResult = this.broadcastAfterEventsForAll();\n            if (!(broadcasterResult.promises.length > 0)) return [3\n            /*break*/\n            , 10];\n            return [4\n            /*yield*/\n            , Promise.all(broadcasterResult.promises)];\n\n          case 9:\n            _a.sent();\n\n            _a.label = 10;\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Validates all given subjects.\n   */\n\n\n  SubjectExecutor.prototype.validate = function () {\n    this.allSubjects.forEach(function (subject) {\n      if (subject.mustBeUpdated && subject.mustBeRemoved) throw new SubjectRemovedAndUpdatedError(subject);\n    });\n  };\n  /**\n   * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n   */\n\n\n  SubjectExecutor.prototype.recompute = function () {\n    new SubjectChangedColumnsComputer().compute(this.allSubjects);\n    this.insertSubjects = this.allSubjects.filter(function (subject) {\n      return subject.mustBeInserted;\n    });\n    this.updateSubjects = this.allSubjects.filter(function (subject) {\n      return subject.mustBeUpdated;\n    });\n    this.removeSubjects = this.allSubjects.filter(function (subject) {\n      return subject.mustBeRemoved;\n    });\n    this.softRemoveSubjects = this.allSubjects.filter(function (subject) {\n      return subject.mustBeSoftRemoved;\n    });\n    this.recoverSubjects = this.allSubjects.filter(function (subject) {\n      return subject.mustBeRecovered;\n    });\n    this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n  };\n  /**\n   * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\n   */\n\n\n  SubjectExecutor.prototype.broadcastBeforeEventsForAll = function () {\n    var _this = this;\n\n    var result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity);\n    });\n    if (this.updateSubjects.length) this.updateSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations);\n    });\n    if (this.removeSubjects.length) this.removeSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity);\n    });\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations);\n    });\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations);\n    });\n    return result;\n  };\n  /**\n   * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\n   * Returns void if there wasn't any listener or subscriber executed.\n   * Note: this method has a performance-optimized code organization.\n   */\n\n\n  SubjectExecutor.prototype.broadcastAfterEventsForAll = function () {\n    var _this = this;\n\n    var result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity);\n    });\n    if (this.updateSubjects.length) this.updateSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations);\n    });\n    if (this.removeSubjects.length) this.removeSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity);\n    });\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations);\n    });\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(function (subject) {\n      return _this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations);\n    });\n    return result;\n  };\n  /**\n   * Executes insert operations.\n   */\n\n\n  SubjectExecutor.prototype.executeInsertOperations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, groupedInsertSubjects, groupedInsertSubjectKeys, _loop_1, this_1, groupedInsertSubjectKeys_1, groupedInsertSubjectKeys_1_1, groupName, e_1_1;\n\n      var e_1, _b;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = __read(this.groupBulkSubjects(this.insertSubjects, \"insert\"), 2), groupedInsertSubjects = _a[0], groupedInsertSubjectKeys = _a[1];\n\n            _loop_1 = function (groupName) {\n              var subjects, bulkInsertMaps, bulkInsertSubjects, singleInsertSubjects, manager, insertResult_1, insertResult_2, _loop_2, singleInsertSubjects_1, singleInsertSubjects_1_1, subject, e_2_1;\n\n              var e_2, _d;\n\n              return __generator(this, function (_e) {\n                switch (_e.label) {\n                  case 0:\n                    subjects = groupedInsertSubjects[groupName];\n                    bulkInsertMaps = [];\n                    bulkInsertSubjects = [];\n                    singleInsertSubjects = [];\n\n                    if (this_1.queryRunner.connection.driver instanceof MongoDriver) {\n                      subjects.forEach(function (subject) {\n                        if (subject.metadata.createDateColumn && subject.entity) {\n                          subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n                        }\n\n                        if (subject.metadata.updateDateColumn && subject.entity) {\n                          subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n                        }\n\n                        subject.createValueSetAndPopChangeMap();\n                        bulkInsertSubjects.push(subject);\n                        bulkInsertMaps.push(subject.entity);\n                      });\n                    } else if (this_1.queryRunner.connection.driver instanceof OracleDriver) {\n                      subjects.forEach(function (subject) {\n                        singleInsertSubjects.push(subject);\n                      });\n                    } else {\n                      subjects.forEach(function (subject) {\n                        // we do not insert in bulk in following cases:\n                        // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                        // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                        // - when oracle is used, since oracle's bulk insertion is very bad\n                        if (subject.changeMaps.length === 0 || subject.metadata.treeType || _this.queryRunner.connection.driver instanceof OracleDriver || _this.queryRunner.connection.driver instanceof SapDriver) {\n                          singleInsertSubjects.push(subject);\n                        } else {\n                          bulkInsertSubjects.push(subject);\n                          bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n                        }\n                      });\n                    }\n\n                    if (!(this_1.queryRunner instanceof MongoQueryRunner)) return [3\n                    /*break*/\n                    , 2];\n                    manager = this_1.queryRunner.manager;\n                    return [4\n                    /*yield*/\n                    , manager.insert(subjects[0].metadata.target, bulkInsertMaps)];\n\n                  case 1:\n                    insertResult_1 = _e.sent();\n                    subjects.forEach(function (subject, index) {\n                      subject.identifier = insertResult_1.identifiers[index];\n                      subject.generatedMap = insertResult_1.generatedMaps[index];\n                      subject.insertedValueSet = bulkInsertMaps[index];\n                    });\n                    return [3\n                    /*break*/\n                    , 12];\n\n                  case 2:\n                    if (!(bulkInsertMaps.length > 0)) return [3\n                    /*break*/\n                    , 4];\n                    return [4\n                    /*yield*/\n                    , this_1.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(this_1.options && this_1.options.reload === false ? false : true).callListeners(false).execute()];\n\n                  case 3:\n                    insertResult_2 = _e.sent();\n                    bulkInsertSubjects.forEach(function (subject, index) {\n                      subject.identifier = insertResult_2.identifiers[index];\n                      subject.generatedMap = insertResult_2.generatedMaps[index];\n                      subject.insertedValueSet = bulkInsertMaps[index];\n                    });\n                    _e.label = 4;\n\n                  case 4:\n                    if (!(singleInsertSubjects.length > 0)) return [3\n                    /*break*/\n                    , 12];\n\n                    _loop_2 = function (subject) {\n                      return __generator(this, function (_f) {\n                        switch (_f.label) {\n                          case 0:\n                            subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n\n                            if (!(subject.metadata.treeType === \"nested-set\")) return [3\n                            /*break*/\n                            , 2];\n                            return [4\n                            /*yield*/\n                            , new NestedSetSubjectExecutor(this_1.queryRunner).insert(subject)];\n\n                          case 1:\n                            _f.sent();\n\n                            _f.label = 2;\n\n                          case 2:\n                            return [4\n                            /*yield*/\n                            , this_1.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(this_1.options && this_1.options.reload === false ? false : true).callListeners(false).execute().then(function (insertResult) {\n                              subject.identifier = insertResult.identifiers[0];\n                              subject.generatedMap = insertResult.generatedMaps[0];\n                            })];\n\n                          case 3:\n                            _f.sent();\n\n                            if (!(subject.metadata.treeType === \"closure-table\")) return [3\n                            /*break*/\n                            , 5];\n                            return [4\n                            /*yield*/\n                            , new ClosureSubjectExecutor(this_1.queryRunner).insert(subject)];\n\n                          case 4:\n                            _f.sent();\n\n                            return [3\n                            /*break*/\n                            , 7];\n\n                          case 5:\n                            if (!(subject.metadata.treeType === \"materialized-path\")) return [3\n                            /*break*/\n                            , 7];\n                            return [4\n                            /*yield*/\n                            , new MaterializedPathSubjectExecutor(this_1.queryRunner).insert(subject)];\n\n                          case 6:\n                            _f.sent();\n\n                            _f.label = 7;\n\n                          case 7:\n                            return [2\n                            /*return*/\n                            ];\n                        }\n                      });\n                    };\n\n                    _e.label = 5;\n\n                  case 5:\n                    _e.trys.push([5, 10, 11, 12]);\n\n                    singleInsertSubjects_1 = (e_2 = void 0, __values(singleInsertSubjects)), singleInsertSubjects_1_1 = singleInsertSubjects_1.next();\n                    _e.label = 6;\n\n                  case 6:\n                    if (!!singleInsertSubjects_1_1.done) return [3\n                    /*break*/\n                    , 9];\n                    subject = singleInsertSubjects_1_1.value;\n                    return [5\n                    /*yield**/\n                    , _loop_2(subject)];\n\n                  case 7:\n                    _e.sent();\n\n                    _e.label = 8;\n\n                  case 8:\n                    singleInsertSubjects_1_1 = singleInsertSubjects_1.next();\n                    return [3\n                    /*break*/\n                    , 6];\n\n                  case 9:\n                    return [3\n                    /*break*/\n                    , 12];\n\n                  case 10:\n                    e_2_1 = _e.sent();\n                    e_2 = {\n                      error: e_2_1\n                    };\n                    return [3\n                    /*break*/\n                    , 12];\n\n                  case 11:\n                    try {\n                      if (singleInsertSubjects_1_1 && !singleInsertSubjects_1_1.done && (_d = singleInsertSubjects_1.return)) _d.call(singleInsertSubjects_1);\n                    } finally {\n                      if (e_2) throw e_2.error;\n                    }\n\n                    return [7\n                    /*endfinally*/\n                    ];\n\n                  case 12:\n                    subjects.forEach(function (subject) {\n                      if (subject.generatedMap) {\n                        subject.metadata.columns.forEach(function (column) {\n                          var value = column.getEntityValue(subject.generatedMap);\n\n                          if (value !== undefined && value !== null) {\n                            var preparedValue = _this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n\n                            column.setEntityValue(subject.generatedMap, preparedValue);\n                          }\n                        });\n                      }\n                    });\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _c.label = 1;\n\n          case 1:\n            _c.trys.push([1, 6, 7, 8]);\n\n            groupedInsertSubjectKeys_1 = __values(groupedInsertSubjectKeys), groupedInsertSubjectKeys_1_1 = groupedInsertSubjectKeys_1.next();\n            _c.label = 2;\n\n          case 2:\n            if (!!groupedInsertSubjectKeys_1_1.done) return [3\n            /*break*/\n            , 5];\n            groupName = groupedInsertSubjectKeys_1_1.value;\n            return [5\n            /*yield**/\n            , _loop_1(groupName)];\n\n          case 3:\n            _c.sent();\n\n            _c.label = 4;\n\n          case 4:\n            groupedInsertSubjectKeys_1_1 = groupedInsertSubjectKeys_1.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            e_1_1 = _c.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            try {\n              if (groupedInsertSubjectKeys_1_1 && !groupedInsertSubjectKeys_1_1.done && (_b = groupedInsertSubjectKeys_1.return)) _b.call(groupedInsertSubjectKeys_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Updates all given subjects in the database.\n   */\n\n\n  SubjectExecutor.prototype.executeUpdateOperations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var updateSubject, nestedSetSubjects, remainingSubjects, _a, _b, subject, nestedSetPromise;\n\n      var e_3, _c;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            updateSubject = function (subject) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var partialEntity, manager, updateMap, _a, updateQueryBuilder, updateResult, updateGeneratedMap_1;\n\n                var _this = this;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n                      if (!(this.queryRunner instanceof MongoQueryRunner)) return [3\n                      /*break*/\n                      , 2];\n                      partialEntity = OrmUtils.mergeDeep({}, subject.entity);\n\n                      if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                        delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                      }\n\n                      if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                        delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                      }\n\n                      if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                        partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                      }\n\n                      manager = this.queryRunner.manager;\n                      return [4\n                      /*yield*/\n                      , manager.update(subject.metadata.target, subject.identifier, partialEntity)];\n\n                    case 1:\n                      _b.sent();\n\n                      return [3\n                      /*break*/\n                      , 11];\n\n                    case 2:\n                      updateMap = subject.createValueSetAndPopChangeMap();\n                      _a = subject.metadata.treeType;\n\n                      switch (_a) {\n                        case \"nested-set\":\n                          return [3\n                          /*break*/\n                          , 3];\n\n                        case \"closure-table\":\n                          return [3\n                          /*break*/\n                          , 5];\n\n                        case \"materialized-path\":\n                          return [3\n                          /*break*/\n                          , 7];\n                      }\n\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 3:\n                      return [4\n                      /*yield*/\n                      , new NestedSetSubjectExecutor(this.queryRunner).update(subject)];\n\n                    case 4:\n                      _b.sent();\n\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 5:\n                      return [4\n                      /*yield*/\n                      , new ClosureSubjectExecutor(this.queryRunner).update(subject)];\n\n                    case 6:\n                      _b.sent();\n\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 7:\n                      return [4\n                      /*yield*/\n                      , new MaterializedPathSubjectExecutor(this.queryRunner).update(subject)];\n\n                    case 8:\n                      _b.sent();\n\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 9:\n                      updateQueryBuilder = this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n\n                      if (subject.entity) {\n                        updateQueryBuilder.whereEntity(subject.identifier);\n                      } else {\n                        // in this case identifier is just conditions object to update by\n                        updateQueryBuilder.where(subject.identifier);\n                      }\n\n                      return [4\n                      /*yield*/\n                      , updateQueryBuilder.execute()];\n\n                    case 10:\n                      updateResult = _b.sent();\n                      updateGeneratedMap_1 = updateResult.generatedMaps[0];\n\n                      if (updateGeneratedMap_1) {\n                        subject.metadata.columns.forEach(function (column) {\n                          var value = column.getEntityValue(updateGeneratedMap_1);\n\n                          if (value !== undefined && value !== null) {\n                            var preparedValue = _this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n\n                            column.setEntityValue(updateGeneratedMap_1, preparedValue);\n                          }\n                        });\n\n                        if (!subject.generatedMap) {\n                          subject.generatedMap = {};\n                        }\n\n                        Object.assign(subject.generatedMap, updateGeneratedMap_1);\n                      }\n\n                      _b.label = 11;\n\n                    case 11:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            };\n\n            nestedSetSubjects = [];\n            remainingSubjects = [];\n\n            try {\n              for (_a = __values(this.updateSubjects), _b = _a.next(); !_b.done; _b = _a.next()) {\n                subject = _b.value;\n\n                if (subject.metadata.treeType === \"nested-set\") {\n                  nestedSetSubjects.push(subject);\n                } else {\n                  remainingSubjects.push(subject);\n                }\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n\n            nestedSetPromise = new Promise(function (resolve, reject) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var nestedSetSubjects_1, nestedSetSubjects_1_1, subject, error_1, e_4_1;\n\n                var e_4, _a;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0, 7, 8, 9]);\n\n                      nestedSetSubjects_1 = __values(nestedSetSubjects), nestedSetSubjects_1_1 = nestedSetSubjects_1.next();\n                      _b.label = 1;\n\n                    case 1:\n                      if (!!nestedSetSubjects_1_1.done) return [3\n                      /*break*/\n                      , 6];\n                      subject = nestedSetSubjects_1_1.value;\n                      _b.label = 2;\n\n                    case 2:\n                      _b.trys.push([2, 4,, 5]);\n\n                      return [4\n                      /*yield*/\n                      , updateSubject(subject)];\n\n                    case 3:\n                      _b.sent();\n\n                      return [3\n                      /*break*/\n                      , 5];\n\n                    case 4:\n                      error_1 = _b.sent();\n                      reject(error_1);\n                      return [3\n                      /*break*/\n                      , 5];\n\n                    case 5:\n                      nestedSetSubjects_1_1 = nestedSetSubjects_1.next();\n                      return [3\n                      /*break*/\n                      , 1];\n\n                    case 6:\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 7:\n                      e_4_1 = _b.sent();\n                      e_4 = {\n                        error: e_4_1\n                      };\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 8:\n                      try {\n                        if (nestedSetSubjects_1_1 && !nestedSetSubjects_1_1.done && (_a = nestedSetSubjects_1.return)) _a.call(nestedSetSubjects_1);\n                      } finally {\n                        if (e_4) throw e_4.error;\n                      }\n\n                      return [7\n                      /*endfinally*/\n                      ];\n\n                    case 9:\n                      resolve();\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }); // Run all remaning subjects in parallel\n\n            return [4\n            /*yield*/\n            , Promise.all(__spreadArray(__spreadArray([], __read(remainingSubjects.map(updateSubject))), [nestedSetPromise]))];\n\n          case 1:\n            // Run all remaning subjects in parallel\n            _d.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Removes all given subjects from the database.\n   *\n   * todo: we need to apply topological sort here as well\n   */\n\n\n  SubjectExecutor.prototype.executeRemoveOperations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, groupedRemoveSubjects, groupedRemoveSubjectKeys, groupedRemoveSubjectKeys_1, groupedRemoveSubjectKeys_1_1, groupName, subjects, deleteMaps, manager, _b, e_5_1;\n\n      var e_5, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _a = __read(this.groupBulkSubjects(this.removeSubjects, \"delete\"), 2), groupedRemoveSubjects = _a[0], groupedRemoveSubjectKeys = _a[1];\n            _d.label = 1;\n\n          case 1:\n            _d.trys.push([1, 13, 14, 15]);\n\n            groupedRemoveSubjectKeys_1 = __values(groupedRemoveSubjectKeys), groupedRemoveSubjectKeys_1_1 = groupedRemoveSubjectKeys_1.next();\n            _d.label = 2;\n\n          case 2:\n            if (!!groupedRemoveSubjectKeys_1_1.done) return [3\n            /*break*/\n            , 12];\n            groupName = groupedRemoveSubjectKeys_1_1.value;\n            subjects = groupedRemoveSubjects[groupName];\n            deleteMaps = subjects.map(function (subject) {\n              if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n              return subject.identifier;\n            });\n            if (!(this.queryRunner instanceof MongoQueryRunner)) return [3\n            /*break*/\n            , 4];\n            manager = this.queryRunner.manager;\n            return [4\n            /*yield*/\n            , manager.delete(subjects[0].metadata.target, deleteMaps)];\n\n          case 3:\n            _d.sent();\n\n            return [3\n            /*break*/\n            , 11];\n\n          case 4:\n            _b = subjects[0].metadata.treeType;\n\n            switch (_b) {\n              case \"nested-set\":\n                return [3\n                /*break*/\n                , 5];\n\n              case \"closure-table\":\n                return [3\n                /*break*/\n                , 7];\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 5:\n            return [4\n            /*yield*/\n            , new NestedSetSubjectExecutor(this.queryRunner).remove(subjects)];\n\n          case 6:\n            _d.sent();\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            return [4\n            /*yield*/\n            , new ClosureSubjectExecutor(this.queryRunner).remove(subjects)];\n\n          case 8:\n            _d.sent();\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 9:\n            // here we execute our deletion query\n            // we don't need to specify entities and set update entity to true since the only thing query builder\n            // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n            // also, we disable listeners because we call them on our own in persistence layer\n            return [4\n            /*yield*/\n            , this.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute()];\n\n          case 10:\n            // here we execute our deletion query\n            // we don't need to specify entities and set update entity to true since the only thing query builder\n            // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n            // also, we disable listeners because we call them on our own in persistence layer\n            _d.sent();\n\n            _d.label = 11;\n\n          case 11:\n            groupedRemoveSubjectKeys_1_1 = groupedRemoveSubjectKeys_1.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 12:\n            return [3\n            /*break*/\n            , 15];\n\n          case 13:\n            e_5_1 = _d.sent();\n            e_5 = {\n              error: e_5_1\n            };\n            return [3\n            /*break*/\n            , 15];\n\n          case 14:\n            try {\n              if (groupedRemoveSubjectKeys_1_1 && !groupedRemoveSubjectKeys_1_1.done && (_c = groupedRemoveSubjectKeys_1.return)) _c.call(groupedRemoveSubjectKeys_1);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Soft-removes all given subjects in the database.\n   */\n\n\n  SubjectExecutor.prototype.executeSoftRemoveOperations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(this.softRemoveSubjects.map(function (subject) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var partialEntity, manager, softDeleteQueryBuilder, updateResult;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n                      if (!(this.queryRunner instanceof MongoQueryRunner)) return [3\n                      /*break*/\n                      , 2];\n                      partialEntity = OrmUtils.mergeDeep({}, subject.entity);\n\n                      if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                        delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                      }\n\n                      if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                        delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                      }\n\n                      if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                        partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                      }\n\n                      if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                        partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n                      }\n\n                      manager = this.queryRunner.manager;\n                      return [4\n                      /*yield*/\n                      , manager.update(subject.metadata.target, subject.identifier, partialEntity)];\n\n                    case 1:\n                      _a.sent();\n\n                      return [3\n                      /*break*/\n                      , 4];\n\n                    case 2:\n                      softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n\n                      if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier);\n                      } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier);\n                      }\n\n                      return [4\n                      /*yield*/\n                      , softDeleteQueryBuilder.execute()];\n\n                    case 3:\n                      updateResult = _a.sent();\n                      subject.generatedMap = updateResult.generatedMaps[0];\n\n                      if (subject.generatedMap) {\n                        subject.metadata.columns.forEach(function (column) {\n                          var value = column.getEntityValue(subject.generatedMap);\n\n                          if (value !== undefined && value !== null) {\n                            var preparedValue = _this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n\n                            column.setEntityValue(subject.generatedMap, preparedValue);\n                          }\n                        });\n                      }\n\n                      _a.label = 4;\n\n                    case 4:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Recovers all given subjects in the database.\n   */\n\n\n  SubjectExecutor.prototype.executeRecoverOperations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(this.recoverSubjects.map(function (subject) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var partialEntity, manager, softDeleteQueryBuilder, updateResult;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n                      if (!(this.queryRunner instanceof MongoQueryRunner)) return [3\n                      /*break*/\n                      , 2];\n                      partialEntity = OrmUtils.mergeDeep({}, subject.entity);\n\n                      if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                        delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                      }\n\n                      if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                        delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                      }\n\n                      if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                        partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                      }\n\n                      if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                        partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n                      }\n\n                      manager = this.queryRunner.manager;\n                      return [4\n                      /*yield*/\n                      , manager.update(subject.metadata.target, subject.identifier, partialEntity)];\n\n                    case 1:\n                      _a.sent();\n\n                      return [3\n                      /*break*/\n                      , 4];\n\n                    case 2:\n                      softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n\n                      if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier);\n                      } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier);\n                      }\n\n                      return [4\n                      /*yield*/\n                      , softDeleteQueryBuilder.execute()];\n\n                    case 3:\n                      updateResult = _a.sent();\n                      subject.generatedMap = updateResult.generatedMaps[0];\n\n                      if (subject.generatedMap) {\n                        subject.metadata.columns.forEach(function (column) {\n                          var value = column.getEntityValue(subject.generatedMap);\n\n                          if (value !== undefined && value !== null) {\n                            var preparedValue = _this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n\n                            column.setEntityValue(subject.generatedMap, preparedValue);\n                          }\n                        });\n                      }\n\n                      _a.label = 4;\n\n                    case 4:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n\n\n  SubjectExecutor.prototype.updateSpecialColumnsInPersistedEntities = function () {\n    var _this = this; // update inserted entity properties\n\n\n    if (this.insertSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects); // update updated entity properties\n\n    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects); // update soft-removed entity properties\n\n    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects); // update recovered entity properties\n\n    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects); // remove ids from the entities that were removed\n\n    if (this.removeSubjects.length) {\n      this.removeSubjects.forEach(function (subject) {\n        if (!subject.entity) return;\n        subject.metadata.primaryColumns.forEach(function (primaryColumn) {\n          primaryColumn.setEntityValue(subject.entity, undefined);\n        });\n      });\n    } // other post-persist updations\n\n\n    this.allSubjects.forEach(function (subject) {\n      if (!subject.entity) return;\n      subject.metadata.relationIds.forEach(function (relationId) {\n        relationId.setValue(subject.entity);\n      }); // mongo _id remove\n\n      if (_this.queryRunner instanceof MongoQueryRunner) {\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {\n          delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n        }\n      }\n    });\n  };\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n\n\n  SubjectExecutor.prototype.updateSpecialColumnsInInsertedAndUpdatedEntities = function (subjects) {\n    var _this = this;\n\n    subjects.forEach(function (subject) {\n      if (!subject.entity) return; // set values to \"null\" for nullable columns that did not have values\n\n      subject.metadata.columns.forEach(function (column) {\n        // if table inheritance is used make sure this column is not child's column\n        if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(function (metadata) {\n          return metadata.target;\n        }).indexOf(column.target) !== -1) return; // entities does not have virtual columns\n\n        if (column.isVirtual) return; // update nullable columns\n\n        if (column.isNullable) {\n          var columnValue = column.getEntityValue(subject.entity);\n          if (columnValue === undefined) column.setEntityValue(subject.entity, null);\n        } // update relational columns\n\n\n        if (subject.updatedRelationMaps.length > 0) {\n          subject.updatedRelationMaps.forEach(function (updatedRelationMap) {\n            updatedRelationMap.relation.joinColumns.forEach(function (column) {\n              if (column.isVirtual === true) return;\n              column.setEntityValue(subject.entity, updatedRelationMap.value instanceof Object ? column.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n            });\n          });\n        }\n      }); // merge into entity all generated values returned by a database\n\n      if (subject.generatedMap) _this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\n    });\n  };\n  /**\n   * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n   * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n   * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n   * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n   * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n   * That's why we only support bulking in junction tables for those drivers.\n   *\n   * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n   * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n   */\n\n\n  SubjectExecutor.prototype.groupBulkSubjects = function (subjects, type) {\n    var group = {};\n    var keys = [];\n    var groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported();\n    subjects.forEach(function (subject, index) {\n      var key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n\n      if (!group[key]) {\n        group[key] = [subject];\n        keys.push(key);\n      } else {\n        group[key].push(subject);\n      }\n    });\n    return [group, keys];\n  };\n\n  return SubjectExecutor;\n}();\n\nexport { SubjectExecutor };","map":{"version":3,"sources":["../browser/src/persistence/SubjectExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import {SapDriver} from \"../driver/sap/SapDriver\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Subject} from \"./Subject\";\nimport {SubjectTopoligicalSorter} from \"./SubjectTopoligicalSorter\";\nimport {SubjectChangedColumnsComputer} from \"./SubjectChangedColumnsComputer\";\nimport {SubjectWithoutIdentifierError} from \"../error/SubjectWithoutIdentifierError\";\nimport {SubjectRemovedAndUpdatedError} from \"../error/SubjectRemovedAndUpdatedError\";\nimport {MongoQueryRunner} from \"../driver/mongodb/MongoQueryRunner\";\nimport {MongoEntityManager} from \"../entity-manager/MongoEntityManager\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {NestedSetSubjectExecutor} from \"./tree/NestedSetSubjectExecutor\";\nimport {ClosureSubjectExecutor} from \"./tree/ClosureSubjectExecutor\";\nimport {MaterializedPathSubjectExecutor} from \"./tree/MaterializedPathSubjectExecutor\";\nimport {OrmUtils} from \"../util/OrmUtils\";\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner;\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions;\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[];\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be soft-removed.\n     */\n    protected softRemoveSubjects: Subject[] = [];\n\n    /**\n     * Subjects that must be recovered.\n     */\n    protected recoverSubjects: Subject[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(queryRunner: QueryRunner, subjects: Subject[], options?: SaveOptions & RemoveOptions) {\n        this.queryRunner = queryRunner;\n        this.allSubjects = subjects;\n        this.options = options;\n        this.validate();\n        this.recompute();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult | undefined = undefined;\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach(subject => subject.recompute());\n            this.updateSubjects.forEach(subject => subject.recompute());\n            this.removeSubjects.forEach(subject => subject.recompute());\n            this.softRemoveSubjects.forEach(subject => subject.recompute());\n            this.recoverSubjects.forEach(subject => subject.recompute());\n            this.recompute();\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n        await this.executeInsertOperations();\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations();\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n        await this.executeRemoveOperations();\n        // console.timeEnd(\".removal\");\n\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations();\n\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n\n        // execute recover operations\n        await this.executeRecoverOperations();\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        await this.updateSpecialColumnsInPersistedEntities();\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll();\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach(subject => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject);\n        });\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects);\n        this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n        this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n        this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n        this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        return result;\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity!));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        return result;\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName];\n\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps: ObjectLiteral[] = [];\n            const bulkInsertSubjects: Subject[] = [];\n            const singleInsertSubjects: Subject[] = [];\n            if (this.queryRunner.connection.driver instanceof MongoDriver) {\n                subjects.forEach(subject => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n                    }\n\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n                    }\n\n                    subject.createValueSetAndPopChangeMap();\n\n                    bulkInsertSubjects.push(subject);\n                    bulkInsertMaps.push(subject.entity!);\n                });\n            } else if (this.queryRunner.connection.driver instanceof OracleDriver) {\n                subjects.forEach(subject => {\n                    singleInsertSubjects.push(subject);\n                });\n            } else {\n                subjects.forEach(subject => {\n\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver instanceof OracleDriver ||\n                        this.queryRunner.connection.driver instanceof SapDriver) {\n                        singleInsertSubjects.push(subject);\n\n                    } else {\n                        bulkInsertSubjects.push(subject);\n                        bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n                    }\n                });\n            }\n\n            // for mongodb we have a bit different insertion logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                const insertResult = await manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index];\n                    subject.generatedMap = insertResult.generatedMaps[index];\n                    subject.insertedValueSet = bulkInsertMaps[index];\n                });\n\n            } else {\n\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner\n                        .manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(this.options && this.options.reload === false ? false : true)\n                        .callListeners(false)\n                        .execute();\n\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index];\n                        subject.generatedMap = insertResult.generatedMaps[index];\n                        subject.insertedValueSet = bulkInsertMaps[index];\n                    });\n                }\n\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\n\n                        await this.queryRunner\n                            .manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(this.options && this.options.reload === false ? false : true)\n                            .callListeners(false)\n                            .execute()\n                            .then(insertResult => {\n                                subject.identifier = insertResult.identifiers[0];\n                                subject.generatedMap = insertResult.generatedMaps[0];\n                            });\n\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\n\n                        } else if (subject.metadata.treeType === \"materialized-path\") {\n                            await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\n                        }\n                    }\n                }\n            }\n\n            subjects.forEach(subject => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n            });\n        }\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        const updateSubject = async (subject: Subject) => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                const updateMap: ObjectLiteral = subject.createValueSetAndPopChangeMap();\n\n                // for tree tables we execute additional queries\n                switch (subject.metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n\n                    case \"materialized-path\":\n                        await new MaterializedPathSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n                }\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await updateQueryBuilder.execute();\n                let updateGeneratedMap = updateResult.generatedMaps[0];\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(updateGeneratedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(updateGeneratedMap!, preparedValue);\n                        }\n                    });\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {};\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap);\n                }\n            }\n        };\n\n        // Nested sets need to be updated one by one\n        // Split array in two, one with nested set subjects and the other with the remaining subjects\n        const nestedSetSubjects: Subject[] = [];\n        const remainingSubjects: Subject[] = [];\n\n        for (const subject of this.updateSubjects) {\n            if (subject.metadata.treeType === \"nested-set\") {\n                nestedSetSubjects.push(subject);\n            } else {\n                remainingSubjects.push(subject);\n            }\n        }\n\n        // Run nested set updates one by one\n        const nestedSetPromise = new Promise<void>(async (resolve, reject) => {\n            for (const subject of nestedSetSubjects) {\n                try {\n                    await updateSubject(subject);\n                } catch (error) {\n                    reject(error);\n                }\n            }\n            resolve();\n        });\n\n        // Run all remaning subjects in parallel\n        await Promise.all([...remainingSubjects.map(updateSubject), nestedSetPromise]);\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName];\n            const deleteMaps = subjects.map(subject => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject);\n\n                return subject.identifier;\n            });\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const manager = this.queryRunner.manager as MongoEntityManager;\n                await manager.delete(subjects[0].metadata.target, deleteMaps);\n\n            } else {\n                // for tree tables we execute additional queries\n                switch (subjects[0].metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(this.queryRunner).remove(subjects);\n                        break;\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(this.queryRunner).remove(subjects);\n                        break;\n                }\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute();\n            }\n        }\n    }\n\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    protected async executeSoftRemoveOperations(): Promise<void> {\n        await Promise.all(this.softRemoveSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                // here we execute our soft-deletion query\n                // we need to enable entity soft-deletion because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .softDelete()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await softDeleteQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Recovers all given subjects in the database.\n     */\n    protected async executeRecoverOperations(): Promise<void> {\n        await Promise.all(this.recoverSubjects.map(async subject => {\n\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n\n            // for mongodb we have a bit different updation logic\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                const partialEntity = OrmUtils.mergeDeep({}, subject.entity!);\n                if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n\n                if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n\n                if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n\n                if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager;\n\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n\n            } else {\n\n                // here we execute our restory query\n                // we need to enable entity restory because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner\n                    .manager\n                    .createQueryBuilder()\n                    .restore()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\n                    .callListeners(false);\n\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n\n                } else { // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n\n                const updateResult = await softDeleteQueryBuilder.execute();\n                subject.generatedMap = updateResult.generatedMaps[0];\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach(column => {\n                        const value = column.getEntityValue(subject.generatedMap!);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\n                        }\n                    });\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }\n        }));\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n\n        // update soft-removed entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);\n\n        // update recovered entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach(subject => {\n                if (!subject.entity) return;\n\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined);\n                });\n            });\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            subject.metadata.relationIds.forEach(relationId => {\n                relationId.setValue(subject.entity!);\n            });\n\n            // mongo _id remove\n            if (this.queryRunner instanceof MongoQueryRunner) {\n                if (subject.metadata.objectIdColumn\n                    && subject.metadata.objectIdColumn.databaseName\n                    && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n                }\n            }\n        });\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(subjects: Subject[]): void {\n        subjects.forEach(subject => {\n            if (!subject.entity) return;\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach(column => {\n\n                // if table inheritance is used make sure this column is not child's column\n                if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1)\n                    return;\n\n                // entities does not have virtual columns\n                if (column.isVirtual)\n                    return;\n\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity!);\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity!, null);\n                }\n\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach(updatedRelationMap => {\n                        updatedRelationMap.relation.joinColumns.forEach(column => {\n                            if (column.isVirtual === true)\n                                return;\n\n                            column.setEntityValue(subject.entity!, updatedRelationMap.value instanceof Object ? column.referencedColumn!.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n                        });\n                    });\n                }\n            });\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(subject.metadata.target as any, subject.entity, subject.generatedMap);\n        });\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(subjects: Subject[], type: \"insert\" | \"delete\"): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {};\n        const keys: string[] = [];\n        const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported();\n\n        subjects.forEach((subject, index) => {\n            const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n            if (!group[key]) {\n                group[key] = [subject];\n                keys.push(key);\n            } else {\n                group[key].push(subject);\n            }\n        });\n\n        return [group, keys];\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}