{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { Table } from \"../schema-builder/table/Table\";\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\n\nvar DbQueryResultCache =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function DbQueryResultCache(connection) {\n    this.connection = connection;\n    var options = this.connection.driver.options;\n    var cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n    var cacheTableName = cacheOptions.tableName || \"query-result-cache\";\n    this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, options.schema, options.database);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a connection with given cache provider.\n   */\n\n\n  DbQueryResultCache.prototype.connect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Disconnects with given cache provider.\n   */\n\n\n  DbQueryResultCache.prototype.disconnect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n\n\n  DbQueryResultCache.prototype.synchronize = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var driver, tableExist;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryRunner = this.getQueryRunner(queryRunner);\n            driver = this.connection.driver;\n            return [4\n            /*yield*/\n            , queryRunner.hasTable(this.queryResultCacheTable)];\n\n          case 1:\n            tableExist = _a.sent();\n            if (tableExist) return [2\n            /*return*/\n            ];\n            return [4\n            /*yield*/\n            , queryRunner.createTable(new Table({\n              name: this.queryResultCacheTable,\n              columns: [{\n                name: \"id\",\n                isPrimary: true,\n                isNullable: false,\n                type: driver.normalizeType({\n                  type: driver.mappedDataTypes.cacheId\n                }),\n                generationStrategy: \"increment\",\n                isGenerated: true\n              }, {\n                name: \"identifier\",\n                type: driver.normalizeType({\n                  type: driver.mappedDataTypes.cacheIdentifier\n                }),\n                isNullable: true\n              }, {\n                name: \"time\",\n                type: driver.normalizeType({\n                  type: driver.mappedDataTypes.cacheTime\n                }),\n                isPrimary: false,\n                isNullable: false\n              }, {\n                name: \"duration\",\n                type: driver.normalizeType({\n                  type: driver.mappedDataTypes.cacheDuration\n                }),\n                isPrimary: false,\n                isNullable: false\n              }, {\n                name: \"query\",\n                type: driver.normalizeType({\n                  type: driver.mappedDataTypes.cacheQuery\n                }),\n                isPrimary: false,\n                isNullable: false\n              }, {\n                name: \"result\",\n                type: driver.normalizeType({\n                  type: driver.mappedDataTypes.cacheResult\n                }),\n                isNullable: false\n              }]\n            }))];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Caches given query result.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n\n\n  DbQueryResultCache.prototype.getFromCache = function (options, queryRunner) {\n    queryRunner = this.getQueryRunner(queryRunner);\n    var qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, \"cache\");\n\n    if (options.identifier) {\n      return qb.where(qb.escape(\"cache\") + \".\" + qb.escape(\"identifier\") + \" = :identifier\").setParameters({\n        identifier: this.connection.driver instanceof SqlServerDriver ? new MssqlParameter(options.identifier, \"nvarchar\") : options.identifier\n      }).getRawOne();\n    } else if (options.query) {\n      if (this.connection.driver instanceof OracleDriver) {\n        return qb.where(\"dbms_lob.compare(\" + qb.escape(\"cache\") + \".\" + qb.escape(\"query\") + \", :query) = 0\", {\n          query: options.query\n        }).getRawOne();\n      }\n\n      return qb.where(qb.escape(\"cache\") + \".\" + qb.escape(\"query\") + \" = :query\").setParameters({\n        query: this.connection.driver instanceof SqlServerDriver ? new MssqlParameter(options.query, \"nvarchar\") : options.query\n      }).getRawOne();\n    }\n\n    return Promise.resolve(undefined);\n  };\n  /**\n   * Checks if cache is expired or not.\n   */\n\n\n  DbQueryResultCache.prototype.isExpired = function (savedCache) {\n    var duration = typeof savedCache.duration === \"string\" ? parseInt(savedCache.duration) : savedCache.duration;\n    return (typeof savedCache.time === \"string\" ? parseInt(savedCache.time) : savedCache.time) + duration < new Date().getTime();\n  };\n  /**\n   * Stores given query result in the cache.\n   */\n\n\n  DbQueryResultCache.prototype.storeInCache = function (options, savedCache, queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var insertedValues, qb, qb;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryRunner = this.getQueryRunner(queryRunner);\n            insertedValues = options;\n\n            if (this.connection.driver instanceof SqlServerDriver) {\n              // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n              insertedValues = {\n                identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n                time: new MssqlParameter(options.time, \"bigint\"),\n                duration: new MssqlParameter(options.duration, \"int\"),\n                query: new MssqlParameter(options.query, \"nvarchar\"),\n                result: new MssqlParameter(options.result, \"nvarchar\")\n              };\n            }\n\n            if (!(savedCache && savedCache.identifier)) return [3\n            /*break*/\n            , 2];\n            qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);\n            qb.where(qb.escape(\"identifier\") + \" = :condition\", {\n              condition: insertedValues.identifier\n            });\n            return [4\n            /*yield*/\n            , qb.execute()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 2:\n            if (!(savedCache && savedCache.query)) return [3\n            /*break*/\n            , 4];\n            qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);\n\n            if (this.connection.driver instanceof OracleDriver) {\n              qb.where(\"dbms_lob.compare(\\\"query\\\", :condition) = 0\", {\n                condition: insertedValues.query\n              });\n            } else {\n              qb.where(qb.escape(\"query\") + \" = :condition\", {\n                condition: insertedValues.query\n              });\n            }\n\n            return [4\n            /*yield*/\n            , qb.execute()];\n\n          case 3:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            // otherwise insert\n            return [4\n            /*yield*/\n            , queryRunner.manager.createQueryBuilder().insert().into(this.queryResultCacheTable).values(insertedValues).execute()];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Clears everything stored in the cache.\n   */\n\n\n  DbQueryResultCache.prototype.clear = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable)];\n      });\n    });\n  };\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n\n\n  DbQueryResultCache.prototype.remove = function (identifiers, queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(identifiers.map(function (identifier) {\n              var qb = _this.getQueryRunner(queryRunner).manager.createQueryBuilder();\n\n              return qb.delete().from(_this.queryResultCacheTable).where(qb.escape(\"identifier\") + \" = :identifier\", {\n                identifier: identifier\n              }).execute();\n            }))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets a query runner to work with.\n   */\n\n\n  DbQueryResultCache.prototype.getQueryRunner = function (queryRunner) {\n    if (queryRunner) return queryRunner;\n    return this.connection.createQueryRunner();\n  };\n\n  return DbQueryResultCache;\n}();\n\nexport { DbQueryResultCache };","map":{"version":3,"sources":["../browser/src/cache/DbQueryResultCache.ts"],"names":[],"mappings":"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","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {Connection} from \"../connection/Connection\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {PostgresConnectionOptions} from \"../driver/postgres/PostgresConnectionOptions\";\nimport {MssqlParameter} from \"../driver/sqlserver/MssqlParameter\";\nimport {SqlServerConnectionOptions} from \"../driver/sqlserver/SqlServerConnectionOptions\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Table} from \"../schema-builder/table/Table\";\nimport {QueryResultCache} from \"./QueryResultCache\";\nimport {QueryResultCacheOptions} from \"./QueryResultCacheOptions\";\n\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\nexport class DbQueryResultCache implements QueryResultCache {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private queryResultCacheTable: string;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection) {\n\n        const options = <SqlServerConnectionOptions|PostgresConnectionOptions>this.connection.driver.options;\n        const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n        const cacheTableName = cacheOptions.tableName || \"query-result-cache\";\n\n        this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, options.schema, options.database);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a connection with given cache provider.\n     */\n    async connect(): Promise<void> {\n    }\n\n    /**\n     * Disconnects with given cache provider.\n     */\n    async disconnect(): Promise<void> {\n    }\n\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner?: QueryRunner): Promise<void> {\n        queryRunner = this.getQueryRunner(queryRunner);\n        const driver = this.connection.driver;\n        const tableExist = await queryRunner.hasTable(this.queryResultCacheTable); // todo: table name should be configurable\n        if (tableExist)\n            return;\n\n        await queryRunner.createTable(new Table(\n            {\n                name: this.queryResultCacheTable,\n                columns: [\n                    {\n                        name: \"id\",\n                        isPrimary: true,\n                        isNullable: false,\n                        type: driver.normalizeType({type: driver.mappedDataTypes.cacheId}),\n                        generationStrategy: \"increment\",\n                        isGenerated: true\n                    },\n                    {\n                        name: \"identifier\",\n                        type: driver.normalizeType({type: driver.mappedDataTypes.cacheIdentifier}),\n                        isNullable: true\n                    },\n                    {\n                        name: \"time\",\n                        type: driver.normalizeType({type: driver.mappedDataTypes.cacheTime}),\n                        isPrimary: false,\n                        isNullable: false\n                    },\n                    {\n                        name: \"duration\",\n                        type: driver.normalizeType({type: driver.mappedDataTypes.cacheDuration}),\n                        isPrimary: false,\n                        isNullable: false\n                    },\n                    {\n                        name: \"query\",\n                        type: driver.normalizeType({type: driver.mappedDataTypes.cacheQuery}),\n                        isPrimary: false,\n                        isNullable: false\n                    },\n                    {\n                        name: \"result\",\n                        type: driver.normalizeType({type: driver.mappedDataTypes.cacheResult}),\n                        isNullable: false\n                    },\n                ]\n            },\n        ));\n    }\n\n    /**\n     * Caches given query result.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(options: QueryResultCacheOptions, queryRunner?: QueryRunner): Promise<QueryResultCacheOptions|undefined> {\n        queryRunner = this.getQueryRunner(queryRunner);\n        const qb = this.connection\n            .createQueryBuilder(queryRunner)\n            .select()\n            .from(this.queryResultCacheTable, \"cache\");\n\n        if (options.identifier) {\n            return qb\n                .where(`${qb.escape(\"cache\")}.${qb.escape(\"identifier\")} = :identifier`)\n                .setParameters({ identifier: this.connection.driver instanceof SqlServerDriver ? new MssqlParameter(options.identifier, \"nvarchar\") : options.identifier })\n                .getRawOne();\n\n        } else if (options.query) {\n            if (this.connection.driver instanceof OracleDriver) {\n                return qb\n                    .where(`dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\"query\")}, :query) = 0`, { query: options.query })\n                    .getRawOne();\n            }\n\n            return qb\n                .where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`)\n                .setParameters({ query: this.connection.driver instanceof SqlServerDriver ? new MssqlParameter(options.query, \"nvarchar\") : options.query })\n                .getRawOne();\n        }\n\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache: QueryResultCacheOptions): boolean {\n        const duration = typeof savedCache.duration === \"string\" ? parseInt(savedCache.duration) : savedCache.duration;\n        return ((typeof savedCache.time === \"string\" ? parseInt(savedCache.time as any) : savedCache.time)! + duration) < new Date().getTime();\n    }\n\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(options: QueryResultCacheOptions, savedCache: QueryResultCacheOptions|undefined, queryRunner?: QueryRunner): Promise<void> {\n        queryRunner = this.getQueryRunner(queryRunner);\n\n        let insertedValues: ObjectLiteral = options;\n        if (this.connection.driver instanceof SqlServerDriver) { // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n            insertedValues = {\n                identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n                time: new MssqlParameter(options.time, \"bigint\"),\n                duration: new MssqlParameter(options.duration, \"int\"),\n                query: new MssqlParameter(options.query, \"nvarchar\"),\n                result: new MssqlParameter(options.result, \"nvarchar\"),\n            };\n        }\n\n        if (savedCache && savedCache.identifier) { // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues);\n\n            qb.where(`${qb.escape(\"identifier\")} = :condition`, { condition: insertedValues.identifier });\n            await qb.execute();\n\n        } else if (savedCache && savedCache.query) { // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues);\n\n            if (this.connection.driver instanceof OracleDriver) {\n                qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, { condition: insertedValues.query });\n\n            } else {\n                qb.where(`${qb.escape(\"query\")} = :condition`, { condition: insertedValues.query });\n            }\n\n            await qb.execute();\n\n        } else { // otherwise insert\n            await queryRunner.manager\n                .createQueryBuilder()\n                .insert()\n                .into(this.queryResultCacheTable)\n                .values(insertedValues)\n                .execute();\n        }\n    }\n\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner: QueryRunner): Promise<void> {\n        return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);\n    }\n\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(identifiers: string[], queryRunner?: QueryRunner): Promise<void> {\n        await Promise.all(identifiers.map(identifier => {\n            const qb = this.getQueryRunner(queryRunner).manager.createQueryBuilder();\n            return qb.delete()\n                .from(this.queryResultCacheTable)\n                .where(`${qb.escape(\"identifier\")} = :identifier`, {identifier})\n                .execute();\n        }));\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets a query runner to work with.\n     */\n    protected getQueryRunner(queryRunner: QueryRunner|undefined): QueryRunner {\n        if (queryRunner)\n            return queryRunner;\n\n        return this.connection.createQueryRunner();\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}