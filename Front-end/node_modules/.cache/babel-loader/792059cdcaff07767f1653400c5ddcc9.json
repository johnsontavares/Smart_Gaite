{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray } from \"tslib\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\n\nvar RelationRemover =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationRemover(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs remove operation on a relation.\n   */\n\n\n  RelationRemover.prototype.remove = function (value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var relation, ofs, values_1, updateSet_1, parameters_1, conditions_1, condition, junctionMetadata_1, ofs, values, firstColumnValues, secondColumnValues_1, parameters_2, conditions_2, condition;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            relation = this.expressionMap.relationMetadata;\n            if (!relation.isOneToMany) return [3\n            /*break*/\n            , 2];\n            ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            values_1 = Array.isArray(value) ? value : [value];\n            updateSet_1 = {};\n            relation.inverseRelation.joinColumns.forEach(function (column) {\n              updateSet_1[column.propertyName] = null;\n            });\n            parameters_1 = {};\n            conditions_1 = [];\n            ofs.forEach(function (of, ofIndex) {\n              conditions_1.push.apply(conditions_1, __spreadArray([], __read(values_1.map(function (value, valueIndex) {\n                return __spreadArray(__spreadArray([], __read(relation.inverseRelation.joinColumns.map(function (column, columnIndex) {\n                  var parameterName = \"joinColumn_\" + ofIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n                  parameters_1[parameterName] = of instanceof Object ? column.referencedColumn.getEntityValue(of) : of;\n                  return column.propertyPath + \" = :\" + parameterName;\n                }))), __read(relation.inverseRelation.entityMetadata.primaryColumns.map(function (column, columnIndex) {\n                  var parameterName = \"primaryColumn_\" + valueIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n                  parameters_1[parameterName] = value instanceof Object ? column.getEntityValue(value) : value;\n                  return column.propertyPath + \" = :\" + parameterName;\n                }))).join(\" AND \");\n              }))));\n            });\n            condition = conditions_1.map(function (str) {\n              return \"(\" + str + \")\";\n            }).join(\" OR \");\n            if (!condition) return [2\n            /*return*/\n            ];\n            return [4\n            /*yield*/\n            , this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet_1).where(condition).setParameters(parameters_1).execute()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            junctionMetadata_1 = relation.junctionEntityMetadata;\n            ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            values = Array.isArray(value) ? value : [value];\n            firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            secondColumnValues_1 = relation.isManyToManyOwner ? values : ofs;\n            parameters_2 = {};\n            conditions_2 = [];\n            firstColumnValues.forEach(function (firstColumnVal, firstColumnValIndex) {\n              conditions_2.push.apply(conditions_2, __spreadArray([], __read(secondColumnValues_1.map(function (secondColumnVal, secondColumnValIndex) {\n                return __spreadArray(__spreadArray([], __read(junctionMetadata_1.ownerColumns.map(function (column, columnIndex) {\n                  var parameterName = \"firstValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n                  parameters_2[parameterName] = firstColumnVal instanceof Object ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n                  return column.databaseName + \" = :\" + parameterName;\n                }))), __read(junctionMetadata_1.inverseColumns.map(function (column, columnIndex) {\n                  var parameterName = \"secondValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n                  parameters_2[parameterName] = secondColumnVal instanceof Object ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n                  return column.databaseName + \" = :\" + parameterName;\n                }))).join(\" AND \");\n              }))));\n            });\n            condition = conditions_2.map(function (str) {\n              return \"(\" + str + \")\";\n            }).join(\" OR \");\n            return [4\n            /*yield*/\n            , this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata_1.tableName).where(condition).setParameters(parameters_2).execute()];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return RelationRemover;\n}();\n\nexport { RelationRemover };","map":{"version":3,"sources":["../browser/src/query-builder/RelationRemover.ts"],"names":[],"mappings":"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","sourcesContent":["import {QueryBuilder} from \"./QueryBuilder\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryBuilder: QueryBuilder<any>,\n                protected expressionMap: QueryExpressionMap) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs remove operation on a relation.\n     */\n    async remove(value: any|any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata;\n\n        if (relation.isOneToMany) {\n\n            // if (this.expressionMap.of instanceof Array)\n            //     throw new Error(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n\n            // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            const values = Array.isArray(value) ? value : [value];\n\n            const updateSet: ObjectLiteral = {};\n            relation.inverseRelation!.joinColumns.forEach(column => {\n                updateSet[column.propertyName] = null;\n            });\n\n            const parameters: ObjectLiteral = {};\n            const conditions: string[] = [];\n            ofs.forEach((of, ofIndex) => {\n                conditions.push(...values.map((value, valueIndex) => {\n                    return [\n                        ...relation.inverseRelation!.joinColumns.map((column, columnIndex) => {\n                            const parameterName = \"joinColumn_\" + ofIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n                            parameters[parameterName] = of instanceof Object ? column.referencedColumn!.getEntityValue(of) : of;\n                            return `${column.propertyPath} = :${parameterName}`;\n                        }),\n                        ...relation.inverseRelation!.entityMetadata.primaryColumns.map((column, columnIndex) => {\n                            const parameterName = \"primaryColumn_\" + valueIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n                            parameters[parameterName] = value instanceof Object ? column.getEntityValue(value) : value;\n                            return `${column.propertyPath} = :${parameterName}`;\n                        })\n                    ].join(\" AND \");\n                }));\n            });\n            const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n            if (!condition) return;\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute();\n\n        } else { // many to many\n\n            const junctionMetadata = relation.junctionEntityMetadata!;\n            const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n            const values = Array.isArray(value) ? value : [value];\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n\n            const parameters: ObjectLiteral = {};\n            const conditions: string[] = [];\n            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n                conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {\n                    return [\n                        ...junctionMetadata.ownerColumns.map((column, columnIndex) => {\n                            const parameterName = \"firstValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n                            parameters[parameterName] = firstColumnVal instanceof Object ? column.referencedColumn!.getEntityValue(firstColumnVal) : firstColumnVal;\n                            return `${column.databaseName} = :${parameterName}`;\n                        }),\n                        ...junctionMetadata.inverseColumns.map((column, columnIndex) => {\n                            const parameterName = \"secondValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n                            parameters[parameterName] = secondColumnVal instanceof Object ? column.referencedColumn!.getEntityValue(secondColumnVal) : secondColumnVal;\n                            return `${column.databaseName} = :${parameterName}`;\n                        })\n                    ].join(\" AND \");\n                }));\n            });\n            const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .delete()\n                .from(junctionMetadata.tableName)\n                .where(condition)\n                .setParameters(parameters)\n                .execute();\n        }\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}