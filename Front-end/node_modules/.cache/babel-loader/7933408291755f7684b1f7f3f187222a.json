{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { getConnection, getMetadataArgsStorage, MongoRepository, Repository, TreeRepository } from \"../../\";\nexport function Transaction(connectionOrOptions) {\n  return function (target, methodName, descriptor) {\n    // save original method - we gonna need it\n    var originalMethod = descriptor.value; // override method descriptor with proxy method\n\n    descriptor.value = function () {\n      var _this = this;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var connectionName = \"default\";\n      var isolationLevel = undefined;\n\n      if (connectionOrOptions) {\n        if (typeof connectionOrOptions === \"string\") {\n          connectionName = connectionOrOptions;\n        } else {\n          if (connectionOrOptions.connectionName) {\n            connectionName = connectionOrOptions.connectionName;\n          }\n\n          if (connectionOrOptions.isolation) {\n            isolationLevel = connectionOrOptions.isolation;\n          }\n        }\n      }\n\n      var transactionCallback = function (entityManager) {\n        var argsWithInjectedTransactionManagerAndRepositories; // filter all @TransactionManager() and @TransactionRepository() decorator usages for this method\n\n        var transactionEntityManagerMetadatas = getMetadataArgsStorage().filterTransactionEntityManagers(target.constructor, methodName).reverse();\n        var transactionRepositoryMetadatas = getMetadataArgsStorage().filterTransactionRepository(target.constructor, methodName).reverse(); // if there are @TransactionManager() decorator usages the inject them\n\n        if (transactionEntityManagerMetadatas.length > 0) {\n          argsWithInjectedTransactionManagerAndRepositories = __spreadArray([], __read(args)); // replace method params with injection of transactionEntityManager\n\n          transactionEntityManagerMetadatas.forEach(function (metadata) {\n            argsWithInjectedTransactionManagerAndRepositories.splice(metadata.index, 0, entityManager);\n          });\n        } else if (transactionRepositoryMetadatas.length === 0) {\n          // otherwise if there's no transaction repositories in use, inject it as a first parameter\n          argsWithInjectedTransactionManagerAndRepositories = __spreadArray([entityManager], __read(args));\n        } else {\n          argsWithInjectedTransactionManagerAndRepositories = __spreadArray([], __read(args));\n        } // for every usage of @TransactionRepository decorator\n\n\n        transactionRepositoryMetadatas.forEach(function (metadata) {\n          var repositoryInstance; // detect type of the repository and get instance from transaction entity manager\n\n          switch (metadata.repositoryType) {\n            case Repository:\n              repositoryInstance = entityManager.getRepository(metadata.entityType);\n              break;\n\n            case MongoRepository:\n              repositoryInstance = entityManager.getMongoRepository(metadata.entityType);\n              break;\n\n            case TreeRepository:\n              repositoryInstance = entityManager.getTreeRepository(metadata.entityType);\n              break;\n            // if not the TypeORM's ones, there must be custom repository classes\n\n            default:\n              repositoryInstance = entityManager.getCustomRepository(metadata.repositoryType);\n          } // replace method param with injection of repository instance\n\n\n          argsWithInjectedTransactionManagerAndRepositories.splice(metadata.index, 0, repositoryInstance);\n        });\n        return originalMethod.apply(_this, argsWithInjectedTransactionManagerAndRepositories);\n      };\n\n      if (isolationLevel) {\n        return getConnection(connectionName).manager.transaction(isolationLevel, transactionCallback);\n      } else {\n        return getConnection(connectionName).manager.transaction(transactionCallback);\n      }\n    };\n  };\n}","map":{"version":3,"sources":["../browser/src/decorator/transaction/Transaction.ts"],"names":[],"mappings":"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","sourcesContent":["import {getConnection, getMetadataArgsStorage, MongoRepository, Repository, TreeRepository, EntityManager} from \"../../\";\nimport {TransactionOptions} from \"../options/TransactionOptions\";\nimport {IsolationLevel} from \"../../driver/types/IsolationLevel\";\n\n/**\n * Wraps some method into the transaction.\n *\n * Method result will return a promise if this decorator applied.\n * All database operations in the wrapped method should be executed using entity managed passed\n * as a first parameter into the wrapped method.\n *\n * If you want to control at what position in your method parameters entity manager should be injected,\n * then use @TransactionManager() decorator.\n *\n * If you want to use repositories instead of bare entity manager,\n * then use @TransactionRepository() decorator.\n */\nexport function Transaction(connectionName?: string): MethodDecorator;\nexport function Transaction(options?: TransactionOptions): MethodDecorator;\nexport function Transaction(connectionOrOptions?: string | TransactionOptions): MethodDecorator {\n    return function (target: Object, methodName: string, descriptor: PropertyDescriptor) {\n\n        // save original method - we gonna need it\n        const originalMethod = descriptor.value;\n\n        // override method descriptor with proxy method\n        descriptor.value = function(...args: any[]) {\n            let connectionName = \"default\";\n            let isolationLevel: IsolationLevel | undefined = undefined;\n            if (connectionOrOptions) {\n                if (typeof connectionOrOptions === \"string\") {\n                    connectionName = connectionOrOptions;\n                } else {\n                    if (connectionOrOptions.connectionName) {\n                        connectionName = connectionOrOptions.connectionName;\n                    }\n                    if (connectionOrOptions.isolation) {\n                        isolationLevel = connectionOrOptions.isolation;\n                    }\n                }\n            }\n\n            const transactionCallback = (entityManager: EntityManager) => {\n                let argsWithInjectedTransactionManagerAndRepositories: any[];\n\n                // filter all @TransactionManager() and @TransactionRepository() decorator usages for this method\n                const transactionEntityManagerMetadatas = getMetadataArgsStorage()\n                    .filterTransactionEntityManagers(target.constructor, methodName)\n                    .reverse();\n                const transactionRepositoryMetadatas = getMetadataArgsStorage()\n                    .filterTransactionRepository(target.constructor, methodName)\n                    .reverse();\n\n                // if there are @TransactionManager() decorator usages the inject them\n                if (transactionEntityManagerMetadatas.length > 0) {\n                    argsWithInjectedTransactionManagerAndRepositories = [...args];\n                    // replace method params with injection of transactionEntityManager\n                    transactionEntityManagerMetadatas.forEach(metadata => {\n                        argsWithInjectedTransactionManagerAndRepositories.splice(metadata.index, 0, entityManager);\n                    });\n\n                } else if (transactionRepositoryMetadatas.length === 0) { // otherwise if there's no transaction repositories in use, inject it as a first parameter\n                    argsWithInjectedTransactionManagerAndRepositories = [entityManager, ...args];\n\n                } else {\n                    argsWithInjectedTransactionManagerAndRepositories = [...args];\n                }\n\n                // for every usage of @TransactionRepository decorator\n                transactionRepositoryMetadatas.forEach(metadata => {\n                    let repositoryInstance: any;\n\n                    // detect type of the repository and get instance from transaction entity manager\n                    switch (metadata.repositoryType) {\n                        case Repository:\n                            repositoryInstance = entityManager.getRepository(metadata.entityType!);\n                            break;\n                        case MongoRepository:\n                            repositoryInstance = entityManager.getMongoRepository(metadata.entityType!);\n                            break;\n                        case TreeRepository:\n                            repositoryInstance = entityManager.getTreeRepository(metadata.entityType!);\n                            break;\n                        // if not the TypeORM's ones, there must be custom repository classes\n                        default:\n                            repositoryInstance = entityManager.getCustomRepository(metadata.repositoryType);\n                    }\n\n                    // replace method param with injection of repository instance\n                    argsWithInjectedTransactionManagerAndRepositories.splice(metadata.index, 0, repositoryInstance);\n                });\n\n                return originalMethod.apply(this, argsWithInjectedTransactionManagerAndRepositories);\n            };\n            if (isolationLevel) {\n                return getConnection(connectionName).manager.transaction(isolationLevel, transactionCallback);\n            } else {\n                return getConnection(connectionName).manager.transaction(transactionCallback);\n            }\n        };\n    };\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}