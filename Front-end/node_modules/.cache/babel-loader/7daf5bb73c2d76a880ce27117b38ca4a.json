{"ast":null,"code":"import { __values } from \"tslib\";\nimport { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\";\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\n\nvar EntitySchemaTransformer =\n/** @class */\nfunction () {\n  function EntitySchemaTransformer() {} // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Transforms entity schema into new metadata args storage object.\n   */\n\n\n  EntitySchemaTransformer.prototype.transform = function (schemas) {\n    var metadataArgsStorage = new MetadataArgsStorage();\n    schemas.forEach(function (entitySchema) {\n      var options = entitySchema.options; // add table metadata args from the schema\n\n      var tableMetadata = {\n        target: options.target || options.name,\n        name: options.tableName,\n        database: options.database,\n        schema: options.schema,\n        type: options.type || \"regular\",\n        orderBy: options.orderBy,\n        synchronize: options.synchronize,\n        expression: options.expression\n      };\n      metadataArgsStorage.tables.push(tableMetadata); // add columns metadata args from the schema\n\n      Object.keys(options.columns).forEach(function (columnName) {\n        var column = options.columns[columnName];\n        var mode = \"regular\";\n        if (column.createDate) mode = \"createDate\";\n        if (column.updateDate) mode = \"updateDate\";\n        if (column.deleteDate) mode = \"deleteDate\";\n        if (column.version) mode = \"version\";\n        if (column.treeChildrenCount) mode = \"treeChildrenCount\";\n        if (column.treeLevel) mode = \"treeLevel\";\n        if (column.objectId) mode = \"objectId\";\n        var columnAgrs = {\n          target: options.target || options.name,\n          mode: mode,\n          propertyName: columnName,\n          options: {\n            type: column.type,\n            name: column.objectId ? \"_id\" : column.name,\n            length: column.length,\n            width: column.width,\n            nullable: column.nullable,\n            readonly: column.readonly,\n            update: column.update,\n            select: column.select,\n            insert: column.insert,\n            primary: column.primary,\n            unique: column.unique,\n            comment: column.comment,\n            default: column.default,\n            onUpdate: column.onUpdate,\n            precision: column.precision,\n            scale: column.scale,\n            zerofill: column.zerofill,\n            unsigned: column.unsigned,\n            charset: column.charset,\n            collation: column.collation,\n            enum: column.enum,\n            asExpression: column.asExpression,\n            generatedType: column.generatedType,\n            hstoreType: column.hstoreType,\n            array: column.array,\n            transformer: column.transformer,\n            spatialFeatureType: column.spatialFeatureType,\n            srid: column.srid\n          }\n        };\n        metadataArgsStorage.columns.push(columnAgrs);\n\n        if (column.generated) {\n          var generationArgs = {\n            target: options.target || options.name,\n            propertyName: columnName,\n            strategy: typeof column.generated === \"string\" ? column.generated : \"increment\"\n          };\n          metadataArgsStorage.generations.push(generationArgs);\n        }\n\n        if (column.unique) metadataArgsStorage.uniques.push({\n          target: options.target || options.name,\n          columns: [columnName]\n        });\n      }); // add relation metadata args from the schema\n\n      if (options.relations) {\n        Object.keys(options.relations).forEach(function (relationName) {\n          var e_1, _a;\n\n          var relationSchema = options.relations[relationName];\n          var relation = {\n            target: options.target || options.name,\n            propertyName: relationName,\n            relationType: relationSchema.type,\n            isLazy: relationSchema.lazy || false,\n            type: relationSchema.target,\n            inverseSideProperty: relationSchema.inverseSide,\n            isTreeParent: relationSchema.treeParent,\n            isTreeChildren: relationSchema.treeChildren,\n            options: {\n              eager: relationSchema.eager || false,\n              cascade: relationSchema.cascade,\n              nullable: relationSchema.nullable,\n              onDelete: relationSchema.onDelete,\n              onUpdate: relationSchema.onUpdate,\n              deferrable: relationSchema.deferrable,\n              primary: relationSchema.primary,\n              persistence: relationSchema.persistence,\n              orphanedRowAction: relationSchema.orphanedRowAction\n            }\n          };\n          metadataArgsStorage.relations.push(relation); // add join column\n\n          if (relationSchema.joinColumn) {\n            if (typeof relationSchema.joinColumn === \"boolean\") {\n              var joinColumn = {\n                target: options.target || options.name,\n                propertyName: relationName\n              };\n              metadataArgsStorage.joinColumns.push(joinColumn);\n            } else {\n              var joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];\n\n              try {\n                for (var joinColumnsOptions_1 = __values(joinColumnsOptions), joinColumnsOptions_1_1 = joinColumnsOptions_1.next(); !joinColumnsOptions_1_1.done; joinColumnsOptions_1_1 = joinColumnsOptions_1.next()) {\n                  var joinColumnOption = joinColumnsOptions_1_1.value;\n                  var joinColumn = {\n                    target: options.target || options.name,\n                    propertyName: relationName,\n                    name: joinColumnOption.name,\n                    referencedColumnName: joinColumnOption.referencedColumnName\n                  };\n                  metadataArgsStorage.joinColumns.push(joinColumn);\n                }\n              } catch (e_1_1) {\n                e_1 = {\n                  error: e_1_1\n                };\n              } finally {\n                try {\n                  if (joinColumnsOptions_1_1 && !joinColumnsOptions_1_1.done && (_a = joinColumnsOptions_1.return)) _a.call(joinColumnsOptions_1);\n                } finally {\n                  if (e_1) throw e_1.error;\n                }\n              }\n            }\n          } // add join table\n\n\n          if (relationSchema.joinTable) {\n            if (typeof relationSchema.joinTable === \"boolean\") {\n              var joinTable = {\n                target: options.target || options.name,\n                propertyName: relationName\n              };\n              metadataArgsStorage.joinTables.push(joinTable);\n            } else {\n              var joinTable = {\n                target: options.target || options.name,\n                propertyName: relationName,\n                name: relationSchema.joinTable.name,\n                database: relationSchema.joinTable.database,\n                schema: relationSchema.joinTable.schema,\n                joinColumns: relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns,\n                inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns\n              };\n              metadataArgsStorage.joinTables.push(joinTable);\n            }\n          }\n        });\n      } // add index metadata args from the schema\n\n\n      if (options.indices) {\n        options.indices.forEach(function (index) {\n          var indexAgrs = {\n            target: options.target || options.name,\n            name: index.name,\n            unique: index.unique === true ? true : false,\n            spatial: index.spatial === true ? true : false,\n            fulltext: index.fulltext === true ? true : false,\n            parser: index.parser,\n            synchronize: index.synchronize === false ? false : true,\n            where: index.where,\n            sparse: index.sparse,\n            columns: index.columns\n          };\n          metadataArgsStorage.indices.push(indexAgrs);\n        });\n      } // add unique metadata args from the schema\n\n\n      if (options.uniques) {\n        options.uniques.forEach(function (unique) {\n          var uniqueAgrs = {\n            target: options.target || options.name,\n            name: unique.name,\n            columns: unique.columns\n          };\n          metadataArgsStorage.uniques.push(uniqueAgrs);\n        });\n      } // add check metadata args from the schema\n\n\n      if (options.checks) {\n        options.checks.forEach(function (check) {\n          var checkAgrs = {\n            target: options.target || options.name,\n            name: check.name,\n            expression: check.expression\n          };\n          metadataArgsStorage.checks.push(checkAgrs);\n        });\n      } // add exclusion metadata args from the schema\n\n\n      if (options.exclusions) {\n        options.exclusions.forEach(function (exclusion) {\n          var exclusionArgs = {\n            target: options.target || options.name,\n            name: exclusion.name,\n            expression: exclusion.expression\n          };\n          metadataArgsStorage.exclusions.push(exclusionArgs);\n        });\n      }\n    });\n    return metadataArgsStorage;\n  };\n\n  return EntitySchemaTransformer;\n}();\n\nexport { EntitySchemaTransformer };","map":{"version":3,"sources":["../browser/src/entity-schema/EntitySchemaTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["import {EntitySchema} from \"./EntitySchema\";\nimport {MetadataArgsStorage} from \"../metadata-args/MetadataArgsStorage\";\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\nimport {ColumnMetadataArgs} from \"../metadata-args/ColumnMetadataArgs\";\nimport {IndexMetadataArgs} from \"../metadata-args/IndexMetadataArgs\";\nimport {RelationMetadataArgs} from \"../metadata-args/RelationMetadataArgs\";\nimport {JoinColumnMetadataArgs} from \"../metadata-args/JoinColumnMetadataArgs\";\nimport {JoinTableMetadataArgs} from \"../metadata-args/JoinTableMetadataArgs\";\nimport {JoinTableOptions} from \"../decorator/options/JoinTableOptions\";\nimport {JoinTableMultipleColumnsOptions} from \"../decorator/options/JoinTableMultipleColumnsOptions\";\nimport {ColumnMode} from \"../metadata-args/types/ColumnMode\";\nimport {GeneratedMetadataArgs} from \"../metadata-args/GeneratedMetadataArgs\";\nimport {UniqueMetadataArgs} from \"../metadata-args/UniqueMetadataArgs\";\nimport {CheckMetadataArgs} from \"../metadata-args/CheckMetadataArgs\";\nimport {ExclusionMetadataArgs} from \"../metadata-args/ExclusionMetadataArgs\";\n\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\nexport class EntitySchemaTransformer {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Transforms entity schema into new metadata args storage object.\n     */\n    transform(schemas: EntitySchema<any>[]): MetadataArgsStorage {\n        const metadataArgsStorage = new MetadataArgsStorage();\n\n        schemas.forEach(entitySchema => {\n            const options = entitySchema.options;\n\n            // add table metadata args from the schema\n            const tableMetadata: TableMetadataArgs = {\n                target: options.target || options.name,\n                name: options.tableName,\n                database: options.database,\n                schema: options.schema,\n                type: options.type || \"regular\",\n                orderBy: options.orderBy,\n                synchronize: options.synchronize,\n                expression: options.expression\n            };\n            metadataArgsStorage.tables.push(tableMetadata);\n\n            // add columns metadata args from the schema\n            Object.keys(options.columns).forEach(columnName => {\n                const column = options.columns[columnName]!;\n                let mode: ColumnMode = \"regular\";\n                if (column.createDate)\n                    mode = \"createDate\";\n                if (column.updateDate)\n                    mode = \"updateDate\";\n                if (column.deleteDate)\n                    mode = \"deleteDate\";\n                if (column.version)\n                    mode = \"version\";\n                if (column.treeChildrenCount)\n                    mode = \"treeChildrenCount\";\n                if (column.treeLevel)\n                    mode = \"treeLevel\";\n                if (column.objectId)\n                    mode = \"objectId\";\n\n                const columnAgrs: ColumnMetadataArgs = {\n                    target: options.target || options.name,\n                    mode: mode,\n                    propertyName: columnName,\n                    options: {\n                        type: column.type,\n                        name: column.objectId ? \"_id\" : column.name,\n                        length: column.length,\n                        width: column.width,\n                        nullable: column.nullable,\n                        readonly: column.readonly,\n                        update: column.update,\n                        select: column.select,\n                        insert: column.insert,\n                        primary: column.primary,\n                        unique: column.unique,\n                        comment: column.comment,\n                        default: column.default,\n                        onUpdate: column.onUpdate,\n                        precision: column.precision,\n                        scale: column.scale,\n                        zerofill: column.zerofill,\n                        unsigned: column.unsigned,\n                        charset: column.charset,\n                        collation: column.collation,\n                        enum: column.enum,\n                        asExpression: column.asExpression,\n                        generatedType: column.generatedType,\n                        hstoreType: column.hstoreType,\n                        array: column.array,\n                        transformer: column.transformer,\n                        spatialFeatureType: column.spatialFeatureType,\n                        srid: column.srid\n                    }\n                };\n                metadataArgsStorage.columns.push(columnAgrs);\n\n                if (column.generated) {\n                    const generationArgs: GeneratedMetadataArgs = {\n                        target: options.target || options.name,\n                        propertyName: columnName,\n                        strategy: typeof column.generated === \"string\" ? column.generated : \"increment\"\n                    };\n                    metadataArgsStorage.generations.push(generationArgs);\n                }\n\n                if (column.unique)\n                    metadataArgsStorage.uniques.push({ target: options.target || options.name, columns: [columnName] });\n            });\n\n            // add relation metadata args from the schema\n            if (options.relations) {\n                Object.keys(options.relations).forEach(relationName => {\n                    const relationSchema = options.relations![relationName]!;\n                    const relation: RelationMetadataArgs = {\n                        target: options.target || options.name,\n                        propertyName: relationName,\n                        relationType: relationSchema.type,\n                        isLazy: relationSchema.lazy || false,\n                        type: relationSchema.target,\n                        inverseSideProperty: relationSchema.inverseSide,\n                        isTreeParent: relationSchema.treeParent,\n                        isTreeChildren: relationSchema.treeChildren,\n                        options: {\n                            eager: relationSchema.eager || false,\n                            cascade: relationSchema.cascade,\n                            nullable: relationSchema.nullable,\n                            onDelete: relationSchema.onDelete,\n                            onUpdate: relationSchema.onUpdate,\n                            deferrable: relationSchema.deferrable,\n                            primary: relationSchema.primary,\n                            persistence: relationSchema.persistence,\n                            orphanedRowAction: relationSchema.orphanedRowAction\n                        }\n                    };\n\n                    metadataArgsStorage.relations.push(relation);\n\n                    // add join column\n                    if (relationSchema.joinColumn) {\n                        if (typeof relationSchema.joinColumn === \"boolean\") {\n                            const joinColumn: JoinColumnMetadataArgs = {\n                                target: options.target || options.name,\n                                propertyName: relationName\n                            };\n                            metadataArgsStorage.joinColumns.push(joinColumn);\n                        } else {\n                            const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];\n\n                            for (const joinColumnOption of joinColumnsOptions) {\n                                const joinColumn: JoinColumnMetadataArgs = {\n                                    target: options.target || options.name,\n                                    propertyName: relationName,\n                                    name: joinColumnOption.name,\n                                    referencedColumnName: joinColumnOption.referencedColumnName\n                                };\n                                metadataArgsStorage.joinColumns.push(joinColumn);\n                            }\n                        }\n                    }\n\n                    // add join table\n                    if (relationSchema.joinTable) {\n                        if (typeof relationSchema.joinTable === \"boolean\") {\n                            const joinTable: JoinTableMetadataArgs = {\n                                target: options.target || options.name,\n                                propertyName: relationName\n                            };\n                            metadataArgsStorage.joinTables.push(joinTable);\n                        } else {\n                            const joinTable: JoinTableMetadataArgs = {\n                                target: options.target || options.name,\n                                propertyName: relationName,\n                                name: relationSchema.joinTable.name,\n                                database: relationSchema.joinTable.database,\n                                schema: relationSchema.joinTable.schema,\n                                joinColumns: ((relationSchema.joinTable as JoinTableOptions).joinColumn ? [(relationSchema.joinTable as JoinTableOptions).joinColumn!] : (relationSchema.joinTable as JoinTableMultipleColumnsOptions).joinColumns) as any,\n                                inverseJoinColumns: ((relationSchema.joinTable as JoinTableOptions).inverseJoinColumn ? [(relationSchema.joinTable as JoinTableOptions).inverseJoinColumn!] : (relationSchema.joinTable as JoinTableMultipleColumnsOptions).inverseJoinColumns) as any,\n                            };\n                            metadataArgsStorage.joinTables.push(joinTable);\n                        }\n                    }\n                });\n            }\n\n            // add index metadata args from the schema\n            if (options.indices) {\n                options.indices.forEach(index => {\n                    const indexAgrs: IndexMetadataArgs = {\n                        target: options.target || options.name,\n                        name: index.name,\n                        unique: index.unique === true ? true : false,\n                        spatial: index.spatial === true ? true : false,\n                        fulltext: index.fulltext === true ? true : false,\n                        parser: index.parser,\n                        synchronize: index.synchronize === false ? false : true,\n                        where: index.where,\n                        sparse: index.sparse,\n                        columns: index.columns\n                    };\n                    metadataArgsStorage.indices.push(indexAgrs);\n                });\n            }\n\n            // add unique metadata args from the schema\n            if (options.uniques) {\n                options.uniques.forEach(unique => {\n                    const uniqueAgrs: UniqueMetadataArgs = {\n                        target: options.target || options.name,\n                        name: unique.name,\n                        columns: unique.columns\n                    };\n                    metadataArgsStorage.uniques.push(uniqueAgrs);\n                });\n            }\n\n            // add check metadata args from the schema\n            if (options.checks) {\n                options.checks.forEach(check => {\n                    const checkAgrs: CheckMetadataArgs = {\n                        target: options.target || options.name,\n                        name: check.name,\n                        expression: check.expression\n                    };\n                    metadataArgsStorage.checks.push(checkAgrs);\n                });\n            }\n\n            // add exclusion metadata args from the schema\n            if (options.exclusions) {\n                options.exclusions.forEach(exclusion => {\n                    const exclusionArgs: ExclusionMetadataArgs = {\n                        target: options.target || options.name,\n                        name: exclusion.name,\n                        expression: exclusion.expression\n                    };\n                    metadataArgsStorage.exclusions.push(exclusionArgs);\n                });\n            }\n\n        });\n\n        return metadataArgsStorage;\n    }\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}