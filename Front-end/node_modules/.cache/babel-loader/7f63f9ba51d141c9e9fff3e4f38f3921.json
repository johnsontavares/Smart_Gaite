{"ast":null,"code":"import { __values } from \"tslib\";\nimport { QueryBuilderUtils } from \"./QueryBuilderUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\n\nvar JoinAttribute =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function JoinAttribute(connection, queryExpressionMap, joinAttribute) {\n    this.connection = connection;\n    this.queryExpressionMap = queryExpressionMap;\n    this.isSelectedEvaluated = false;\n    this.relationEvaluated = false;\n    ObjectUtils.assign(this, joinAttribute || {});\n  }\n\n  Object.defineProperty(JoinAttribute.prototype, \"isMany\", {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    get: function () {\n      if (this.isMappingMany !== undefined) return this.isMappingMany;\n      if (this.relation) return this.relation.isManyToMany || this.relation.isOneToMany;\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"isSelected\", {\n    /**\n     * Indicates if this join is selected.\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this.isSelectedEvaluated) {\n        var getValue = function () {\n          var e_1, _a;\n\n          var _loop_1 = function (select) {\n            if (select.selection === _this.alias.name) return {\n              value: true\n            };\n            if (_this.metadata && !!_this.metadata.columns.find(function (column) {\n              return select.selection === _this.alias.name + \".\" + column.propertyPath;\n            })) return {\n              value: true\n            };\n          };\n\n          try {\n            for (var _b = __values(_this.queryExpressionMap.selects), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var select = _c.value;\n\n              var state_1 = _loop_1(select);\n\n              if (typeof state_1 === \"object\") return state_1.value;\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n\n          return false;\n        };\n\n        this.isSelectedCache = getValue();\n        this.isSelectedEvaluated = true;\n      }\n\n      return this.isSelectedCache;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"tablePath\", {\n    /**\n     * Name of the table which we should join.\n     */\n    get: function () {\n      return this.metadata ? this.metadata.tablePath : this.entityOrProperty;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"parentAlias\", {\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get: function () {\n      if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n      return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"relationPropertyPath\", {\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get: function () {\n      if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n      return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"relation\", {\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this.relationEvaluated) {\n        var getValue = function () {\n          if (!QueryBuilderUtils.isAliasProperty(_this.entityOrProperty)) return undefined;\n\n          var relationOwnerSelection = _this.queryExpressionMap.findAliasByName(_this.parentAlias);\n\n          var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(_this.relationPropertyPath);\n\n          if (relation) {\n            return relation;\n          }\n\n          if (relationOwnerSelection.metadata.parentEntityMetadata) {\n            relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(_this.relationPropertyPath);\n\n            if (relation) {\n              return relation;\n            }\n          }\n\n          throw new Error(\"Relation with property path \" + _this.relationPropertyPath + \" in entity was not found.\");\n        };\n\n        this.relationCache = getValue.bind(this)();\n        this.relationEvaluated = true;\n      }\n\n      return this.relationCache;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"metadata\", {\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get: function () {\n      // entityOrProperty is relation, e.g. \"post.category\"\n      if (this.relation) return this.relation.inverseEntityMetadata; // entityOrProperty is Entity class\n\n      if (this.connection.hasMetadata(this.entityOrProperty)) return this.connection.getMetadata(this.entityOrProperty);\n      return undefined;\n      /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n               // first try to find entity with such name, this is needed when entity does not have a target class,\n          // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n          const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n          if (metadata)\n              return metadata;\n               // check if we have entity with such table name, and use its metadata if found\n          return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n      }*/\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"junctionAlias\", {\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get: function () {\n      if (!this.relation) throw new Error(\"Cannot get junction table for join without relation.\");\n      return this.relation.isOwning ? this.parentAlias + \"_\" + this.alias.name : this.alias.name + \"_\" + this.parentAlias;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"mapToPropertyParentAlias\", {\n    get: function () {\n      if (!this.mapToProperty) return undefined;\n      return this.mapToProperty.split(\".\")[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JoinAttribute.prototype, \"mapToPropertyPropertyName\", {\n    get: function () {\n      if (!this.mapToProperty) return undefined;\n      return this.mapToProperty.split(\".\")[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return JoinAttribute;\n}();\n\nexport { JoinAttribute };","map":{"version":3,"sources":["../browser/src/query-builder/JoinAttribute.ts"],"names":[],"mappings":"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","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {Connection} from \"../connection/Connection\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {QueryBuilderUtils} from \"./QueryBuilderUtils\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {Alias} from \"./Alias\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\n\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Join direction.\n     */\n    direction: \"LEFT\"|\"INNER\";\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias: Alias;\n\n    /**\n     * Joined table, entity target, or relation in \"post.category\" format.\n     */\n    entityOrProperty: Function|string;\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    condition?: string;\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty?: string;\n\n    /**\n     * Indicates if user maps one or many objects from the join.\n     */\n    isMappingMany?: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection,\n                private queryExpressionMap: QueryExpressionMap,\n                joinAttribute?: JoinAttribute) {\n        ObjectUtils.assign(this, joinAttribute || {});\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get isMany(): boolean {\n        if (this.isMappingMany !== undefined)\n            return this.isMappingMany;\n\n        if (this.relation)\n            return this.relation.isManyToMany || this.relation.isOneToMany;\n\n        return false;\n    }\n\n\n    isSelectedCache: boolean;\n    isSelectedEvaluated: boolean = false;\n    /**\n     * Indicates if this join is selected.\n     */\n    get isSelected(): boolean {\n        if (!this.isSelectedEvaluated) {\n            let getValue = () => {\n                for (const select of this.queryExpressionMap.selects) {\n                    if (select.selection === this.alias.name)\n                        return true;\n\n                    if (this.metadata && !!this.metadata.columns.find(column => select.selection === this.alias.name + \".\" + column.propertyPath))\n                        return true;\n                }\n\n                return false;\n            };\n            this.isSelectedCache = getValue();\n            this.isSelectedEvaluated = true;\n        }\n        return this.isSelectedCache;\n\n    }\n\n    /**\n     * Name of the table which we should join.\n     */\n    get tablePath(): string {\n        return this.metadata ? this.metadata.tablePath : this.entityOrProperty as string;\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string|undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined;\n\n        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string|undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined;\n\n        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n    }\n\n    relationCache: RelationMetadata|undefined;\n    relationEvaluated: boolean = false;\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get relation(): RelationMetadata | undefined {\n        if (!this.relationEvaluated) {\n            let getValue = () => {\n                if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n                    return undefined;\n\n                const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias!);\n                let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath!);\n\n                if (relation) {\n                    return relation;\n                }\n\n                if (relationOwnerSelection.metadata.parentEntityMetadata) {\n                    relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath!);\n                    if (relation) {\n                        return relation;\n                    }\n                }\n\n                throw new Error(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n            };\n            this.relationCache = getValue.bind(this)();\n            this.relationEvaluated = true;\n        }\n        return this.relationCache;\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata|undefined {\n\n        // entityOrProperty is relation, e.g. \"post.category\"\n        if (this.relation)\n            return this.relation.inverseEntityMetadata;\n\n        // entityOrProperty is Entity class\n        if (this.connection.hasMetadata(this.entityOrProperty))\n            return this.connection.getMetadata(this.entityOrProperty);\n\n        return undefined;\n\n        /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n\n            // first try to find entity with such name, this is needed when entity does not have a target class,\n            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n            if (metadata)\n                return metadata;\n\n            // check if we have entity with such table name, and use its metadata if found\n            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n        }*/\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        if (!this.relation)\n            throw new Error(`Cannot get junction table for join without relation.`);\n\n        return this.relation.isOwning ? this.parentAlias + \"_\" + this.alias.name : this.alias.name + \"_\" + this.parentAlias;\n    }\n\n    get mapToPropertyParentAlias(): string|undefined {\n        if (!this.mapToProperty)\n            return undefined;\n\n        return this.mapToProperty!.split(\".\")[0];\n    }\n\n    get mapToPropertyPropertyName(): string|undefined {\n        if (!this.mapToProperty)\n            return undefined;\n\n        return this.mapToProperty!.split(\".\")[1];\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}