{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\n\nvar RelationIdLoader =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationIdLoader(connection, queryRunner, relationIdAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationIdAttributes = relationIdAttributes;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  RelationIdLoader.prototype.load = function (rawEntities) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promises;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        promises = this.relationIdAttributes.map(function (relationIdAttr) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var duplicates_1, results, relation_1, joinColumns_1, table, tableName, tableAlias_1, duplicates_2, parameters_1, condition, qb_1, results, relation, joinColumns_2, inverseJoinColumns_1, junctionAlias_1, inverseSideTableName, inverseSideTableAlias_1, junctionTableName, mappedColumns, parameters_2, duplicates_3, joinColumnConditions, inverseJoinColumnCondition_1, condition, qb_2, results;\n\n            var _this = this;\n\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  if (!(relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner)) return [3\n                  /*break*/\n                  , 1]; // example: Post and Tag\n                  // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n                  // we expect it to load id of tag\n\n                  if (relationIdAttr.queryBuilderFactory) throw new Error(\"Additional condition can not be used with ManyToOne or OneToOne owner relations.\");\n                  duplicates_1 = [];\n                  results = rawEntities.map(function (rawEntity) {\n                    var result = {};\n                    var duplicateParts = [];\n                    relationIdAttr.relation.joinColumns.forEach(function (joinColumn) {\n                      result[joinColumn.databaseName] = _this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(_this.connection.driver, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);\n                      var duplicatePart = joinColumn.databaseName + \":\" + result[joinColumn.databaseName];\n\n                      if (duplicateParts.indexOf(duplicatePart) === -1) {\n                        duplicateParts.push(duplicatePart);\n                      }\n                    });\n                    relationIdAttr.relation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {\n                      result[primaryColumn.databaseName] = _this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(_this.connection.driver, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);\n                      var duplicatePart = primaryColumn.databaseName + \":\" + result[primaryColumn.databaseName];\n\n                      if (duplicateParts.indexOf(duplicatePart) === -1) {\n                        duplicateParts.push(duplicatePart);\n                      }\n                    });\n                    duplicateParts.sort();\n                    var duplicate = duplicateParts.join(\"::\");\n\n                    if (duplicates_1.indexOf(duplicate) !== -1) {\n                      return null;\n                    }\n\n                    duplicates_1.push(duplicate);\n                    return result;\n                  }).filter(function (v) {\n                    return v;\n                  });\n                  return [2\n                  /*return*/\n                  , {\n                    relationIdAttribute: relationIdAttr,\n                    results: results\n                  }];\n\n                case 1:\n                  if (!(relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner)) return [3\n                  /*break*/\n                  , 3];\n                  relation_1 = relationIdAttr.relation;\n                  joinColumns_1 = relation_1.isOwning ? relation_1.joinColumns : relation_1.inverseRelation.joinColumns;\n                  table = relation_1.inverseEntityMetadata.target;\n                  tableName = relation_1.inverseEntityMetadata.tableName;\n                  tableAlias_1 = relationIdAttr.alias || tableName;\n                  duplicates_2 = [];\n                  parameters_1 = {};\n                  condition = rawEntities.map(function (rawEntity, index) {\n                    var duplicateParts = [];\n                    var parameterParts = {};\n                    var queryPart = joinColumns_1.map(function (joinColumn) {\n                      var parameterName = joinColumn.databaseName + index;\n                      var parameterValue = rawEntity[DriverUtils.buildAlias(_this.connection.driver, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n                      var duplicatePart = tableAlias_1 + \":\" + joinColumn.propertyPath + \":\" + parameterValue;\n\n                      if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                        return \"\";\n                      }\n\n                      duplicateParts.push(duplicatePart);\n                      parameterParts[parameterName] = parameterValue;\n                      return tableAlias_1 + \".\" + joinColumn.propertyPath + \" = :\" + parameterName;\n                    }).filter(function (v) {\n                      return v;\n                    }).join(\" AND \");\n                    duplicateParts.sort();\n                    var duplicate = duplicateParts.join(\"::\");\n\n                    if (duplicates_2.indexOf(duplicate) !== -1) {\n                      return \"\";\n                    }\n\n                    duplicates_2.push(duplicate);\n                    Object.assign(parameters_1, parameterParts);\n                    return queryPart;\n                  }).filter(function (v) {\n                    return v;\n                  }).map(function (condition) {\n                    return \"(\" + condition + \")\";\n                  }).join(\" OR \"); // ensure we won't perform redundant queries for joined data which was not found in selection\n                  // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n                  if (!condition) return [2\n                  /*return*/\n                  , {\n                    relationIdAttribute: relationIdAttr,\n                    results: []\n                  }];\n                  qb_1 = this.connection.createQueryBuilder(this.queryRunner);\n                  joinColumns_1.forEach(function (joinColumn) {\n                    qb_1.addSelect(tableAlias_1 + \".\" + joinColumn.propertyPath, joinColumn.databaseName);\n                  });\n                  relation_1.inverseRelation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {\n                    qb_1.addSelect(tableAlias_1 + \".\" + primaryColumn.propertyPath, primaryColumn.databaseName);\n                  });\n                  qb_1.from(table, tableAlias_1).where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n                  .setParameters(parameters_1); // apply condition (custom query builder factory)\n\n                  if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb_1);\n                  return [4\n                  /*yield*/\n                  , qb_1.getRawMany()];\n\n                case 2:\n                  results = _a.sent();\n                  results.forEach(function (result) {\n                    joinColumns_1.forEach(function (column) {\n                      result[column.databaseName] = _this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n                    });\n                    relation_1.inverseRelation.entityMetadata.primaryColumns.forEach(function (column) {\n                      result[column.databaseName] = _this.connection.driver.prepareHydratedValue(result[column.databaseName], column);\n                    });\n                  });\n                  return [2\n                  /*return*/\n                  , {\n                    relationIdAttribute: relationIdAttr,\n                    results: results\n                  }];\n\n                case 3:\n                  relation = relationIdAttr.relation;\n                  joinColumns_2 = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;\n                  inverseJoinColumns_1 = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;\n                  junctionAlias_1 = relationIdAttr.junctionAlias;\n                  inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;\n                  inverseSideTableAlias_1 = relationIdAttr.alias || inverseSideTableName;\n                  junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;\n                  mappedColumns = rawEntities.map(function (rawEntity) {\n                    return joinColumns_2.reduce(function (map, joinColumn) {\n                      map[joinColumn.propertyPath] = rawEntity[DriverUtils.buildAlias(_this.connection.driver, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n                      return map;\n                    }, {});\n                  }); // ensure we won't perform redundant queries for joined data which was not found in selection\n                  // example: if post.category was not found in db then no need to execute query for category.imageIds\n\n                  if (mappedColumns.length === 0) return [2\n                  /*return*/\n                  , {\n                    relationIdAttribute: relationIdAttr,\n                    results: []\n                  }];\n                  parameters_2 = {};\n                  duplicates_3 = [];\n                  joinColumnConditions = mappedColumns.map(function (mappedColumn, index) {\n                    var duplicateParts = [];\n                    var parameterParts = {};\n                    var queryPart = Object.keys(mappedColumn).map(function (key) {\n                      var parameterName = key + index;\n                      var parameterValue = mappedColumn[key];\n                      var duplicatePart = junctionAlias_1 + \":\" + key + \":\" + parameterValue;\n\n                      if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                        return \"\";\n                      }\n\n                      duplicateParts.push(duplicatePart);\n                      parameterParts[parameterName] = parameterValue;\n                      return junctionAlias_1 + \".\" + key + \" = :\" + parameterName;\n                    }).filter(function (s) {\n                      return s;\n                    }).join(\" AND \");\n                    duplicateParts.sort();\n                    var duplicate = duplicateParts.join(\"::\");\n\n                    if (duplicates_3.indexOf(duplicate) !== -1) {\n                      return \"\";\n                    }\n\n                    duplicates_3.push(duplicate);\n                    Object.assign(parameters_2, parameterParts);\n                    return queryPart;\n                  }).filter(function (s) {\n                    return s;\n                  });\n                  inverseJoinColumnCondition_1 = inverseJoinColumns_1.map(function (joinColumn) {\n                    return junctionAlias_1 + \".\" + joinColumn.propertyPath + \" = \" + inverseSideTableAlias_1 + \".\" + joinColumn.referencedColumn.propertyPath;\n                  }).join(\" AND \");\n                  condition = joinColumnConditions.map(function (condition) {\n                    return \"(\" + condition + \" AND \" + inverseJoinColumnCondition_1 + \")\";\n                  }).join(\" OR \");\n                  qb_2 = this.connection.createQueryBuilder(this.queryRunner);\n                  inverseJoinColumns_1.forEach(function (joinColumn) {\n                    qb_2.addSelect(junctionAlias_1 + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias_1 + \".\" + joinColumn.propertyPath);\n                  });\n                  joinColumns_2.forEach(function (joinColumn) {\n                    qb_2.addSelect(junctionAlias_1 + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias_1 + \".\" + joinColumn.propertyPath);\n                  });\n                  qb_2.from(inverseSideTableName, inverseSideTableAlias_1).innerJoin(junctionTableName, junctionAlias_1, condition).setParameters(parameters_2); // apply condition (custom query builder factory)\n\n                  if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb_2);\n                  return [4\n                  /*yield*/\n                  , qb_2.getRawMany()];\n\n                case 4:\n                  results = _a.sent();\n                  results.forEach(function (result) {\n                    __spreadArray(__spreadArray([], __read(joinColumns_2)), __read(inverseJoinColumns_1)).forEach(function (column) {\n                      result[column.databaseName] = _this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n                    });\n                  });\n                  return [2\n                  /*return*/\n                  , {\n                    relationIdAttribute: relationIdAttr,\n                    results: results\n                  }];\n              }\n            });\n          });\n        });\n        return [2\n        /*return*/\n        , Promise.all(promises)];\n      });\n    });\n  };\n\n  return RelationIdLoader;\n}();\n\nexport { RelationIdLoader };","map":{"version":3,"sources":["../browser/src/query-builder/relation-id/RelationIdLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import {RelationIdAttribute} from \"./RelationIdAttribute\";\nimport {Connection} from \"../../connection/Connection\";\nimport {RelationIdLoadResult} from \"./RelationIdLoadResult\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {DriverUtils} from \"../../driver/DriverUtils\";\n\nexport class RelationIdLoader {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunner: QueryRunner|undefined,\n                protected relationIdAttributes: RelationIdAttribute[]) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationIdLoadResult[]> {\n\n        const promises = this.relationIdAttributes.map(async relationIdAttr => {\n\n            if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {\n                // example: Post and Tag\n                // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n                // we expect it to load id of tag\n\n                if (relationIdAttr.queryBuilderFactory)\n                    throw new Error(\"Additional condition can not be used with ManyToOne or OneToOne owner relations.\");\n\n                const duplicates: Array<string> = [];\n                const results = rawEntities.map(rawEntity => {\n                    const result: ObjectLiteral = {};\n                    const duplicateParts: Array<string> = [];\n                    relationIdAttr.relation.joinColumns.forEach(joinColumn => {\n                        result[joinColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn!);\n                        const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;\n                        if (duplicateParts.indexOf(duplicatePart) === -1) {\n                            duplicateParts.push(duplicatePart);\n                        }\n                    });\n\n                    relationIdAttr.relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n                        result[primaryColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);\n                        const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;\n                        if (duplicateParts.indexOf(duplicatePart) === -1) {\n                            duplicateParts.push(duplicatePart);\n                        }\n                    });\n\n                    duplicateParts.sort();\n                    const duplicate = duplicateParts.join(\"::\");\n                    if (duplicates.indexOf(duplicate) !== -1) {\n                        return null;\n                    }\n                    duplicates.push(duplicate);\n                    return result;\n                }).filter(v => v);\n\n                return {\n                    relationIdAttribute: relationIdAttr,\n                    results: results\n                };\n\n            } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {\n                // example: Post and Category\n                // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // we expect it to load array of category ids\n\n                const relation = relationIdAttr.relation; // \"post.categories\"\n                const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation!.joinColumns;\n                const table = relation.inverseEntityMetadata.target; // category\n                const tableName = relation.inverseEntityMetadata.tableName; // category\n                const tableAlias = relationIdAttr.alias || tableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n\n                const duplicates: Array<string> = [];\n                const parameters: ObjectLiteral = {};\n                const condition = rawEntities.map((rawEntity, index) => {\n                    const duplicateParts: Array<string> = [];\n                    const parameterParts: ObjectLiteral = {};\n                    const queryPart = joinColumns.map(joinColumn => {\n                        const parameterName = joinColumn.databaseName + index;\n                        const parameterValue = rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, joinColumn.referencedColumn!.databaseName)];\n                        const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;\n                        if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                            return \"\";\n                        }\n                        duplicateParts.push(duplicatePart);\n                        parameterParts[parameterName] = parameterValue;\n                        return tableAlias + \".\" + joinColumn.propertyPath + \" = :\" + parameterName;\n                    }).filter(v => v).join(\" AND \");\n                    duplicateParts.sort();\n                    const duplicate = duplicateParts.join(\"::\");\n                    if (duplicates.indexOf(duplicate) !== -1) {\n                        return \"\";\n                    }\n                    duplicates.push(duplicate);\n                    Object.assign(parameters, parameterParts);\n                    return queryPart;\n                }).filter(v => v).map(condition => \"(\" + condition + \")\")\n                    .join(\" OR \");\n\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (!condition)\n                    return { relationIdAttribute: relationIdAttr, results: [] };\n\n                // generate query:\n                // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n\n                joinColumns.forEach(joinColumn => {\n                    qb.addSelect(tableAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName);\n                });\n\n                relation.inverseRelation!.entityMetadata.primaryColumns.forEach(primaryColumn => {\n                    qb.addSelect(tableAlias + \".\" + primaryColumn.propertyPath, primaryColumn.databaseName);\n                });\n\n                qb.from(table, tableAlias)\n                    .where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n                    .setParameters(parameters);\n\n                // apply condition (custom query builder factory)\n                if (relationIdAttr.queryBuilderFactory)\n                    relationIdAttr.queryBuilderFactory(qb);\n\n                const results = await qb.getRawMany();\n                results.forEach(result => {\n                    joinColumns.forEach(column => {\n                        result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn!);\n                    });\n                    relation.inverseRelation!.entityMetadata.primaryColumns.forEach(column => {\n                        result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column);\n                    });\n                });\n\n                return {\n                    relationIdAttribute: relationIdAttr,\n                    results\n                };\n\n            } else {\n                // many-to-many\n                // example: Post and Category\n                // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                // we expect it to load array of post ids\n\n                const relation = relationIdAttr.relation;\n                const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation!.inverseJoinColumns;\n                const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\n                const junctionAlias = relationIdAttr.junctionAlias;\n                const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;\n                const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;\n                const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata!.tableName : relation.inverseRelation!.junctionEntityMetadata!.tableName;\n\n\n                const mappedColumns = rawEntities.map(rawEntity => {\n                    return joinColumns.reduce((map, joinColumn) => {\n                        map[joinColumn.propertyPath] = rawEntity[DriverUtils.buildAlias(this.connection.driver, relationIdAttr.parentAlias, joinColumn.referencedColumn!.databaseName)];\n                        return map;\n                    }, {} as ObjectLiteral);\n                });\n\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (mappedColumns.length === 0)\n                    return { relationIdAttribute: relationIdAttr, results: [] };\n\n                const parameters: ObjectLiteral = {};\n                const duplicates: Array<string> = [];\n                const joinColumnConditions = mappedColumns.map((mappedColumn, index) => {\n                    const duplicateParts: Array<string> = [];\n                    const parameterParts: ObjectLiteral = {};\n                    const queryPart = Object.keys(mappedColumn).map(key => {\n                        const parameterName = key + index;\n                        const parameterValue = mappedColumn[key];\n                        const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;\n                        if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                            return \"\";\n                        }\n                        duplicateParts.push(duplicatePart);\n                        parameterParts[parameterName] = parameterValue;\n                        return junctionAlias + \".\" + key + \" = :\" + parameterName;\n                    }).filter(s => s).join(\" AND \");\n                    duplicateParts.sort();\n                    const duplicate = duplicateParts.join(\"::\");\n                    if (duplicates.indexOf(duplicate) !== -1) {\n                        return \"\";\n                    }\n                    duplicates.push(duplicate);\n                    Object.assign(parameters, parameterParts);\n                    return queryPart;\n                }).filter(s => s);\n\n                const inverseJoinColumnCondition = inverseJoinColumns.map(joinColumn => {\n                    return junctionAlias + \".\" + joinColumn.propertyPath + \" = \" + inverseSideTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                const condition = joinColumnConditions.map(condition => {\n                    return \"(\" + condition + \" AND \" + inverseJoinColumnCondition + \")\";\n                }).join(\" OR \");\n\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n\n                inverseJoinColumns.forEach(joinColumn => {\n                    qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName)\n                    .addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n                });\n\n                joinColumns.forEach(joinColumn => {\n                    qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName)\n                    .addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n                });\n\n                qb.from(inverseSideTableName, inverseSideTableAlias)\n                    .innerJoin(junctionTableName, junctionAlias, condition)\n                    .setParameters(parameters);\n\n                // apply condition (custom query builder factory)\n                if (relationIdAttr.queryBuilderFactory)\n                    relationIdAttr.queryBuilderFactory(qb);\n\n                const results = await qb.getRawMany();\n                results.forEach(result => {\n                    [...joinColumns, ...inverseJoinColumns].forEach(column => {\n                        result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn!);\n                    });\n                });\n\n                return {\n                    relationIdAttribute: relationIdAttr,\n                    results\n                };\n            }\n        });\n\n        return Promise.all(promises);\n    }\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}