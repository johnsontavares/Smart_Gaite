{"ast":null,"code":"import { __awaiter, __extends, __generator, __read, __spreadArray } from \"tslib\";\nimport { SapDriver } from \"../driver/sap/SapDriver\";\nimport { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { AbstractSqliteDriver } from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport { CockroachDriver } from \"../driver/cockroachdb/CockroachDriver\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nvar SelectQueryBuilder =\n/** @class */\nfunction (_super) {\n  __extends(SelectQueryBuilder, _super);\n\n  function SelectQueryBuilder() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated sql query without parameters being replaced.\n   */\n\n\n  SelectQueryBuilder.prototype.getQuery = function () {\n    var sql = this.createComment();\n    sql += this.createSelectExpression();\n    sql += this.createJoinExpression();\n    sql += this.createWhereExpression();\n    sql += this.createGroupByExpression();\n    sql += this.createHavingExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitOffsetExpression();\n    sql += this.createLockExpression();\n    sql = sql.trim();\n    if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\";\n    return sql;\n  }; // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a subquery - query that can be used inside other queries.\n   */\n\n\n  SelectQueryBuilder.prototype.subQuery = function () {\n    var qb = this.createQueryBuilder();\n    qb.expressionMap.subQuery = true;\n    qb.expressionMap.parentQueryBuilder = this;\n    return qb;\n  };\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n\n\n  SelectQueryBuilder.prototype.select = function (selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(function (selection) {\n        return {\n          selection: selection\n        };\n      });\n    } else if (selection instanceof Function) {\n      var subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    }\n\n    return this;\n  };\n  /**\n   * Adds new selection to the SELECT query.\n   */\n\n\n  SelectQueryBuilder.prototype.addSelect = function (selection, selectionAliasName) {\n    if (!selection) return this;\n\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(function (selection) {\n        return {\n          selection: selection\n        };\n      }));\n    } else if (selection instanceof Function) {\n      var subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects.push({\n        selection: selection,\n        aliasName: selectionAliasName\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Set max execution time.\n   * @param milliseconds\n   */\n\n\n  SelectQueryBuilder.prototype.maxExecutionTime = function (milliseconds) {\n    this.expressionMap.maxExecutionTime = milliseconds;\n    return this;\n  };\n  /**\n   * Sets whether the selection is DISTINCT.\n   */\n\n\n  SelectQueryBuilder.prototype.distinct = function (distinct) {\n    if (distinct === void 0) {\n      distinct = true;\n    }\n\n    this.expressionMap.selectDistinct = distinct;\n    return this;\n  };\n  /**\n   * Sets the distinct on clause for Postgres.\n   */\n\n\n  SelectQueryBuilder.prototype.distinctOn = function (distinctOn) {\n    this.expressionMap.selectDistinctOn = distinctOn;\n    return this;\n  };\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   * Removes all previously set from-s.\n   */\n\n\n  SelectQueryBuilder.prototype.from = function (entityTarget, aliasName) {\n    var mainAlias = this.createFromAlias(entityTarget, aliasName);\n    this.expressionMap.setMainAlias(mainAlias);\n    return this;\n  };\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n\n\n  SelectQueryBuilder.prototype.addFrom = function (entityTarget, aliasName) {\n    var alias = this.createFromAlias(entityTarget, aliasName);\n    if (!this.expressionMap.mainAlias) this.expressionMap.setMainAlias(alias);\n    return this;\n  };\n  /**\n   * INNER JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.innerJoin = function (entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n    return this;\n  };\n  /**\n   * LEFT JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.leftJoin = function (entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n    return this;\n  };\n  /**\n   * INNER JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.innerJoinAndSelect = function (entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.addSelect(alias);\n    this.innerJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  };\n  /**\n   * LEFT JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.leftJoinAndSelect = function (entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.addSelect(alias);\n    this.leftJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  };\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.innerJoinAndMapMany = function (mapToProperty, entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  };\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.innerJoinAndMapOne = function (mapToProperty, entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n    return this;\n  };\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.leftJoinAndMapMany = function (mapToProperty, entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  };\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.leftJoinAndMapOne = function (mapToProperty, entityOrProperty, alias, condition, parameters) {\n    if (condition === void 0) {\n      condition = \"\";\n    }\n\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n    return this;\n  };\n  /**\n   * LEFT JOINs relation id and maps it into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.loadRelationIdAndMap = function (mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {\n    var relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n    relationIdAttribute.mapToProperty = mapToProperty;\n    relationIdAttribute.relationName = relationName;\n    if (typeof aliasNameOrOptions === \"string\") relationIdAttribute.alias = aliasNameOrOptions;\n    if (aliasNameOrOptions instanceof Object && aliasNameOrOptions.disableMixedMap) relationIdAttribute.disableMixedMap = true;\n    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n    if (relationIdAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationIdAttribute.junctionAlias,\n        metadata: relationIdAttribute.relation.junctionEntityMetadata\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Counts number of entities of entity's relation and maps the value into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n\n\n  SelectQueryBuilder.prototype.loadRelationCountAndMap = function (mapToProperty, relationName, aliasName, queryBuilderFactory) {\n    var relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n    relationCountAttribute.mapToProperty = mapToProperty;\n    relationCountAttribute.relationName = relationName;\n    relationCountAttribute.alias = aliasName;\n    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n    this.expressionMap.createAlias({\n      type: \"other\",\n      name: relationCountAttribute.junctionAlias\n    });\n\n    if (relationCountAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationCountAttribute.junctionAlias,\n        metadata: relationCountAttribute.relation.junctionEntityMetadata\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Loads all relation ids for all relations of the selected entity.\n   * All relation ids will be mapped to relation property themself.\n   * If array of strings is given then loads only relation ids of the given properties.\n   */\n\n\n  SelectQueryBuilder.prototype.loadAllRelationIds = function (options) {\n    var _this = this;\n\n    this.expressionMap.mainAlias.metadata.relations.forEach(function (relation) {\n      if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1) return;\n\n      _this.loadRelationIdAndMap(_this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, _this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, options);\n    });\n    return this;\n  };\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  SelectQueryBuilder.prototype.where = function (where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n\n    var condition = this.computeWhereParameter(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  };\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  SelectQueryBuilder.prototype.andWhere = function (where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.computeWhereParameter(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  };\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  SelectQueryBuilder.prototype.orWhere = function (where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.computeWhereParameter(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  };\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n\n\n  SelectQueryBuilder.prototype.whereInIds = function (ids) {\n    return this.where(this.createWhereIdsExpression(ids));\n  };\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n\n\n  SelectQueryBuilder.prototype.andWhereInIds = function (ids) {\n    return this.andWhere(this.createWhereIdsExpression(ids));\n  };\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n\n\n  SelectQueryBuilder.prototype.orWhereInIds = function (ids) {\n    return this.orWhere(this.createWhereIdsExpression(ids));\n  };\n  /**\n   * Sets HAVING condition in the query builder.\n   * If you had previously HAVING expression defined,\n   * calling this function will override previously set HAVING conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  SelectQueryBuilder.prototype.having = function (having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"simple\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  };\n  /**\n   * Adds new AND HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  SelectQueryBuilder.prototype.andHaving = function (having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"and\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  };\n  /**\n   * Adds new OR HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n\n\n  SelectQueryBuilder.prototype.orHaving = function (having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"or\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  };\n  /**\n   * Sets GROUP BY condition in the query builder.\n   * If you had previously GROUP BY expression defined,\n   * calling this function will override previously set GROUP BY conditions.\n   */\n\n\n  SelectQueryBuilder.prototype.groupBy = function (groupBy) {\n    if (groupBy) {\n      this.expressionMap.groupBys = [groupBy];\n    } else {\n      this.expressionMap.groupBys = [];\n    }\n\n    return this;\n  };\n  /**\n   * Adds GROUP BY condition in the query builder.\n   */\n\n\n  SelectQueryBuilder.prototype.addGroupBy = function (groupBy) {\n    this.expressionMap.groupBys.push(groupBy);\n    return this;\n  };\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n\n\n  SelectQueryBuilder.prototype.orderBy = function (sort, order, nulls) {\n    var _a, _b;\n\n    if (order === void 0) {\n      order = \"ASC\";\n    }\n\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new Error(\"SelectQueryBuilder.addOrderBy \\\"order\\\" can accept only \\\"ASC\\\" and \\\"DESC\\\" values.\");\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new Error(\"SelectQueryBuilder.addOrderBy \\\"nulls\\\" can accept only \\\"NULLS FIRST\\\" and \\\"NULLS LAST\\\" values.\");\n\n    if (sort) {\n      if (sort instanceof Object) {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = (_a = {}, _a[sort] = {\n            order: order,\n            nulls: nulls\n          }, _a);\n        } else {\n          this.expressionMap.orderBys = (_b = {}, _b[sort] = order, _b);\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n\n    return this;\n  };\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n\n\n  SelectQueryBuilder.prototype.addOrderBy = function (sort, order, nulls) {\n    if (order === void 0) {\n      order = \"ASC\";\n    }\n\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new Error(\"SelectQueryBuilder.addOrderBy \\\"order\\\" can accept only \\\"ASC\\\" and \\\"DESC\\\" values.\");\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new Error(\"SelectQueryBuilder.addOrderBy \\\"nulls\\\" can accept only \\\"NULLS FIRST\\\" and \\\"NULLS LAST\\\" values.\");\n\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order: order,\n        nulls: nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n\n    return this;\n  };\n  /**\n   * Set's LIMIT - maximum number of rows to be selected.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use instead take method instead.\n   */\n\n\n  SelectQueryBuilder.prototype.limit = function (limit) {\n    this.expressionMap.limit = this.normalizeNumber(limit);\n    if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit)) throw new Error(\"Provided \\\"limit\\\" value is not a number. Please provide a numeric value.\");\n    return this;\n  };\n  /**\n   * Set's OFFSET - selection offset.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use instead skip method instead.\n   */\n\n\n  SelectQueryBuilder.prototype.offset = function (offset) {\n    this.expressionMap.offset = this.normalizeNumber(offset);\n    if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset)) throw new Error(\"Provided \\\"offset\\\" value is not a number. Please provide a numeric value.\");\n    return this;\n  };\n  /**\n   * Sets maximal number of entities to take.\n   */\n\n\n  SelectQueryBuilder.prototype.take = function (take) {\n    this.expressionMap.take = this.normalizeNumber(take);\n    if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take)) throw new Error(\"Provided \\\"take\\\" value is not a number. Please provide a numeric value.\");\n    return this;\n  };\n  /**\n   * Sets number of entities to skip.\n   */\n\n\n  SelectQueryBuilder.prototype.skip = function (skip) {\n    this.expressionMap.skip = this.normalizeNumber(skip);\n    if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip)) throw new Error(\"Provided \\\"skip\\\" value is not a number. Please provide a numeric value.\");\n    return this;\n  };\n  /**\n   * Sets locking mode.\n   */\n\n\n  SelectQueryBuilder.prototype.setLock = function (lockMode, lockVersion, lockTables) {\n    this.expressionMap.lockMode = lockMode;\n    this.expressionMap.lockVersion = lockVersion;\n    this.expressionMap.lockTables = lockTables;\n    return this;\n  };\n  /**\n   * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n   */\n\n\n  SelectQueryBuilder.prototype.withDeleted = function () {\n    this.expressionMap.withDeleted = true;\n    return this;\n  };\n  /**\n   * Gets first raw result returned by execution of generated query builder sql.\n   */\n\n\n  SelectQueryBuilder.prototype.getRawOne = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getRawMany()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()[0]];\n        }\n      });\n    });\n  };\n  /**\n   * Gets all raw results returned by execution of generated query builder sql.\n   */\n\n\n  SelectQueryBuilder.prototype.getRawMany = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, transactionStartedByUs, results, error_1, rollbackError_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n            this.expressionMap.queryEntity = false;\n            queryRunner = this.obtainQueryRunner();\n            transactionStartedByUs = false;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7, 12, 15]);\n\n            if (!(this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 2:\n            _a.sent();\n\n            transactionStartedByUs = true;\n            _a.label = 3;\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.loadRawResults(queryRunner)];\n\n          case 4:\n            results = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            , results];\n\n          case 7:\n            error_1 = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 11];\n            _a.label = 8;\n\n          case 8:\n            _a.trys.push([8, 10,, 11]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 9:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 11];\n\n          case 10:\n            rollbackError_1 = _a.sent();\n            return [3\n            /*break*/\n            , 11];\n\n          case 11:\n            throw error_1;\n\n          case 12:\n            if (!(queryRunner !== this.queryRunner)) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 13:\n            _a.sent();\n\n            _a.label = 14;\n\n          case 14:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n\n\n  SelectQueryBuilder.prototype.getRawAndEntities = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, transactionStartedByUs, results, error_2, rollbackError_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryRunner = this.obtainQueryRunner();\n            transactionStartedByUs = false;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7, 12, 15]);\n\n            if (!(this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 2:\n            _a.sent();\n\n            transactionStartedByUs = true;\n            _a.label = 3;\n\n          case 3:\n            this.expressionMap.queryEntity = true;\n            return [4\n            /*yield*/\n            , this.executeEntitiesAndRawResults(queryRunner)];\n\n          case 4:\n            results = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            , results];\n\n          case 7:\n            error_2 = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 11];\n            _a.label = 8;\n\n          case 8:\n            _a.trys.push([8, 10,, 11]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 9:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 11];\n\n          case 10:\n            rollbackError_2 = _a.sent();\n            return [3\n            /*break*/\n            , 11];\n\n          case 11:\n            throw error_2;\n\n          case 12:\n            if (!(queryRunner !== this.queryRunner)) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 13:\n            _a.sent();\n\n            _a.label = 14;\n\n          case 14:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Gets single entity returned by execution of generated query builder sql.\n   */\n\n\n  SelectQueryBuilder.prototype.getOne = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var results, result, metadata, actualVersion, actualVersion;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getRawAndEntities()];\n\n          case 1:\n            results = _a.sent();\n            result = results.entities[0];\n\n            if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\n              metadata = this.expressionMap.mainAlias.metadata;\n\n              if (this.expressionMap.lockVersion instanceof Date) {\n                actualVersion = metadata.updateDateColumn.getEntityValue(result);\n                if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime()) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n              } else {\n                actualVersion = metadata.versionColumn.getEntityValue(result);\n                if (actualVersion !== this.expressionMap.lockVersion) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n              }\n            }\n\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n   */\n\n\n  SelectQueryBuilder.prototype.getOneOrFail = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var entity;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getOne()];\n\n          case 1:\n            entity = _a.sent();\n\n            if (!entity) {\n              throw new EntityNotFoundError(this.expressionMap.mainAlias.target, this);\n            }\n\n            return [2\n            /*return*/\n            , entity];\n        }\n      });\n    });\n  };\n  /**\n   * Gets entities returned by execution of generated query builder sql.\n   */\n\n\n  SelectQueryBuilder.prototype.getMany = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var results;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n            return [4\n            /*yield*/\n            , this.getRawAndEntities()];\n\n          case 1:\n            results = _a.sent();\n            return [2\n            /*return*/\n            , results.entities];\n        }\n      });\n    });\n  };\n  /**\n   * Gets count - number of entities selected by sql generated by this query builder.\n   * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n   */\n\n\n  SelectQueryBuilder.prototype.getCount = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, transactionStartedByUs, results, error_3, rollbackError_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n            queryRunner = this.obtainQueryRunner();\n            transactionStartedByUs = false;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7, 12, 15]);\n\n            if (!(this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 2:\n            _a.sent();\n\n            transactionStartedByUs = true;\n            _a.label = 3;\n\n          case 3:\n            this.expressionMap.queryEntity = false;\n            return [4\n            /*yield*/\n            , this.executeCountQuery(queryRunner)];\n\n          case 4:\n            results = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            , results];\n\n          case 7:\n            error_3 = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 11];\n            _a.label = 8;\n\n          case 8:\n            _a.trys.push([8, 10,, 11]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 9:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 11];\n\n          case 10:\n            rollbackError_3 = _a.sent();\n            return [3\n            /*break*/\n            , 11];\n\n          case 11:\n            throw error_3;\n\n          case 12:\n            if (!(queryRunner !== this.queryRunner)) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 13:\n            _a.sent();\n\n            _a.label = 14;\n\n          case 14:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes built SQL query and returns entities and overall entities count (without limitation).\n   * This method is useful to build pagination.\n   */\n\n\n  SelectQueryBuilder.prototype.getManyAndCount = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, transactionStartedByUs, entitiesAndRaw, count, results, error_4, rollbackError_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n            queryRunner = this.obtainQueryRunner();\n            transactionStartedByUs = false;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 8, 13, 16]);\n\n            if (!(this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 2:\n            _a.sent();\n\n            transactionStartedByUs = true;\n            _a.label = 3;\n\n          case 3:\n            this.expressionMap.queryEntity = true;\n            return [4\n            /*yield*/\n            , this.executeEntitiesAndRawResults(queryRunner)];\n\n          case 4:\n            entitiesAndRaw = _a.sent();\n            this.expressionMap.queryEntity = false;\n            return [4\n            /*yield*/\n            , this.executeCountQuery(queryRunner)];\n\n          case 5:\n            count = _a.sent();\n            results = [entitiesAndRaw.entities, count];\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 6:\n            _a.sent();\n\n            _a.label = 7;\n\n          case 7:\n            return [2\n            /*return*/\n            , results];\n\n          case 8:\n            error_4 = _a.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 12];\n            _a.label = 9;\n\n          case 9:\n            _a.trys.push([9, 11,, 12]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 10:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            rollbackError_4 = _a.sent();\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            throw error_4;\n\n          case 13:\n            if (!(queryRunner !== this.queryRunner)) return [3\n            /*break*/\n            , 15];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 14:\n            _a.sent();\n\n            _a.label = 15;\n\n          case 15:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes built SQL query and returns raw data stream.\n   */\n\n\n  SelectQueryBuilder.prototype.stream = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, sql, parameters, queryRunner, transactionStartedByUs, releaseFn, results, error_5, rollbackError_5;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.expressionMap.queryEntity = false;\n            _a = __read(this.getQueryAndParameters(), 2), sql = _a[0], parameters = _a[1];\n            queryRunner = this.obtainQueryRunner();\n            transactionStartedByUs = false;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 6,, 11]);\n\n            if (!(this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 2:\n            _b.sent();\n\n            transactionStartedByUs = true;\n            _b.label = 3;\n\n          case 3:\n            releaseFn = function () {\n              if (queryRunner !== _this.queryRunner) // means we created our own query runner\n                return queryRunner.release();\n              return;\n            };\n\n            results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 4:\n            _b.sent();\n\n            _b.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            , results];\n\n          case 6:\n            error_5 = _b.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 10];\n            _b.label = 7;\n\n          case 7:\n            _b.trys.push([7, 9,, 10]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 8:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            rollbackError_5 = _b.sent();\n            return [3\n            /*break*/\n            , 10];\n\n          case 10:\n            throw error_5;\n\n          case 11:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Enables or disables query result caching.\n   */\n\n\n  SelectQueryBuilder.prototype.cache = function (enabledOrMillisecondsOrId, maybeMilliseconds) {\n    if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n      this.expressionMap.cache = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n    }\n\n    if (maybeMilliseconds) {\n      this.expressionMap.cacheDuration = maybeMilliseconds;\n    }\n\n    return this;\n  };\n  /**\n   * Sets extra options that can be used to configure how query builder works.\n   */\n\n\n  SelectQueryBuilder.prototype.setOption = function (option) {\n    this.expressionMap.options.push(option);\n    return this;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  SelectQueryBuilder.prototype.join = function (direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany) {\n    this.setParameters(parameters || {});\n    var joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n    joinAttribute.direction = direction;\n    joinAttribute.mapToProperty = mapToProperty;\n    joinAttribute.isMappingMany = isMappingMany;\n    joinAttribute.entityOrProperty = entityOrProperty; // relationName\n\n    joinAttribute.condition = condition; // joinInverseSideCondition\n    // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n\n    this.expressionMap.joinAttributes.push(joinAttribute);\n\n    if (joinAttribute.metadata) {\n      if (joinAttribute.metadata.deleteDateColumn && !this.expressionMap.withDeleted) {\n        var conditionDeleteColumn = aliasName + \".\" + joinAttribute.metadata.deleteDateColumn.propertyName + \" IS NULL\";\n        joinAttribute.condition += joinAttribute.condition ? \" AND \" + conditionDeleteColumn : \"\" + conditionDeleteColumn;\n      } // todo: find and set metadata right there?\n\n\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        metadata: joinAttribute.metadata\n      });\n\n      if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n        this.expressionMap.createAlias({\n          type: \"join\",\n          name: joinAttribute.junctionAlias,\n          metadata: joinAttribute.relation.junctionEntityMetadata\n        });\n      }\n    } else {\n      var subQuery = \"\";\n\n      if (entityOrProperty instanceof Function) {\n        var subQueryBuilder = entityOrProperty(this.subQuery());\n        this.setParameters(subQueryBuilder.getParameters());\n        subQuery = subQueryBuilder.getQuery();\n      } else {\n        subQuery = entityOrProperty;\n      }\n\n      var isSubQuery = entityOrProperty instanceof Function || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        tablePath: isSubQuery === false ? entityOrProperty : undefined,\n        subQuery: isSubQuery === true ? subQuery : undefined\n      });\n    }\n  };\n  /**\n   * Creates \"SELECT FROM\" part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createSelectExpression = function () {\n    var _this = this;\n\n    if (!this.expressionMap.mainAlias) throw new Error(\"Cannot build query because main alias is not set (call qb#from method)\"); // todo throw exception if selects or from is missing\n\n    var allSelects = [];\n    var excludedSelects = [];\n\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      var metadata = this.expressionMap.mainAlias.metadata;\n      allSelects.push.apply(allSelects, __spreadArray([], __read(this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata))));\n      excludedSelects.push.apply(excludedSelects, __spreadArray([], __read(this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata))));\n    } // add selects from joins\n\n\n    this.expressionMap.joinAttributes.forEach(function (join) {\n      if (join.metadata) {\n        allSelects.push.apply(allSelects, __spreadArray([], __read(_this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata))));\n        excludedSelects.push.apply(excludedSelects, __spreadArray([], __read(_this.findEntityColumnSelects(join.alias.name, join.metadata))));\n      } else {\n        var hasMainAlias = _this.expressionMap.selects.some(function (select) {\n          return select.selection === join.alias.name;\n        });\n\n        if (hasMainAlias) {\n          allSelects.push({\n            selection: _this.escape(join.alias.name) + \".*\"\n          });\n\n          var excludedSelect = _this.expressionMap.selects.find(function (select) {\n            return select.selection === join.alias.name;\n          });\n\n          excludedSelects.push(excludedSelect);\n        }\n      }\n    }); // add all other selects\n\n    this.expressionMap.selects.filter(function (select) {\n      return excludedSelects.indexOf(select) === -1;\n    }).forEach(function (select) {\n      return allSelects.push({\n        selection: _this.replacePropertyNames(select.selection),\n        aliasName: select.aliasName\n      });\n    }); // if still selection is empty, then simply set it to all (*)\n\n    if (allSelects.length === 0) allSelects.push({\n      selection: \"*\"\n    });\n    var lock = \"\";\n\n    if (this.connection.driver instanceof SqlServerDriver) {\n      switch (this.expressionMap.lockMode) {\n        case \"pessimistic_read\":\n          lock = \" WITH (HOLDLOCK, ROWLOCK)\";\n          break;\n\n        case \"pessimistic_write\":\n          lock = \" WITH (UPDLOCK, ROWLOCK)\";\n          break;\n\n        case \"dirty_read\":\n          lock = \" WITH (NOLOCK)\";\n          break;\n      }\n    } // create a selection query\n\n\n    var froms = this.expressionMap.aliases.filter(function (alias) {\n      return alias.type === \"from\" && (alias.tablePath || alias.subQuery);\n    }).map(function (alias) {\n      if (alias.subQuery) return alias.subQuery + \" \" + _this.escape(alias.name);\n      return _this.getTableName(alias.tablePath) + \" \" + _this.escape(alias.name);\n    });\n    var select = this.createSelectDistinctExpression();\n    var selection = allSelects.map(function (select) {\n      return select.selection + (select.aliasName ? \" AS \" + _this.escape(select.aliasName) : \"\");\n    }).join(\", \");\n    return select + selection + \" FROM \" + froms.join(\", \") + lock;\n  };\n  /**\n   * Creates select | select distinct part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createSelectDistinctExpression = function () {\n    var _this = this;\n\n    var _a = this.expressionMap,\n        selectDistinct = _a.selectDistinct,\n        selectDistinctOn = _a.selectDistinctOn,\n        maxExecutionTime = _a.maxExecutionTime;\n    var driver = this.connection.driver;\n    var select = \"SELECT \";\n\n    if (maxExecutionTime > 0) {\n      if (driver instanceof MysqlDriver) {\n        select += \"/*+ MAX_EXECUTION_TIME(\" + this.expressionMap.maxExecutionTime + \") */ \";\n      }\n    }\n\n    if (driver instanceof PostgresDriver && selectDistinctOn.length > 0) {\n      var selectDistinctOnMap = selectDistinctOn.map(function (on) {\n        return _this.replacePropertyNames(on);\n      }).join(\", \");\n      select = \"SELECT DISTINCT ON (\" + selectDistinctOnMap + \") \";\n    } else if (selectDistinct) {\n      select = \"SELECT DISTINCT \";\n    }\n\n    return select;\n  };\n  /**\n   * Creates \"JOIN\" part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createJoinExpression = function () {\n    // examples:\n    // select from owning side\n    // qb.select(\"post\")\n    //     .leftJoinAndSelect(\"post.category\", \"category\");\n    // select from non-owning side\n    // qb.select(\"category\")\n    //     .leftJoinAndSelect(\"category.post\", \"post\");\n    var _this = this;\n\n    var joins = this.expressionMap.joinAttributes.map(function (joinAttr) {\n      var relation = joinAttr.relation;\n      var destinationTableName = joinAttr.tablePath;\n      var destinationTableAlias = joinAttr.alias.name;\n      var appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n      var parentAlias = joinAttr.parentAlias; // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n      // table to join, without junction table involved. This means we simply join direct table.\n\n      if (!parentAlias || !relation) {\n        var destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : _this.getTableName(destinationTableName);\n        return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + _this.escape(destinationTableAlias) + (joinAttr.condition ? \" ON \" + _this.replacePropertyNames(joinAttr.condition) : \"\");\n      } // if real entity relation is involved\n\n\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n        var condition = relation.joinColumns.map(function (joinColumn) {\n          return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + _this.getTableName(destinationTableName) + \" \" + _this.escape(destinationTableAlias) + \" ON \" + _this.replacePropertyNames(condition + appendedCondition);\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n        var condition = relation.inverseRelation.joinColumns.map(function (joinColumn) {\n          if (relation.inverseEntityMetadata.tableType === \"entity-child\" && relation.inverseEntityMetadata.discriminatorColumn) {\n            appendedCondition += \" AND \" + destinationTableAlias + \".\" + relation.inverseEntityMetadata.discriminatorColumn.databaseName + \"='\" + relation.inverseEntityMetadata.discriminatorValue + \"'\";\n          }\n\n          return destinationTableAlias + \".\" + relation.inverseRelation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + _this.getTableName(destinationTableName) + \" \" + _this.escape(destinationTableAlias) + \" ON \" + _this.replacePropertyNames(condition + appendedCondition);\n      } else {\n        // means many-to-many\n        var junctionTableName = relation.junctionEntityMetadata.tablePath;\n        var junctionAlias_1 = joinAttr.junctionAlias;\n        var junctionCondition = \"\",\n            destinationCondition = \"\";\n\n        if (relation.isOwning) {\n          junctionCondition = relation.joinColumns.map(function (joinColumn) {\n            // `post_category`.`postId` = `post`.`id`\n            return junctionAlias_1 + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseJoinColumns.map(function (joinColumn) {\n            // `category`.`id` = `post_category`.`categoryId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias_1 + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        } else {\n          junctionCondition = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) {\n            // `post_category`.`categoryId` = `category`.`id`\n            return junctionAlias_1 + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseRelation.joinColumns.map(function (joinColumn) {\n            // `post`.`id` = `post_category`.`postId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias_1 + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        }\n\n        return \" \" + joinAttr.direction + \" JOIN \" + _this.getTableName(junctionTableName) + \" \" + _this.escape(junctionAlias_1) + \" ON \" + _this.replacePropertyNames(junctionCondition) + \" \" + joinAttr.direction + \" JOIN \" + _this.getTableName(destinationTableName) + \" \" + _this.escape(destinationTableAlias) + \" ON \" + _this.replacePropertyNames(destinationCondition + appendedCondition);\n      }\n    });\n    return joins.join(\" \");\n  };\n  /**\n   * Creates \"GROUP BY\" part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createGroupByExpression = function () {\n    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n    return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n  };\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createOrderByExpression = function () {\n    var _this = this;\n\n    var orderBys = this.expressionMap.allOrderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(function (columnName) {\n      if (typeof orderBys[columnName] === \"string\") {\n        return _this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return _this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  };\n  /**\n   * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createLimitOffsetExpression = function () {\n    // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n    // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n    var offset = this.expressionMap.offset,\n        limit = this.expressionMap.limit;\n\n    if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\n      offset = this.expressionMap.skip;\n      limit = this.expressionMap.take;\n    }\n\n    if (this.connection.driver instanceof SqlServerDriver) {\n      // Due to a limitation in SQL Server's parser implementation it does not support using\n      // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n      // user does not request one we insert a dummy ORDER BY that does nothing and should\n      // have no effect on the query planner or on the order of the results returned.\n      // https://dba.stackexchange.com/a/193799\n      var prefix = \"\";\n\n      if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n        prefix = \" ORDER BY (SELECT NULL)\";\n      }\n\n      if (limit && offset) return prefix + \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\";\n    } else if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver || this.connection.driver instanceof SapDriver) {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) throw new OffsetWithoutLimitNotSupportedError();\n    } else if (this.connection.driver instanceof AbstractSqliteDriver) {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" LIMIT -1 OFFSET \" + offset;\n    } else if (this.connection.driver instanceof OracleDriver) {\n      if (limit && offset) return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return \" OFFSET \" + offset + \" ROWS\";\n    } else {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" OFFSET \" + offset;\n    }\n\n    return \"\";\n  };\n  /**\n   * Creates \"LOCK\" part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createLockExpression = function () {\n    var driver = this.connection.driver;\n    var lockTablesClause = \"\";\n\n    if (this.expressionMap.lockTables) {\n      if (!(driver instanceof PostgresDriver)) {\n        throw new Error(\"Lock tables not supported in selected driver\");\n      }\n\n      if (this.expressionMap.lockTables.length < 1) {\n        throw new Error(\"lockTables cannot be an empty array\");\n      }\n\n      lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n    }\n\n    switch (this.expressionMap.lockMode) {\n      case \"pessimistic_read\":\n        if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver) {\n          return \" LOCK IN SHARE MODE\";\n        } else if (driver instanceof PostgresDriver) {\n          return \" FOR SHARE\" + lockTablesClause;\n        } else if (driver instanceof OracleDriver) {\n          return \" FOR UPDATE\";\n        } else if (driver instanceof SqlServerDriver) {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"pessimistic_write\":\n        if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver || driver instanceof OracleDriver) {\n          return \" FOR UPDATE\";\n        } else if (driver instanceof PostgresDriver) {\n          return \" FOR UPDATE\" + lockTablesClause;\n        } else if (driver instanceof SqlServerDriver) {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"pessimistic_partial_write\":\n        if (driver instanceof PostgresDriver) {\n          return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n        } else if (driver instanceof MysqlDriver) {\n          return \" FOR UPDATE SKIP LOCKED\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"pessimistic_write_or_fail\":\n        if (driver instanceof PostgresDriver) {\n          return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n        } else if (driver instanceof MysqlDriver) {\n          return \" FOR UPDATE NOWAIT\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      case \"for_no_key_update\":\n        if (driver instanceof PostgresDriver) {\n          return \" FOR NO KEY UPDATE\" + lockTablesClause;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n\n      default:\n        return \"\";\n    }\n  };\n  /**\n   * Creates \"HAVING\" part of SQL query.\n   */\n\n\n  SelectQueryBuilder.prototype.createHavingExpression = function () {\n    var _this = this;\n\n    if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n    var conditions = this.expressionMap.havings.map(function (having, index) {\n      switch (having.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + _this.replacePropertyNames(having.condition);\n\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + _this.replacePropertyNames(having.condition);\n\n        default:\n          return _this.replacePropertyNames(having.condition);\n      }\n    }).join(\" \");\n    if (!conditions.length) return \"\";\n    return \" HAVING \" + conditions;\n  };\n\n  SelectQueryBuilder.prototype.buildEscapedEntityColumnSelects = function (aliasName, metadata) {\n    var _this = this;\n\n    var hasMainAlias = this.expressionMap.selects.some(function (select) {\n      return select.selection === aliasName;\n    });\n    var columns = [];\n\n    if (hasMainAlias) {\n      columns.push.apply(columns, __spreadArray([], __read(metadata.columns.filter(function (column) {\n        return column.isSelect === true;\n      }))));\n    }\n\n    columns.push.apply(columns, __spreadArray([], __read(metadata.columns.filter(function (column) {\n      return _this.expressionMap.selects.some(function (select) {\n        return select.selection === aliasName + \".\" + column.propertyPath;\n      });\n    })))); // if user used partial selection and did not select some primary columns which are required to be selected\n    // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n    // to make entity contain exactly what user selected\n\n    if (columns.length === 0) // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n      return [];\n    var nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(function (primaryColumn) {\n      return columns.indexOf(primaryColumn) === -1;\n    }) : [];\n\n    var allColumns = __spreadArray(__spreadArray([], __read(columns)), __read(nonSelectedPrimaryColumns));\n\n    return allColumns.map(function (column) {\n      var selection = _this.expressionMap.selects.find(function (select) {\n        return select.selection === aliasName + \".\" + column.propertyPath;\n      });\n\n      var selectionPath = _this.escape(aliasName) + \".\" + _this.escape(column.databaseName);\n\n      if (_this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n        if (_this.connection.driver instanceof MysqlDriver || _this.connection.driver instanceof AuroraDataApiDriver) {\n          var useLegacy = _this.connection.driver.options.legacySpatialSupport;\n          var asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n          selectionPath = asText + \"(\" + selectionPath + \")\";\n        }\n\n        if (_this.connection.driver instanceof PostgresDriver) // cast to JSON to trigger parsing in the driver\n          if (column.precision) {\n            selectionPath = \"ST_AsGeoJSON(\" + selectionPath + \", \" + column.precision + \")::json\";\n          } else {\n            selectionPath = \"ST_AsGeoJSON(\" + selectionPath + \")::json\";\n          }\n        if (_this.connection.driver instanceof SqlServerDriver) selectionPath = selectionPath + \".ToString()\";\n      }\n\n      return {\n        selection: selectionPath,\n        aliasName: selection && selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(_this.connection.driver, aliasName, column.databaseName),\n        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n        virtual: selection ? selection.virtual === true : hasMainAlias ? false : true\n      };\n    });\n  };\n\n  SelectQueryBuilder.prototype.findEntityColumnSelects = function (aliasName, metadata) {\n    var mainSelect = this.expressionMap.selects.find(function (select) {\n      return select.selection === aliasName;\n    });\n    if (mainSelect) return [mainSelect];\n    return this.expressionMap.selects.filter(function (select) {\n      return metadata.columns.some(function (column) {\n        return select.selection === aliasName + \".\" + column.propertyPath;\n      });\n    });\n  };\n\n  SelectQueryBuilder.prototype.computeCountExpression = function () {\n    var _this = this;\n\n    var mainAlias = this.expressionMap.mainAlias.name; // todo: will this work with \"fromTableName\"?\n\n    var metadata = this.expressionMap.mainAlias.metadata;\n    var primaryColumns = metadata.primaryColumns;\n    var distinctAlias = this.escape(mainAlias); // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n    // so we prevent poor query patterns in the most likely cases\n\n    if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {\n      return \"COUNT(1)\";\n    } // For everything else, we'll need to do some hackery to get the correct count values.\n\n\n    if (this.connection.driver instanceof CockroachDriver || this.connection.driver instanceof PostgresDriver) {\n      // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n      // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n      return \"COUNT(DISTINCT(\" + primaryColumns.map(function (c) {\n        return distinctAlias + \".\" + _this.escape(c.databaseName);\n      }).join(\", \") + \"))\";\n    }\n\n    if (this.connection.driver instanceof MysqlDriver) {\n      // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n      // https://mariadb.com/kb/en/count-distinct/\n      return \"COUNT(DISTINCT \" + primaryColumns.map(function (c) {\n        return distinctAlias + \".\" + _this.escape(c.databaseName);\n      }).join(\", \") + \")\";\n    }\n\n    if (this.connection.driver instanceof SqlServerDriver) {\n      // SQL Server has gotta be different from everyone else.  They don't support\n      // distinct counting multiple columns & they don't have the same operator\n      // characteristic for concatenating, so we gotta use the `CONCAT` function.\n      // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n      var columnsExpression = primaryColumns.map(function (primaryColumn) {\n        return distinctAlias + \".\" + _this.escape(primaryColumn.databaseName);\n      }).join(\", '|;|', \");\n\n      if (primaryColumns.length === 1) {\n        return \"COUNT(DISTINCT(\" + columnsExpression + \"))\";\n      }\n\n      return \"COUNT(DISTINCT(CONCAT(\" + columnsExpression + \")))\";\n    } // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n    // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n    // likely to work across servers implementing the SQL standard.\n    // Please note, if there is only one primary column that the concatenation does not occur in this\n    // query and the query is a standard `COUNT DISTINCT` in that case.\n\n\n    return \"COUNT(DISTINCT(\" + primaryColumns.map(function (c) {\n      return distinctAlias + \".\" + _this.escape(c.databaseName);\n    }).join(\" || '|;|' || \") + \"))\";\n  };\n\n  SelectQueryBuilder.prototype.executeCountQuery = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var countSql, results;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            countSql = this.computeCountExpression();\n            return [4\n            /*yield*/\n            , this.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(countSql, \"cnt\").setOption(\"disable-global-order\").loadRawResults(queryRunner)];\n\n          case 1:\n            results = _a.sent();\n            if (!results || !results[0] || !results[0][\"cnt\"]) return [2\n            /*return*/\n            , 0];\n            return [2\n            /*return*/\n            , parseInt(results[0][\"cnt\"])];\n        }\n      });\n    });\n  };\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n\n\n  SelectQueryBuilder.prototype.executeEntitiesAndRawResults = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, relationIdLoader, relationCountLoader, relationIdMetadataTransformer, relationCountMetadataTransformer, rawResults, entities, _a, selects, orderBys_1, metadata_1, mainAliasName_1, querySelects, condition, parameters_1, alias_1, ids, areAllNumbers, rawRelationIdResults, rawRelationCountResults, transformer, broadcastResult;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this.expressionMap.mainAlias) throw new Error(\"Alias is not set. Use \\\"from\\\" method to set an alias.\");\n            if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\" || this.expressionMap.lockMode === \"pessimistic_partial_write\" || this.expressionMap.lockMode === \"pessimistic_write_or_fail\" || this.expressionMap.lockMode === \"for_no_key_update\") && !queryRunner.isTransactionActive) throw new PessimisticLockTransactionRequiredError();\n\n            if (this.expressionMap.lockMode === \"optimistic\") {\n              metadata = this.expressionMap.mainAlias.metadata;\n              if (!metadata.versionColumn && !metadata.updateDateColumn) throw new NoVersionOrUpdateDateColumnError(metadata.name);\n            }\n\n            relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\n            relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\n            relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n            relationIdMetadataTransformer.transform();\n            relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n            relationCountMetadataTransformer.transform();\n            rawResults = [], entities = [];\n            if (!((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0)) return [3\n            /*break*/\n            , 4];\n            _a = __read(this.createOrderByCombinedWithSelectExpression(\"distinctAlias\"), 2), selects = _a[0], orderBys_1 = _a[1];\n            metadata_1 = this.expressionMap.mainAlias.metadata;\n            mainAliasName_1 = this.expressionMap.mainAlias.name;\n            querySelects = metadata_1.primaryColumns.map(function (primaryColumn) {\n              var distinctAlias = _this.escape(\"distinctAlias\");\n\n              var columnAlias = _this.escape(DriverUtils.buildAlias(_this.connection.driver, mainAliasName_1, primaryColumn.databaseName));\n\n              if (!orderBys_1[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction\n                orderBys_1[columnAlias] = \"ASC\";\n              var alias = DriverUtils.buildAlias(_this.connection.driver, \"ids_\" + mainAliasName_1, primaryColumn.databaseName);\n              return distinctAlias + \".\" + columnAlias + \" as \\\"\" + alias + \"\\\"\";\n            });\n            return [4\n            /*yield*/\n            , new SelectQueryBuilder(this.connection, queryRunner).select(\"DISTINCT \" + querySelects.join(\", \")).addSelect(selects).from(\"(\" + this.clone().orderBy().getQuery() + \")\", \"distinctAlias\").offset(this.expressionMap.skip).limit(this.expressionMap.take).orderBy(orderBys_1).cache(this.expressionMap.cache ? this.expressionMap.cache : this.expressionMap.cacheId, this.expressionMap.cacheDuration).setParameters(this.getParameters()).setNativeParameters(this.expressionMap.nativeParameters).getRawMany()];\n\n          case 1:\n            rawResults = _b.sent();\n            if (!(rawResults.length > 0)) return [3\n            /*break*/\n            , 3];\n            condition = \"\";\n            parameters_1 = {};\n\n            if (metadata_1.hasMultiplePrimaryKeys) {\n              condition = rawResults.map(function (result, index) {\n                return metadata_1.primaryColumns.map(function (primaryColumn) {\n                  var paramKey = \"orm_distinct_ids_\" + index + \"_\" + primaryColumn.databaseName;\n                  parameters_1[paramKey] = result[\"ids_\" + mainAliasName_1 + \"_\" + primaryColumn.databaseName];\n                  return mainAliasName_1 + \".\" + primaryColumn.propertyPath + \"=:\" + paramKey;\n                }).join(\" AND \");\n              }).join(\" OR \");\n            } else {\n              alias_1 = DriverUtils.buildAlias(this.connection.driver, \"ids_\" + mainAliasName_1, metadata_1.primaryColumns[0].databaseName);\n              ids = rawResults.map(function (result) {\n                return result[alias_1];\n              });\n              areAllNumbers = ids.every(function (id) {\n                return typeof id === \"number\";\n              });\n\n              if (areAllNumbers) {\n                // fixes #190. if all numbers then its safe to perform query without parameter\n                condition = mainAliasName_1 + \".\" + metadata_1.primaryColumns[0].propertyPath + \" IN (\" + ids.join(\", \") + \")\";\n              } else {\n                parameters_1[\"orm_distinct_ids\"] = ids;\n                condition = mainAliasName_1 + \".\" + metadata_1.primaryColumns[0].propertyPath + \" IN (:...orm_distinct_ids)\";\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.clone().mergeExpressionMap({\n              extraAppendedAndWhereCondition: condition\n            }).setParameters(parameters_1).loadRawResults(queryRunner)];\n\n          case 2:\n            rawResults = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            return [4\n            /*yield*/\n            , this.loadRawResults(queryRunner)];\n\n          case 5:\n            rawResults = _b.sent();\n            _b.label = 6;\n\n          case 6:\n            if (!(rawResults.length > 0)) return [3\n            /*break*/\n            , 10];\n            return [4\n            /*yield*/\n            , relationIdLoader.load(rawResults)];\n\n          case 7:\n            rawRelationIdResults = _b.sent();\n            return [4\n            /*yield*/\n            , relationCountLoader.load(rawResults)];\n\n          case 8:\n            rawRelationCountResults = _b.sent();\n            transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);\n            entities = transformer.transform(rawResults, this.expressionMap.mainAlias);\n            if (!(this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata)) return [3\n            /*break*/\n            , 10];\n            broadcastResult = new BroadcasterResult();\n            queryRunner.broadcaster.broadcastLoadEventsForAll(broadcastResult, this.expressionMap.mainAlias.metadata, entities);\n            if (!(broadcastResult.promises.length > 0)) return [3\n            /*break*/\n            , 10];\n            return [4\n            /*yield*/\n            , Promise.all(broadcastResult.promises)];\n\n          case 9:\n            _b.sent();\n\n            _b.label = 10;\n\n          case 10:\n            return [2\n            /*return*/\n            , {\n              raw: rawResults,\n              entities: entities\n            }];\n        }\n      });\n    });\n  };\n\n  SelectQueryBuilder.prototype.createOrderByCombinedWithSelectExpression = function (parentAlias) {\n    var _this = this; // if table has a default order then apply it\n\n\n    var orderBys = this.expressionMap.allOrderBys;\n    var selectString = Object.keys(orderBys).map(function (orderCriteria) {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        var criteriaParts = orderCriteria.split(\".\");\n        var aliasName = criteriaParts[0];\n        var propertyPath = criteriaParts.slice(1).join(\".\");\n\n        var alias = _this.expressionMap.findAliasByName(aliasName);\n\n        var column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        return _this.escape(parentAlias) + \".\" + _this.escape(DriverUtils.buildAlias(_this.connection.driver, aliasName, column.databaseName));\n      } else {\n        if (_this.expressionMap.selects.find(function (select) {\n          return select.selection === orderCriteria || select.aliasName === orderCriteria;\n        })) return _this.escape(parentAlias) + \".\" + orderCriteria;\n        return \"\";\n      }\n    }).join(\", \");\n    var orderByObject = {};\n    Object.keys(orderBys).forEach(function (orderCriteria) {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        var criteriaParts = orderCriteria.split(\".\");\n        var aliasName = criteriaParts[0];\n        var propertyPath = criteriaParts.slice(1).join(\".\");\n\n        var alias = _this.expressionMap.findAliasByName(aliasName);\n\n        var column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        orderByObject[_this.escape(parentAlias) + \".\" + _this.escape(DriverUtils.buildAlias(_this.connection.driver, aliasName, column.databaseName))] = orderBys[orderCriteria];\n      } else {\n        if (_this.expressionMap.selects.find(function (select) {\n          return select.selection === orderCriteria || select.aliasName === orderCriteria;\n        })) {\n          orderByObject[_this.escape(parentAlias) + \".\" + orderCriteria] = orderBys[orderCriteria];\n        } else {\n          orderByObject[orderCriteria] = orderBys[orderCriteria];\n        }\n      }\n    });\n    return [selectString, orderByObject];\n  };\n  /**\n   * Loads raw results from the database.\n   */\n\n\n  SelectQueryBuilder.prototype.loadRawResults = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, sql, parameters, queryId, cacheOptions, savedQueryResultCacheOptions, cacheError, error_6, results, error_7;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = __read(this.getQueryAndParameters(), 2), sql = _a[0], parameters = _a[1];\n            queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n            cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n            savedQueryResultCacheOptions = undefined;\n            cacheError = false;\n            if (!(this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled))) return [3\n            /*break*/\n            , 4];\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.connection.queryResultCache.getFromCache({\n              identifier: this.expressionMap.cacheId,\n              query: queryId,\n              duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\n            }, queryRunner)];\n\n          case 2:\n            savedQueryResultCacheOptions = _b.sent();\n            if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) return [2\n            /*return*/\n            , JSON.parse(savedQueryResultCacheOptions.result)];\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_6 = _b.sent();\n\n            if (!cacheOptions.ignoreErrors) {\n              throw error_6;\n            }\n\n            cacheError = true;\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [4\n            /*yield*/\n            , queryRunner.query(sql, parameters)];\n\n          case 5:\n            results = _b.sent();\n            if (!(!cacheError && this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled))) return [3\n            /*break*/\n            , 9];\n            _b.label = 6;\n\n          case 6:\n            _b.trys.push([6, 8,, 9]);\n\n            return [4\n            /*yield*/\n            , this.connection.queryResultCache.storeInCache({\n              identifier: this.expressionMap.cacheId,\n              query: queryId,\n              time: new Date().getTime(),\n              duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\n              result: JSON.stringify(results)\n            }, savedQueryResultCacheOptions, queryRunner)];\n\n          case 7:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            error_7 = _b.sent();\n\n            if (!cacheOptions.ignoreErrors) {\n              throw error_7;\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 9:\n            return [2\n            /*return*/\n            , results];\n        }\n      });\n    });\n  };\n  /**\n   * Merges into expression map given expression map properties.\n   */\n\n\n  SelectQueryBuilder.prototype.mergeExpressionMap = function (expressionMap) {\n    ObjectUtils.assign(this.expressionMap, expressionMap);\n    return this;\n  };\n  /**\n   * Normalizes a give number - converts to int if possible.\n   */\n\n\n  SelectQueryBuilder.prototype.normalizeNumber = function (num) {\n    if (typeof num === \"number\" || num === undefined || num === null) return num;\n    return Number(num);\n  };\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n\n\n  SelectQueryBuilder.prototype.obtainQueryRunner = function () {\n    return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n  };\n\n  return SelectQueryBuilder;\n}(QueryBuilder);\n\nexport { SelectQueryBuilder };","map":{"version":3,"sources":["../browser/src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {SapDriver} from \"../driver/sap/SapDriver\";\nimport {RawSqlResultsToEntityTransformer} from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {PessimisticLockTransactionRequiredError} from \"../error/PessimisticLockTransactionRequiredError\";\nimport {NoVersionOrUpdateDateColumnError} from \"../error/NoVersionOrUpdateDateColumnError\";\nimport {OptimisticLockVersionMismatchError} from \"../error/OptimisticLockVersionMismatchError\";\nimport {OptimisticLockCanNotBeUsedError} from \"../error/OptimisticLockCanNotBeUsedError\";\nimport {JoinAttribute} from \"./JoinAttribute\";\nimport {RelationIdAttribute} from \"./relation-id/RelationIdAttribute\";\nimport {RelationCountAttribute} from \"./relation-count/RelationCountAttribute\";\nimport {RelationIdLoader} from \"./relation-id/RelationIdLoader\";\nimport {RelationIdMetadataToAttributeTransformer} from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport {RelationCountLoader} from \"./relation-count/RelationCountLoader\";\nimport {RelationCountMetadataToAttributeTransformer} from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport {QueryBuilder} from \"./QueryBuilder\";\nimport {ReadStream} from \"../platform/PlatformTools\";\nimport {LockNotSupportedOnGivenDriverError} from \"../error/LockNotSupportedOnGivenDriverError\";\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {SelectQuery} from \"./SelectQuery\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {WhereExpression} from \"./WhereExpression\";\nimport {Brackets} from \"./Brackets\";\nimport {AbstractSqliteDriver} from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport {QueryResultCacheOptions} from \"../cache/QueryResultCacheOptions\";\nimport {OffsetWithoutLimitNotSupportedError} from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\nimport {SelectQueryBuilderOption} from \"./SelectQueryBuilderOption\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\nimport {DriverUtils} from \"../driver/DriverUtils\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport {CockroachDriver} from \"../driver/cockroachdb/CockroachDriver\";\nimport {EntityNotFoundError} from \"../error/EntityNotFoundError\";\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity> extends QueryBuilder<Entity> implements WhereExpression {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment();\n        sql += this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitOffsetExpression();\n        sql += this.createLockExpression();\n        sql = sql.trim();\n        if (this.expressionMap.subQuery)\n            sql = \"(\" + sql + \")\";\n        return sql;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder();\n        qb.expressionMap.subQuery = true;\n        qb.expressionMap.parentQueryBuilder = this;\n        return qb;\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this;\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, selectionAliasName?: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection?: string|string[]|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), selectionAliasName?: string): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map(selection => ({ selection: selection }));\n\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });\n\n        } else if (selection) {\n            this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string|string[]|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), selectionAliasName?: string): this {\n        if (!selection)\n            return this;\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({ selection: selection })));\n\n        } else if (selection instanceof Function) {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });\n\n        } else if (selection) {\n            this.expressionMap.selects.push({ selection: selection, aliasName: selectionAliasName });\n        }\n\n        return this;\n    }\n\n    /**\n     * Set max execution time.\n     * @param milliseconds\n     */\n    maxExecutionTime(milliseconds: number): this {\n        this.expressionMap.maxExecutionTime = milliseconds;\n        return this;\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct;\n        return this;\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn;\n        return this;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(entityTarget: EntityTarget<T>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T>(entityTarget: EntityTarget<T>|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName);\n        this.expressionMap.setMainAlias(mainAlias);\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(entityTarget: EntityTarget<T>, aliasName: string): SelectQueryBuilder<T>;\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T>(entityTarget: EntityTarget<T>|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName);\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias);\n\n        return (this as any) as SelectQueryBuilder<T>;\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entity: Function|string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entity: Function|string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entity: Function|string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.innerJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(tableName: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.leftJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n        return this;\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n        return this;\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, property: string, alias: string, condition?: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entity: Function|string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, tableName: string, alias: string, condition: string, parameters?: ObjectLiteral): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), alias: string, condition: string = \"\", parameters?: ObjectLiteral): this {\n        this.addSelect(alias);\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false);\n        return this;\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, options?: { disableMixedMap?: boolean }): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, alias: string, queryBuilderFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this;\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty: string,\n                         relationName: string,\n                         aliasNameOrOptions?: string|{ disableMixedMap?: boolean },\n                         queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\n\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n        relationIdAttribute.mapToProperty = mapToProperty;\n        relationIdAttribute.relationName = relationName;\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions;\n        if (aliasNameOrOptions instanceof Object && (aliasNameOrOptions as any).disableMixedMap)\n            relationIdAttribute.disableMixedMap = true;\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(mapToProperty: string, relationName: string, aliasName?: string, queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\n        const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n        relationCountAttribute.mapToProperty = mapToProperty;\n        relationCountAttribute.relationName = relationName;\n        relationCountAttribute.alias = aliasName;\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias\n        });\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata: relationCountAttribute.relation.junctionEntityMetadata\n            });\n        }\n        return this;\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: { relations?: string[], disableMixedMap?: boolean }): this { // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach(relation => {\n            if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1)\n                return;\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\n                options\n            );\n        });\n        return this;\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(where: Brackets|string|((qb: this) => string)|ObjectLiteral|ObjectLiteral[], parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.computeWhereParameter(where);\n        if (condition)\n            this.expressionMap.wheres = [{ type: \"simple\", condition: condition }];\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(where: string|Brackets|((qb: this) => string), parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"and\", condition: this.computeWhereParameter(where) });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(where: Brackets|string|((qb: this) => string), parameters?: ObjectLiteral): this {\n        this.expressionMap.wheres.push({ type: \"or\", condition: this.computeWhereParameter(where) });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any|any[]): this {\n        return this.where(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any|any[]): this {\n        return this.andWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any|any[]): this {\n        return this.orWhere(this.createWhereIdsExpression(ids));\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this;\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy];\n        } else {\n            this.expressionMap.groupBys = [];\n        }\n        return this;\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy);\n        return this;\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort: string, order?: \"ASC\"|\"DESC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this;\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort?: string|OrderByCondition, order: \"ASC\"|\"DESC\" = \"ASC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n        if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n\n        if (sort) {\n            if (sort instanceof Object) {\n                this.expressionMap.orderBys = sort as OrderByCondition;\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = { [sort as string]: { order, nulls } };\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order };\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(sort: string, order: \"ASC\"|\"DESC\" = \"ASC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n        if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\")\n            throw new Error(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls };\n        } else {\n            this.expressionMap.orderBys[sort] = order;\n        }\n        return this;\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit);\n        if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit))\n            throw new Error(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset);\n        if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset))\n            throw new Error(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take);\n        if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take))\n            throw new Error(`Provided \"take\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip);\n        if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip))\n            throw new Error(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\n\n        return this;\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"pessimistic_read\"|\"pessimistic_write\"|\"dirty_read\"|\"pessimistic_partial_write\"|\"pessimistic_write_or_fail\"|\"for_no_key_update\", lockVersion?: undefined, lockTables?: string[]): this;\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\"|\"pessimistic_read\"|\"pessimistic_write\"|\"dirty_read\"|\"pessimistic_partial_write\"|\"pessimistic_write_or_fail\"|\"for_no_key_update\", lockVersion?: number|Date, lockTables?: string[]): this {\n        this.expressionMap.lockMode = lockMode;\n        this.expressionMap.lockVersion = lockVersion;\n        this.expressionMap.lockTables = lockTables;\n        return this;\n    }\n\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted(): this {\n        this.expressionMap.withDeleted = true;\n        return this;\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne<T = any>(): Promise<T> {\n        return (await this.getRawMany())[0];\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany<T = any>(): Promise<T[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        this.expressionMap.queryEntity = false;\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const results = await this.loadRawResults(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) { // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities<T = any>(): Promise<{ entities: Entity[], raw: T[] }> {\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            const results = await this.executeEntitiesAndRawResults(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity|undefined> {\n        const results = await this.getRawAndEntities();\n        const result = results.entities[0] as any;\n\n        if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\n            const metadata = this.expressionMap.mainAlias!.metadata;\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion = metadata.updateDateColumn!.getEntityValue(result); // what if columns arent set?\n                if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n\n            } else {\n                const actualVersion = metadata.versionColumn!.getEntityValue(result); // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail(): Promise<Entity> {\n        const entity = await this.getOne();\n\n        if (!entity) {\n            throw new EntityNotFoundError(this.expressionMap.mainAlias!.target, this);\n        }\n\n        return entity;\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const results = await this.getRawAndEntities();\n        return results.entities;\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = false;\n            const results = await this.executeCountQuery(queryRunner);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            this.expressionMap.queryEntity = true;\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);\n            this.expressionMap.queryEntity = false;\n            const count = await this.executeCountQuery(queryRunner);\n            const results: [Entity[], number] = [entitiesAndRaw.entities, count];\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false;\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner) // means we created our own query runner\n                    return queryRunner.release();\n                return;\n            };\n            const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n\n            return results;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this;\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this;\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this;\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabledOrMillisecondsOrId: boolean|number|string, maybeMilliseconds?: number): this {\n\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId;\n\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n\n        } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option);\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(direction: \"INNER\"|\"LEFT\",\n                   entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n                   aliasName: string,\n                   condition?: string,\n                   parameters?: ObjectLiteral,\n                   mapToProperty?: string,\n                   isMappingMany?: boolean): void {\n\n        this.setParameters(parameters || {});\n\n        const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n        joinAttribute.direction = direction;\n        joinAttribute.mapToProperty = mapToProperty;\n        joinAttribute.isMappingMany = isMappingMany;\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\n        joinAttribute.condition = condition; // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute);\n\n        if (joinAttribute.metadata) {\n           if (joinAttribute.metadata.deleteDateColumn && !this.expressionMap.withDeleted) {\n                const conditionDeleteColumn = `${aliasName}.${joinAttribute.metadata.deleteDateColumn.propertyName} IS NULL`;\n                joinAttribute.condition += joinAttribute.condition ? ` AND ${conditionDeleteColumn}`: `${conditionDeleteColumn}`;\n            }\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttribute.metadata\n            });\n            if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata\n                });\n            }\n\n        } else {\n            let subQuery: string = \"\";\n            if (entityOrProperty instanceof Function) {\n                const subQueryBuilder: SelectQueryBuilder<any> = (entityOrProperty as any)(((this as any) as SelectQueryBuilder<any>).subQuery());\n                this.setParameters(subQueryBuilder.getParameters());\n                subQuery = subQueryBuilder.getQuery();\n\n            } else {\n                subQuery = entityOrProperty;\n            }\n            const isSubQuery = entityOrProperty instanceof Function || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath: isSubQuery === false ? entityOrProperty as string : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            });\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n\n        if (!this.expressionMap.mainAlias)\n            throw new Error(\"Cannot build query because main alias is not set (call qb#from method)\");\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = [];\n        const excludedSelects: SelectQuery[] = [];\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n            excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes\n            .forEach(join => {\n                if (join.metadata) {\n                    allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name!, join.metadata));\n                    excludedSelects.push(...this.findEntityColumnSelects(join.alias.name!, join.metadata));\n                } else {\n                    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\n                    if (hasMainAlias) {\n                        allSelects.push({ selection: this.escape(join.alias.name!) + \".*\" });\n                        const excludedSelect = this.expressionMap.selects.find(select => select.selection === join.alias.name);\n                        excludedSelects.push(excludedSelect!);\n                    }\n                }\n            });\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter(select => excludedSelects.indexOf(select) === -1)\n            .forEach(select => allSelects.push({ selection: this.replacePropertyNames(select.selection), aliasName: select.aliasName }));\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0)\n            allSelects.push({ selection: \"*\" });\n\n        let lock: string = \"\";\n        if (this.connection.driver instanceof SqlServerDriver) {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    lock = \" WITH (HOLDLOCK, ROWLOCK)\";\n                    break;\n                case \"pessimistic_write\":\n                    lock = \" WITH (UPDLOCK, ROWLOCK)\";\n                    break;\n                case \"dirty_read\":\n                    lock = \" WITH (NOLOCK)\";\n                    break;\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(alias => alias.type === \"from\" && (alias.tablePath || alias.subQuery))\n            .map(alias => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name);\n\n                return this.getTableName(alias.tablePath!) + \" \" + this.escape(alias.name);\n            });\n\n        const select = this.createSelectDistinctExpression();\n        const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\n\n        return select + selection + \" FROM \" + froms.join(\", \") + lock;\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const {selectDistinct, selectDistinctOn, maxExecutionTime} = this.expressionMap;\n        const {driver} = this.connection;\n\n        let select = \"SELECT \";\n\n        if (maxExecutionTime > 0) {\n            if (driver instanceof MysqlDriver) {\n                select += `/*+ MAX_EXECUTION_TIME(${ this.expressionMap.maxExecutionTime }) */ `;\n            }\n        }\n\n        if (driver instanceof PostgresDriver && selectDistinctOn.length > 0) {\n            const selectDistinctOnMap = selectDistinctOn.map(\n              (on) => this.replacePropertyNames(on)\n            ).join(\", \");\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \";\n        }\n\n        return select;\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n            const relation = joinAttr.relation;\n            const destinationTableName = joinAttr.tablePath;\n            const destinationTableAlias = joinAttr.alias.name;\n            let appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n            const parentAlias = joinAttr.parentAlias;\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);\n                return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + this.escape(destinationTableAlias) +\n                    (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns.map(joinColumn => {\n                    return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\n                        parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation.inverseRelation!.joinColumns.map(joinColumn => {\n                    if (relation.inverseEntityMetadata.tableType === \"entity-child\" && relation.inverseEntityMetadata.discriminatorColumn) {\n                        appendedCondition += \" AND \" + destinationTableAlias + \".\" + relation.inverseEntityMetadata.discriminatorColumn.databaseName + \"='\" + relation.inverseEntityMetadata.discriminatorValue + \"'\";\n                    }\n\n                    return destinationTableAlias + \".\" + relation.inverseRelation!.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\n                        parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                }).join(\" AND \");\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n\n            } else { // means many-to-many\n                const junctionTableName = relation.junctionEntityMetadata!.tablePath;\n\n                const junctionAlias = joinAttr.junctionAlias;\n                let junctionCondition = \"\", destinationCondition = \"\";\n\n                if (relation.isOwning) {\n\n                    junctionCondition = relation.joinColumns.map(joinColumn => {\n                        // `post_category`.`postId` = `post`.`id`\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                    }).join(\" AND \");\n\n                    destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\n                        // `category`.`id` = `post_category`.`categoryId`\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n                    }).join(\" AND \");\n\n                } else {\n                    junctionCondition = relation.inverseRelation!.inverseJoinColumns.map(joinColumn => {\n                        // `post_category`.`categoryId` = `category`.`id`\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\n                    }).join(\" AND \");\n\n                    destinationCondition = relation.inverseRelation!.joinColumns.map(joinColumn => {\n                        // `post`.`id` = `post_category`.`postId`\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n                    }).join(\" AND \");\n                }\n\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(junctionTableName) + \" \" + this.escape(junctionAlias) + \" ON \" + this.replacePropertyNames(junctionCondition) +\n                    \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\n\n            }\n        });\n\n        return joins.join(\" \");\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n        return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys;\n        if (Object.keys(orderBys).length > 0)\n            return \" ORDER BY \" + Object.keys(orderBys)\n                    .map(columnName => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n                        } else {\n                            return this.replacePropertyNames(columnName) + \" \" + (orderBys[columnName] as any).order + \" \" + (orderBys[columnName] as any).nulls;\n                        }\n                    })\n                    .join(\", \");\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number|undefined = this.expressionMap.offset,\n            limit: number|undefined = this.expressionMap.limit;\n        if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\n            offset = this.expressionMap.skip;\n            limit = this.expressionMap.take;\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\";\n            if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n                prefix = \" ORDER BY (SELECT NULL)\";\n            }\n\n            if (limit && offset)\n                return prefix + \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (limit)\n                return prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset)\n                return prefix + \" OFFSET \" + offset + \" ROWS\";\n\n        } else if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver || this.connection.driver instanceof SapDriver) {\n\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                throw new OffsetWithoutLimitNotSupportedError();\n\n        } else if (this.connection.driver instanceof AbstractSqliteDriver) {\n\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                return \" LIMIT -1 OFFSET \" + offset;\n\n        } else if (this.connection.driver instanceof OracleDriver) {\n\n            if (limit && offset)\n                return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (limit)\n                return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset)\n                return \" OFFSET \" + offset + \" ROWS\";\n\n        } else {\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                return \" OFFSET \" + offset;\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver;\n\n        let lockTablesClause = \"\";\n\n        if (this.expressionMap.lockTables) {\n            if (!(driver instanceof PostgresDriver)) {\n                throw new Error(\"Lock tables not supported in selected driver\");\n            }\n            if (this.expressionMap.lockTables.length < 1) {\n                throw new Error(\"lockTables cannot be an empty array\");\n            }\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n        }\n\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver) {\n                    return \" LOCK IN SHARE MODE\";\n\n                } else if (driver instanceof PostgresDriver) {\n                    return \" FOR SHARE\" + lockTablesClause;\n\n                } else if (driver instanceof OracleDriver) {\n                    return \" FOR UPDATE\";\n\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write\":\n                if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver || driver instanceof OracleDriver) {\n                    return \" FOR UPDATE\";\n\n                }\n                else if (driver instanceof PostgresDriver ) {\n                    return \" FOR UPDATE\" + lockTablesClause;\n\n                } else if (driver instanceof SqlServerDriver) {\n                    return \"\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_partial_write\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n\n                } else if (driver instanceof MysqlDriver) {\n                    return \" FOR UPDATE SKIP LOCKED\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write_or_fail\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n\n                } else if (driver instanceof MysqlDriver) {\n                    return \" FOR UPDATE NOWAIT\";\n\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n\n            case \"for_no_key_update\":\n                if (driver instanceof PostgresDriver) {\n                    return \" FOR NO KEY UPDATE\" + lockTablesClause;\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            default:\n                return \"\";\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n        const conditions = this.expressionMap.havings.map((having, index) => {\n            switch (having.type) {\n                case \"and\":\n                    return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\n                case \"or\":\n                    return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\n                default:\n                    return this.replacePropertyNames(having.condition);\n            }\n        }).join(\" \");\n\n        if (!conditions.length) return \"\";\n        return \" HAVING \" + conditions;\n    }\n\n    protected buildEscapedEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\n\n        const columns: ColumnMetadata[] = [];\n        if (hasMainAlias) {\n            columns.push(...metadata.columns.filter(column => column.isSelect === true));\n        }\n        columns.push(...metadata.columns.filter(column => {\n            return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyPath);\n        }));\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0) // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return [];\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n\n        return allColumns.map(column => {\n            const selection = this.expressionMap.selects.find(select => select.selection === aliasName + \".\" + column.propertyPath);\n            let selectionPath = this.escape(aliasName) + \".\" + this.escape(column.databaseName);\n            if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n                    const useLegacy = this.connection.driver.options.legacySpatialSupport;\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n                    selectionPath = `${asText}(${selectionPath})`;\n                }\n\n                if (this.connection.driver instanceof PostgresDriver)\n                    // cast to JSON to trigger parsing in the driver\n                    if (column.precision) {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;\n                    } else {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n                    }\n                if (this.connection.driver instanceof SqlServerDriver)\n                    selectionPath = `${selectionPath}.ToString()`;\n            }\n            return {\n                selection: selectionPath,\n                aliasName: selection && selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(this.connection.driver, aliasName, column.databaseName),\n                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                virtual: selection ? selection.virtual === true : (hasMainAlias ? false : true),\n            };\n        });\n    }\n\n    protected findEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\n        if (mainSelect)\n            return [mainSelect];\n\n        return this.expressionMap.selects.filter(select => {\n            return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyPath);\n        });\n    }\n\n    private computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias!.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        const primaryColumns = metadata.primaryColumns;\n        const distinctAlias = this.escape(mainAlias);\n\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (\n            this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0\n        ) {\n            return \"COUNT(1)\";\n        }\n\n        // For everything else, we'll need to do some hackery to get the correct count values.\n\n        if (this.connection.driver instanceof CockroachDriver || this.connection.driver instanceof PostgresDriver) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return \"COUNT(DISTINCT(\" +\n                primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") +\n                \"))\";\n        }\n\n        if (this.connection.driver instanceof MysqlDriver) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return \"COUNT(DISTINCT \" +\n                primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") +\n                \")\";\n        }\n\n        if (this.connection.driver instanceof SqlServerDriver) {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n\n            const columnsExpression = primaryColumns.map(\n                primaryColumn => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`\n            ).join(\", '|;|', \");\n\n            if (primaryColumns.length === 1) {\n\n                return `COUNT(DISTINCT(${columnsExpression}))`;\n            }\n\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n\n        }\n\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n\n        return `COUNT(DISTINCT(` +\n            primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\" || '|;|' || \") +\n            \"))\";\n    }\n\n    protected async executeCountQuery(queryRunner: QueryRunner): Promise<number> {\n        const countSql = this.computeCountExpression();\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner);\n\n        if (!results || !results[0] || !results[0][\"cnt\"])\n            return 0;\n\n        return parseInt(results[0][\"cnt\"]);\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(queryRunner: QueryRunner): Promise<{ entities: Entity[], raw: any[] }> {\n\n        if (!this.expressionMap.mainAlias)\n            throw new Error(`Alias is not set. Use \"from\" method to set an alias.`);\n\n        if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\" || this.expressionMap.lockMode === \"pessimistic_partial_write\" || this.expressionMap.lockMode === \"pessimistic_write_or_fail\" || this.expressionMap.lockMode === \"for_no_key_update\") && !queryRunner.isTransactionActive)\n            throw new PessimisticLockTransactionRequiredError();\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name);\n        }\n\n        const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\n        const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\n        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n        relationIdMetadataTransformer.transform();\n        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n        relationCountMetadataTransformer.transform();\n\n        let rawResults: any[] = [], entities: any[] = [];\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {\n\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n            const metadata = this.expressionMap.mainAlias.metadata;\n            const mainAliasName = this.expressionMap.mainAlias.name;\n\n            const querySelects = metadata.primaryColumns.map(primaryColumn => {\n                const distinctAlias = this.escape(\"distinctAlias\");\n                const columnAlias = this.escape(DriverUtils.buildAlias(this.connection.driver, mainAliasName, primaryColumn.databaseName));\n                if (!orderBys[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction\n                    orderBys[columnAlias] = \"ASC\";\n\n                const alias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    \"ids_\" + mainAliasName,\n                    primaryColumn.databaseName\n                );\n\n                return `${distinctAlias}.${columnAlias} as \"${alias}\"`;\n            });\n\n            rawResults = await new SelectQueryBuilder(this.connection, queryRunner)\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(`(${this.clone().orderBy().getQuery()})`, \"distinctAlias\")\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(this.expressionMap.cache ? this.expressionMap.cache : this.expressionMap.cacheId, this.expressionMap.cacheDuration)\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany();\n\n            if (rawResults.length > 0) {\n                let condition = \"\";\n                const parameters: ObjectLiteral = {};\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults.map((result, index) => {\n                        return metadata.primaryColumns.map(primaryColumn => {\n                            const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n                            parameters[paramKey] = result[`ids_${mainAliasName}_${primaryColumn.databaseName}`];\n                            return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n                        }).join(\" AND \");\n                    }).join(\" OR \");\n                } else {\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        \"ids_\" + mainAliasName,\n                        metadata.primaryColumns[0].databaseName\n                    );\n\n                    const ids = rawResults.map(result => result[alias]);\n                    const areAllNumbers = ids.every((id: any) => typeof id === \"number\");\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(\", \")})`;\n                    } else {\n                        parameters[\"orm_distinct_ids\"] = ids;\n                        condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyPath + \" IN (:...orm_distinct_ids)\";\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({ extraAppendedAndWhereCondition: condition })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner);\n            }\n\n        } else {\n            rawResults = await this.loadRawResults(queryRunner);\n        }\n\n        if (rawResults.length > 0) {\n\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(rawResults);\n            const rawRelationCountResults = await relationCountLoader.load(rawResults);\n            const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);\n            entities = transformer.transform(rawResults, this.expressionMap.mainAlias!);\n\n            // broadcast all \"after load\" events\n            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n                const broadcastResult = new BroadcasterResult();\n                queryRunner.broadcaster.broadcastLoadEventsForAll(broadcastResult, this.expressionMap.mainAlias.metadata, entities);\n                if (broadcastResult.promises.length > 0) await Promise.all(broadcastResult.promises);\n            }\n        }\n\n        return {\n            raw: rawResults,\n            entities: entities,\n        };\n    }\n\n    protected createOrderByCombinedWithSelectExpression(parentAlias: string): [ string, OrderByCondition] {\n\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys;\n        const selectString = Object.keys(orderBys)\n            .map(orderCriteria => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const criteriaParts = orderCriteria.split(\".\");\n                    const aliasName = criteriaParts[0];\n                    const propertyPath = criteriaParts.slice(1).join(\".\");\n                    const alias = this.expressionMap.findAliasByName(aliasName);\n                    const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                    return this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, aliasName, column!.databaseName));\n                } else {\n                    if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria))\n                        return this.escape(parentAlias) + \".\" + orderCriteria;\n\n                    return \"\";\n                }\n            })\n            .join(\", \");\n\n        const orderByObject: OrderByCondition = {};\n        Object.keys(orderBys).forEach(orderCriteria => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\");\n                const aliasName = criteriaParts[0];\n                const propertyPath = criteriaParts.slice(1).join(\".\");\n                const alias = this.expressionMap.findAliasByName(aliasName);\n                const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                orderByObject[this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, aliasName, column!.databaseName))] = orderBys[orderCriteria];\n            } else {\n                if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) {\n                    orderByObject[this.escape(parentAlias) + \".\" + orderCriteria] = orderBys[orderCriteria];\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria];\n                }\n            }\n        });\n\n        return [selectString, orderByObject];\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n        const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n        let savedQueryResultCacheOptions: QueryResultCacheOptions|undefined = undefined;\n        let cacheError = false;\n        if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\n            try {\n                savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\n                }, queryRunner);\n                if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions))\n                    return JSON.parse(savedQueryResultCacheOptions.result);\n            } catch(error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error;\n                }\n                cacheError = true;\n            }\n        }\n\n        const results = await queryRunner.query(sql, parameters);\n\n        if (!cacheError && this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\n            try {\n                await this.connection.queryResultCache.storeInCache({\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    time: new Date().getTime(),\n                    duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\n                    result: JSON.stringify(results)\n                }, savedQueryResultCacheOptions, queryRunner);\n            } catch(error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error;\n                }\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(expressionMap: Partial<QueryExpressionMap>): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap);\n        return this;\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num;\n\n        return Number(num);\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}