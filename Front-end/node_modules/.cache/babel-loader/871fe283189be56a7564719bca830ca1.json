{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../\";\n/**\n * Marks a entity property as a parent of the tree.\n * \"Tree parent\" indicates who owns (is a parent) of this entity in tree structure.\n */\n\nexport function TreeParent(options) {\n  return function (object, propertyName) {\n    if (!options) options = {}; // now try to determine it its lazy relation\n\n    var reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    var isLazy = reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\" || false;\n    getMetadataArgsStorage().relations.push({\n      isTreeParent: true,\n      target: object.constructor,\n      propertyName: propertyName,\n      isLazy: isLazy,\n      relationType: \"many-to-one\",\n      type: function () {\n        return object.constructor;\n      },\n      options: options\n    });\n  };\n}","map":{"version":3,"sources":["../browser/src/decorator/tree/TreeParent.ts"],"names":[],"mappings":"AAAA,SAAQ,sBAAR,QAAqC,QAArC;AAKA;;;AAGG;;AACH,OAAM,SAAU,UAAV,CAAqB,OAArB,EAA0D;AAC5D,SAAO,UAAU,MAAV,EAA0B,YAA1B,EAA8C;AACjD,QAAI,CAAC,OAAL,EAAc,OAAO,GAAG,EAAV,CADmC,CAGjD;;AACA,QAAM,aAAa,GAAG,OAAO,IAAK,OAAe,CAAC,WAA5B,GAA0C,OAAO,CAAC,WAAR,CAAoB,aAApB,EAAmC,MAAnC,EAA2C,YAA3C,CAA1C,GAAqG,SAA3H;AACA,QAAM,MAAM,GAAI,aAAa,IAAI,OAAO,aAAa,CAAC,IAArB,KAA8B,QAA/C,IAA2D,aAAa,CAAC,IAAd,CAAmB,WAAnB,OAAqC,SAAjG,IAA+G,KAA9H;AAEA,IAAA,sBAAsB,GAAG,SAAzB,CAAmC,IAAnC,CAAwC;AACpC,MAAA,YAAY,EAAE,IADsB;AAEpC,MAAA,MAAM,EAAE,MAAM,CAAC,WAFqB;AAGpC,MAAA,YAAY,EAAE,YAHsB;AAIpC,MAAA,MAAM,EAAE,MAJ4B;AAKpC,MAAA,YAAY,EAAE,aALsB;AAMpC,MAAA,IAAI,EAAE,YAAA;AAAM,eAAA,MAAM,CAAN,WAAA;AAAkB,OANM;AAOpC,MAAA,OAAO,EAAE;AAP2B,KAAxC;AASH,GAhBD;AAiBH","sourcesContent":["import {getMetadataArgsStorage} from \"../../\";\nimport {RelationMetadataArgs} from \"../../metadata-args/RelationMetadataArgs\";\nimport {OnDeleteType} from \"../../metadata/types/OnDeleteType\";\nimport {RelationOptions} from \"../options/RelationOptions\";\n\n/**\n * Marks a entity property as a parent of the tree.\n * \"Tree parent\" indicates who owns (is a parent) of this entity in tree structure.\n */\nexport function TreeParent(options?: { onDelete?: OnDeleteType }): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions;\n\n        // now try to determine it its lazy relation\n        const reflectedType = Reflect && (Reflect as any).getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n        const isLazy = (reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\") || false;\n\n        getMetadataArgsStorage().relations.push({\n            isTreeParent: true,\n            target: object.constructor,\n            propertyName: propertyName,\n            isLazy: isLazy,\n            relationType: \"many-to-one\",\n            type: () => object.constructor,\n            options: options\n        } as RelationMetadataArgs);\n    };\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}