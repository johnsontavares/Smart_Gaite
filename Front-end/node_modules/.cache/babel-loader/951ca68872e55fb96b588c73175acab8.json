{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\n\nvar ReturningResultsEntityUpdator =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function ReturningResultsEntityUpdator(queryRunner, expressionMap) {\n    this.queryRunner = queryRunner;\n    this.expressionMap = expressionMap;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Updates entities with a special columns after updation query execution.\n   */\n\n\n  ReturningResultsEntityUpdator.prototype.update = function (updateResult, entities) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.expressionMap.mainAlias.metadata;\n            return [4\n            /*yield*/\n            , Promise.all(entities.map(function (entity, entityIndex) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var result, returningColumns, updationColumns, entityId, loadedReturningColumns;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!this.queryRunner.connection.driver.isReturningSqlSupported()) return [3\n                      /*break*/\n                      , 1];\n\n                      if (this.queryRunner.connection.driver instanceof OracleDriver && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n                        updateResult.raw = updateResult.raw.reduce(function (newRaw, rawItem, rawItemIndex) {\n                          newRaw[_this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                          return newRaw;\n                        }, {});\n                      }\n\n                      result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;\n                      returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\n\n                      if (returningColumns) {\n                        this.queryRunner.manager.merge(metadata.target, entity, returningColumns);\n                        updateResult.generatedMaps.push(returningColumns);\n                      }\n\n                      return [3\n                      /*break*/\n                      , 3];\n\n                    case 1:\n                      updationColumns = this.getUpdationReturningColumns();\n                      if (!(updationColumns.length > 0)) return [3\n                      /*break*/\n                      , 3];\n                      entityId = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n                      if (!entityId) throw new Error(\"Cannot update entity because entity id is not set in the entity.\");\n                      return [4\n                      /*yield*/\n                      , this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map(function (column) {\n                        return metadata.targetName + \".\" + column.propertyPath;\n                      })).addSelect(this.getUpdationReturningColumns().map(function (column) {\n                        return metadata.targetName + \".\" + column.propertyPath;\n                      })).from(metadata.target, metadata.targetName).where(entityId).setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\n                      .getOne()];\n\n                    case 2:\n                      loadedReturningColumns = _a.sent();\n\n                      if (loadedReturningColumns) {\n                        this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);\n                        updateResult.generatedMaps.push(loadedReturningColumns);\n                      }\n\n                      _a.label = 3;\n\n                    case 3:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Updates entities with a special columns after insertion query execution.\n   */\n\n\n  ReturningResultsEntityUpdator.prototype.insert = function (insertResult, entities) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, insertionColumns, generatedMaps, entityIds, returningResult_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.expressionMap.mainAlias.metadata;\n            insertionColumns = this.getInsertionReturningColumns();\n            generatedMaps = entities.map(function (entity, entityIndex) {\n              if (_this.queryRunner.connection.driver instanceof OracleDriver && Array.isArray(insertResult.raw) && _this.expressionMap.extraReturningColumns.length > 0) {\n                insertResult.raw = insertResult.raw.reduce(function (newRaw, rawItem, rawItemIndex) {\n                  newRaw[_this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                  return newRaw;\n                }, {});\n              } // get all values generated by a database for us\n\n\n              var result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;\n              var generatedMap = _this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {}; // if database does not support uuid generation we need to get uuid values\n              // generated by orm and set them to the generatedMap\n\n              if (_this.queryRunner.connection.driver.isUUIDGenerationSupported() === false) {\n                metadata.generatedColumns.forEach(function (generatedColumn) {\n                  if (generatedColumn.generationStrategy === \"uuid\") {\n                    // uuid can be defined by user in a model, that's why first we get it\n                    var uuid = generatedColumn.getEntityValue(entity);\n                    if (!uuid) // if it was not defined by a user then InsertQueryBuilder generates it by its own, get this generated uuid value\n                      uuid = _this.expressionMap.nativeParameters[\"uuid_\" + generatedColumn.databaseName + entityIndex];\n                    OrmUtils.mergeDeep(generatedMap, generatedColumn.createValueMap(uuid));\n                  }\n                });\n              }\n\n              _this.queryRunner.manager.merge(metadata.target, entity, generatedMap); // todo: this should not be here, but problem with below line\n\n\n              return generatedMap;\n            });\n            if (!(this.queryRunner.connection.driver.isReturningSqlSupported() === false && insertionColumns.length > 0)) return [3\n            /*break*/\n            , 2];\n            entityIds = entities.map(function (entity) {\n              var entityId = metadata.getEntityIdMap(entity); // We have to check for an empty `entityId` - if we don't, the query against the database\n              // effectively drops the `where` clause entirely and the first record will be returned -\n              // not what we want at all.\n\n              if (!entityId) throw new Error(\"Cannot update entity because entity id is not set in the entity.\");\n              return entityId;\n            });\n            return [4\n            /*yield*/\n            , this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map(function (column) {\n              return metadata.targetName + \".\" + column.propertyPath;\n            })).addSelect(insertionColumns.map(function (column) {\n              return metadata.targetName + \".\" + column.propertyPath;\n            })).from(metadata.target, metadata.targetName).where(entityIds).setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\n            .getMany()];\n\n          case 1:\n            returningResult_1 = _a.sent();\n            entities.forEach(function (entity, entityIndex) {\n              _this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult_1[entityIndex]);\n            });\n            _a.label = 2;\n\n          case 2:\n            entities.forEach(function (entity, entityIndex) {\n              var entityId = metadata.getEntityIdMap(entity);\n              insertResult.identifiers.push(entityId);\n              insertResult.generatedMaps.push(generatedMaps[entityIndex]);\n\n              _this.queryRunner.manager.merge(_this.expressionMap.mainAlias.metadata.target, entity, generatedMaps[entityIndex], generatedMaps[entityIndex]); // todo: why twice?!\n\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Columns we need to be returned from the database when we insert entity.\n   */\n\n\n  ReturningResultsEntityUpdator.prototype.getInsertionReturningColumns = function () {\n    // for databases which support returning statement we need to return extra columns like id\n    // for other databases we don't need to return id column since its returned by a driver already\n    var needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported(); // filter out the columns of which we need database inserted values to update our entity\n\n    return this.expressionMap.mainAlias.metadata.columns.filter(function (column) {\n      return column.default !== undefined || needToCheckGenerated && column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;\n    });\n  };\n  /**\n   * Columns we need to be returned from the database when we update entity.\n   */\n\n\n  ReturningResultsEntityUpdator.prototype.getUpdationReturningColumns = function () {\n    return this.expressionMap.mainAlias.metadata.columns.filter(function (column) {\n      return column.isUpdateDate || column.isVersion;\n    });\n  };\n\n  return ReturningResultsEntityUpdator;\n}();\n\nexport { ReturningResultsEntityUpdator };","map":{"version":3,"sources":["../browser/src/query-builder/ReturningResultsEntityUpdator.ts"],"names":[],"mappings":"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","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {UpdateResult} from \"./result/UpdateResult\";\nimport {InsertResult} from \"./result/InsertResult\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\n\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner,\n                protected expressionMap: QueryExpressionMap) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates entities with a special columns after updation query execution.\n     */\n    async update(updateResult: UpdateResult, entities: ObjectLiteral[]): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata;\n\n        await Promise.all(entities.map(async (entity, entityIndex) => {\n\n            // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n            if (this.queryRunner.connection.driver.isReturningSqlSupported()) {\n                if (this.queryRunner.connection.driver instanceof OracleDriver && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n                    updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                        newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                        return newRaw;\n                    }, {} as ObjectLiteral);\n                }\n                const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;\n                const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\n                if (returningColumns) {\n                    this.queryRunner.manager.merge(metadata.target as any, entity, returningColumns);\n                    updateResult.generatedMaps.push(returningColumns);\n                }\n\n            } else {\n\n                // for driver which do not support returning/output statement we need to perform separate query and load what we need\n                const updationColumns = this.getUpdationReturningColumns();\n                if (updationColumns.length > 0) {\n\n                    // get entity id by which we will get needed data\n                    const entityId = this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity);\n                    if (!entityId)\n                        throw new Error(`Cannot update entity because entity id is not set in the entity.`);\n\n                    // execute query to get needed data\n                    const loadedReturningColumns = await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\n                        .addSelect(this.getUpdationReturningColumns().map(column => metadata.targetName + \".\" + column.propertyPath))\n                        .from(metadata.target, metadata.targetName)\n                        .where(entityId)\n                        .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\n                        .getOne() as any;\n\n                    if (loadedReturningColumns) {\n                        this.queryRunner.manager.merge(metadata.target as any, entity, loadedReturningColumns);\n                        updateResult.generatedMaps.push(loadedReturningColumns);\n                    }\n                }\n            }\n        }));\n    }\n\n    /**\n     * Updates entities with a special columns after insertion query execution.\n     */\n    async insert(insertResult: InsertResult, entities: ObjectLiteral[]): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata;\n        const insertionColumns = this.getInsertionReturningColumns();\n\n        const generatedMaps = entities.map((entity, entityIndex) => {\n            if (this.queryRunner.connection.driver instanceof OracleDriver && Array.isArray(insertResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n                insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                    newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                    return newRaw;\n                }, {} as ObjectLiteral);\n            }\n            // get all values generated by a database for us\n            const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;\n            const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};\n\n            // if database does not support uuid generation we need to get uuid values\n            // generated by orm and set them to the generatedMap\n            if (this.queryRunner.connection.driver.isUUIDGenerationSupported() === false) {\n                metadata.generatedColumns.forEach(generatedColumn => {\n                    if (generatedColumn.generationStrategy === \"uuid\") {\n                        // uuid can be defined by user in a model, that's why first we get it\n                        let uuid = generatedColumn.getEntityValue(entity);\n                        if (!uuid) // if it was not defined by a user then InsertQueryBuilder generates it by its own, get this generated uuid value\n                            uuid = this.expressionMap.nativeParameters[\"uuid_\" + generatedColumn.databaseName + entityIndex];\n\n                        OrmUtils.mergeDeep(generatedMap, generatedColumn.createValueMap(uuid));\n                    }\n                });\n            }\n\n            this.queryRunner.manager.merge(metadata.target as any, entity, generatedMap); // todo: this should not be here, but problem with below line\n            return generatedMap;\n        });\n\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n        // for other drivers we have to re-select this data from the database\n        if (this.queryRunner.connection.driver.isReturningSqlSupported() === false && insertionColumns.length > 0) {\n            const entityIds = entities.map((entity) => {\n                const entityId = metadata.getEntityIdMap(entity)!;\n\n                // We have to check for an empty `entityId` - if we don't, the query against the database\n                // effectively drops the `where` clause entirely and the first record will be returned -\n                // not what we want at all.\n                if (!entityId)\n                    throw new Error(`Cannot update entity because entity id is not set in the entity.`);\n\n                return entityId;\n            });\n\n            // to select just inserted entities we need a criteria to select by.\n            // for newly inserted entities in drivers which do not support returning statement\n            // row identifier can only be an increment column\n            // (since its the only thing that can be generated by those databases)\n            // or (and) other primary key which is defined by a user and inserted value has it\n\n            const returningResult: any = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\n                .addSelect(insertionColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\n                .from(metadata.target, metadata.targetName)\n                .where(entityIds)\n                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\n                .getMany();\n\n            entities.forEach((entity, entityIndex) => {\n                this.queryRunner.manager.merge(metadata.target as any, generatedMaps[entityIndex], returningResult[entityIndex]);\n            });\n        }\n\n        entities.forEach((entity, entityIndex) => {\n            const entityId = metadata.getEntityIdMap(entity)!;\n            insertResult.identifiers.push(entityId);\n            insertResult.generatedMaps.push(generatedMaps[entityIndex]);\n            this.queryRunner.manager.merge(this.expressionMap.mainAlias!.metadata.target as any, entity, generatedMaps[entityIndex], generatedMaps[entityIndex]); // todo: why twice?!\n        });\n    }\n\n    /**\n     * Columns we need to be returned from the database when we insert entity.\n     */\n    getInsertionReturningColumns(): ColumnMetadata[] {\n\n        // for databases which support returning statement we need to return extra columns like id\n        // for other databases we don't need to return id column since its returned by a driver already\n        const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported();\n\n        // filter out the columns of which we need database inserted values to update our entity\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\n            return  column.default !== undefined ||\n                    (needToCheckGenerated && column.isGenerated)  ||\n                    column.isCreateDate ||\n                    column.isUpdateDate ||\n                    column.isDeleteDate ||\n                    column.isVersion;\n        });\n    }\n\n    /**\n     * Columns we need to be returned from the database when we update entity.\n     */\n    getUpdationReturningColumns(): ColumnMetadata[] {\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\n            return column.isUpdateDate || column.isVersion;\n        });\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}