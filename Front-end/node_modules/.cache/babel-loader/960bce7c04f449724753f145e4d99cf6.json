{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../\";\n/**\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\n */\n\nexport function Entity(nameOrOptions, maybeOptions) {\n  var options = (typeof nameOrOptions === \"object\" ? nameOrOptions : maybeOptions) || {};\n  var name = typeof nameOrOptions === \"string\" ? nameOrOptions : options.name;\n  return function (target) {\n    getMetadataArgsStorage().tables.push({\n      target: target,\n      name: name,\n      type: \"regular\",\n      orderBy: options.orderBy ? options.orderBy : undefined,\n      engine: options.engine ? options.engine : undefined,\n      database: options.database ? options.database : undefined,\n      schema: options.schema ? options.schema : undefined,\n      synchronize: options.synchronize,\n      withoutRowid: options.withoutRowid\n    });\n  };\n}","map":{"version":3,"sources":["../browser/src/decorator/entity/Entity.ts"],"names":[],"mappings":"AAAA,SAAuB,sBAAvB,QAAoD,QAApD;AAeA;;;AAGG;;AACH,OAAM,SAAU,MAAV,CAAiB,aAAjB,EAAuD,YAAvD,EAAmF;AACrF,MAAM,OAAO,GAAG,CAAC,OAAO,aAAP,KAAyB,QAAzB,GAAoC,aAApC,GAAqE,YAAtE,KAAuF,EAAvG;AACA,MAAM,IAAI,GAAG,OAAO,aAAP,KAAyB,QAAzB,GAAoC,aAApC,GAAoD,OAAO,CAAC,IAAzE;AAEA,SAAO,UAAU,MAAV,EAAgB;AACnB,IAAA,sBAAsB,GAAG,MAAzB,CAAgC,IAAhC,CAAqC;AACjC,MAAA,MAAM,EAAE,MADyB;AAEjC,MAAA,IAAI,EAAE,IAF2B;AAGjC,MAAA,IAAI,EAAE,SAH2B;AAIjC,MAAA,OAAO,EAAE,OAAO,CAAC,OAAR,GAAkB,OAAO,CAAC,OAA1B,GAAoC,SAJZ;AAKjC,MAAA,MAAM,EAAE,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAzB,GAAkC,SALT;AAMjC,MAAA,QAAQ,EAAE,OAAO,CAAC,QAAR,GAAmB,OAAO,CAAC,QAA3B,GAAsC,SANf;AAOjC,MAAA,MAAM,EAAE,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAzB,GAAkC,SAPT;AAQjC,MAAA,WAAW,EAAE,OAAO,CAAC,WARY;AASjC,MAAA,YAAY,EAAE,OAAO,CAAC;AATW,KAArC;AAWH,GAZD;AAaH","sourcesContent":["import {EntityOptions, getMetadataArgsStorage} from \"../../\";\nimport {TableMetadataArgs} from \"../../metadata-args/TableMetadataArgs\";\n\n/**\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\n */\nexport function Entity(options?: EntityOptions): ClassDecorator;\n\n/**\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\n */\nexport function Entity(name?: string, options?: EntityOptions): ClassDecorator;\n\n/**\n * This decorator is used to mark classes that will be an entity (table or document depend on database type).\n * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.\n */\nexport function Entity(nameOrOptions?: string|EntityOptions, maybeOptions?: EntityOptions): ClassDecorator {\n    const options = (typeof nameOrOptions === \"object\" ? nameOrOptions as EntityOptions : maybeOptions) || {};\n    const name = typeof nameOrOptions === \"string\" ? nameOrOptions : options.name;\n\n    return function (target) {\n        getMetadataArgsStorage().tables.push({\n            target: target,\n            name: name,\n            type: \"regular\",\n            orderBy: options.orderBy ? options.orderBy : undefined,\n            engine: options.engine ? options.engine : undefined,\n            database: options.database ? options.database : undefined,\n            schema: options.schema ? options.schema : undefined,\n            synchronize: options.synchronize,\n            withoutRowid: options.withoutRowid\n        } as TableMetadataArgs);\n    };\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}