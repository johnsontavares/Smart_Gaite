{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { Repository } from \"./Repository\";\nimport { AbstractSqliteDriver } from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\n\nvar TreeRepository =\n/** @class */\nfunction (_super) {\n  __extends(TreeRepository, _super);\n\n  function TreeRepository() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets complete trees for all roots in the table.\n   */\n\n\n  TreeRepository.prototype.findTrees = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var roots;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.findRoots()];\n\n          case 1:\n            roots = _a.sent();\n            return [4\n            /*yield*/\n            , Promise.all(roots.map(function (root) {\n              return _this.findDescendantsTree(root);\n            }))];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , roots];\n        }\n      });\n    });\n  };\n  /**\n   * Roots are entities that have no ancestors. Finds them all.\n   */\n\n\n  TreeRepository.prototype.findRoots = function () {\n    var _this = this;\n\n    var escapeAlias = function (alias) {\n      return _this.manager.connection.driver.escape(alias);\n    };\n\n    var escapeColumn = function (column) {\n      return _this.manager.connection.driver.escape(column);\n    };\n\n    var parentPropertyName = this.manager.connection.namingStrategy.joinColumnName(this.metadata.treeParentRelation.propertyName, this.metadata.primaryColumns[0].propertyName);\n    return this.createQueryBuilder(\"treeEntity\").where(escapeAlias(\"treeEntity\") + \".\" + escapeColumn(parentPropertyName) + \" IS NULL\").getMany();\n  };\n  /**\n   * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n   */\n\n\n  TreeRepository.prototype.findDescendants = function (entity) {\n    return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getMany();\n  };\n  /**\n   * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n   */\n\n\n  TreeRepository.prototype.findDescendantsTree = function (entity) {\n    var _this = this; // todo: throw exception if there is no column of this relation?\n\n\n    return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getRawAndEntities().then(function (entitiesAndScalars) {\n      var relationMaps = _this.createRelationMaps(\"treeEntity\", entitiesAndScalars.raw);\n\n      _this.buildChildrenEntityTree(entity, entitiesAndScalars.entities, relationMaps);\n\n      return entity;\n    });\n  };\n  /**\n   * Gets number of descendants of the entity.\n   */\n\n\n  TreeRepository.prototype.countDescendants = function (entity) {\n    return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  };\n  /**\n   * Creates a query builder used to get descendants of the entities in a tree.\n   */\n\n\n  TreeRepository.prototype.createDescendantsQueryBuilder = function (alias, closureTableAlias, entity) {\n    var _this = this; // create shortcuts for better readability\n\n\n    var escape = function (alias) {\n      return _this.manager.connection.driver.escape(alias);\n    };\n\n    if (this.metadata.treeType === \"closure-table\") {\n      var joinCondition = this.metadata.closureJunctionTable.descendantColumns.map(function (column) {\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = \" + escape(alias) + \".\" + escape(column.referencedColumn.propertyPath);\n      }).join(\" AND \");\n      var parameters_1 = {};\n      var whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map(function (column) {\n        parameters_1[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters_1);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      var whereCondition = alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND joined.\" + this.metadata.nestedSetRightColumn.propertyPath;\n      var parameters_2 = {};\n      var joinCondition = this.metadata.treeParentRelation.joinColumns.map(function (joinColumn) {\n        var parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters_2[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", whereCondition).where(joinCondition, parameters_2);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      return this.createQueryBuilder(alias).where(function (qb) {\n        var subQuery = qb.subQuery().select(_this.metadata.targetName + \".\" + _this.metadata.materializedPathColumn.propertyPath, \"path\").from(_this.metadata.target, _this.metadata.targetName).whereInIds(_this.metadata.getEntityIdMap(entity));\n        qb.setNativeParameters(subQuery.expressionMap.nativeParameters);\n\n        if (_this.manager.connection.driver instanceof AbstractSqliteDriver) {\n          return alias + \".\" + _this.metadata.materializedPathColumn.propertyPath + \" LIKE \" + subQuery.getQuery() + \" || '%'\";\n        } else {\n          return alias + \".\" + _this.metadata.materializedPathColumn.propertyPath + \" LIKE CONCAT(\" + subQuery.getQuery() + \", '%')\";\n        }\n      });\n    }\n\n    throw new Error(\"Supported only in tree entities\");\n  };\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n   */\n\n\n  TreeRepository.prototype.findAncestors = function (entity) {\n    return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getMany();\n  };\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n   */\n\n\n  TreeRepository.prototype.findAncestorsTree = function (entity) {\n    var _this = this; // todo: throw exception if there is no column of this relation?\n\n\n    return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getRawAndEntities().then(function (entitiesAndScalars) {\n      var relationMaps = _this.createRelationMaps(\"treeEntity\", entitiesAndScalars.raw);\n\n      _this.buildParentEntityTree(entity, entitiesAndScalars.entities, relationMaps);\n\n      return entity;\n    });\n  };\n  /**\n   * Gets number of ancestors of the entity.\n   */\n\n\n  TreeRepository.prototype.countAncestors = function (entity) {\n    return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  };\n  /**\n   * Creates a query builder used to get ancestors of the entities in the tree.\n   */\n\n\n  TreeRepository.prototype.createAncestorsQueryBuilder = function (alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n    var _this = this;\n\n    if (this.metadata.treeType === \"closure-table\") {\n      var joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map(function (column) {\n        return closureTableAlias + \".\" + column.propertyPath + \" = \" + alias + \".\" + column.referencedColumn.propertyPath;\n      }).join(\" AND \");\n      var parameters_3 = {};\n      var whereCondition = this.metadata.closureJunctionTable.descendantColumns.map(function (column) {\n        parameters_3[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return closureTableAlias + \".\" + column.propertyPath + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters_3);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      var joinCondition = \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND \" + alias + \".\" + this.metadata.nestedSetRightColumn.propertyPath;\n      var parameters_4 = {};\n      var whereCondition = this.metadata.treeParentRelation.joinColumns.map(function (joinColumn) {\n        var parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters_4[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", joinCondition).where(whereCondition, parameters_4);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n      return this.createQueryBuilder(alias).where(function (qb) {\n        var subQuery = qb.subQuery().select(_this.metadata.targetName + \".\" + _this.metadata.materializedPathColumn.propertyPath, \"path\").from(_this.metadata.target, _this.metadata.targetName).whereInIds(_this.metadata.getEntityIdMap(entity));\n        qb.setNativeParameters(subQuery.expressionMap.nativeParameters);\n\n        if (_this.manager.connection.driver instanceof AbstractSqliteDriver) {\n          return subQuery.getQuery() + \" LIKE \" + alias + \".\" + _this.metadata.materializedPathColumn.propertyPath + \" || '%'\";\n        } else {\n          return subQuery.getQuery() + \" LIKE CONCAT(\" + alias + \".\" + _this.metadata.materializedPathColumn.propertyPath + \", '%')\";\n        }\n      });\n    }\n\n    throw new Error(\"Supported only in tree entities\");\n  };\n  /**\n   * Moves entity to the children of then given entity.\n   *\n  move(entity: Entity, to: Entity): Promise<void> {\n      return Promise.resolve();\n  } */\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n\n  TreeRepository.prototype.createRelationMaps = function (alias, rawResults) {\n    var _this = this;\n\n    return rawResults.map(function (rawResult) {\n      var joinColumn = _this.metadata.treeParentRelation.joinColumns[0]; // fixes issue #2518, default to databaseName property when givenDatabaseName is not set\n\n      var joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n      var id = rawResult[alias + \"_\" + _this.metadata.primaryColumns[0].databaseName];\n      var parentId = rawResult[alias + \"_\" + joinColumnName];\n      return {\n        id: _this.manager.connection.driver.prepareHydratedValue(id, _this.metadata.primaryColumns[0]),\n        parentId: _this.manager.connection.driver.prepareHydratedValue(parentId, joinColumn)\n      };\n    });\n  };\n\n  TreeRepository.prototype.buildChildrenEntityTree = function (entity, entities, relationMaps) {\n    var _this = this;\n\n    var childProperty = this.metadata.treeChildrenRelation.propertyName;\n    var parentEntityId = this.metadata.primaryColumns[0].getEntityValue(entity);\n    var childRelationMaps = relationMaps.filter(function (relationMap) {\n      return relationMap.parentId === parentEntityId;\n    });\n    var childIds = new Set(childRelationMaps.map(function (relationMap) {\n      return relationMap.id;\n    }));\n    entity[childProperty] = entities.filter(function (entity) {\n      return childIds.has(_this.metadata.primaryColumns[0].getEntityValue(entity));\n    });\n    entity[childProperty].forEach(function (childEntity) {\n      _this.buildChildrenEntityTree(childEntity, entities, relationMaps);\n    });\n  };\n\n  TreeRepository.prototype.buildParentEntityTree = function (entity, entities, relationMaps) {\n    var _this = this;\n\n    var parentProperty = this.metadata.treeParentRelation.propertyName;\n    var entityId = this.metadata.primaryColumns[0].getEntityValue(entity);\n    var parentRelationMap = relationMaps.find(function (relationMap) {\n      return relationMap.id === entityId;\n    });\n    var parentEntity = entities.find(function (entity) {\n      if (!parentRelationMap) return false;\n      return _this.metadata.primaryColumns[0].getEntityValue(entity) === parentRelationMap.parentId;\n    });\n\n    if (parentEntity) {\n      entity[parentProperty] = parentEntity;\n      this.buildParentEntityTree(entity[parentProperty], entities, relationMaps);\n    }\n  };\n\n  return TreeRepository;\n}(Repository);\n\nexport { TreeRepository };","map":{"version":3,"sources":["../browser/src/repository/TreeRepository.ts"],"names":[],"mappings":"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","sourcesContent":["import {Repository} from \"./Repository\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {AbstractSqliteDriver} from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\n\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\nexport class TreeRepository<Entity> extends Repository<Entity> {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets complete trees for all roots in the table.\n     */\n    async findTrees(): Promise<Entity[]> {\n        const roots = await this.findRoots();\n        await Promise.all(roots.map(root => this.findDescendantsTree(root)));\n        return roots;\n    }\n\n    /**\n     * Roots are entities that have no ancestors. Finds them all.\n     */\n    findRoots(): Promise<Entity[]> {\n        const escapeAlias = (alias: string) => this.manager.connection.driver.escape(alias);\n        const escapeColumn = (column: string) => this.manager.connection.driver.escape(column);\n        const parentPropertyName = this.manager.connection.namingStrategy.joinColumnName(\n            this.metadata.treeParentRelation!.propertyName, this.metadata.primaryColumns[0].propertyName\n        );\n\n        return this.createQueryBuilder(\"treeEntity\")\n            .where(`${escapeAlias(\"treeEntity\")}.${escapeColumn(parentPropertyName)} IS NULL`)\n            .getMany();\n    }\n\n    /**\n     * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n     */\n    findDescendants(entity: Entity): Promise<Entity[]> {\n        return this\n            .createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity)\n            .getMany();\n    }\n\n    /**\n     * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n     */\n    findDescendantsTree(entity: Entity): Promise<Entity> {\n        // todo: throw exception if there is no column of this relation?\n        return this\n            .createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity)\n            .getRawAndEntities()\n            .then(entitiesAndScalars => {\n                const relationMaps = this.createRelationMaps(\"treeEntity\", entitiesAndScalars.raw);\n                this.buildChildrenEntityTree(entity, entitiesAndScalars.entities, relationMaps);\n                return entity;\n            });\n    }\n\n    /**\n     * Gets number of descendants of the entity.\n     */\n    countDescendants(entity: Entity): Promise<number> {\n        return this\n            .createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity)\n            .getCount();\n    }\n\n    /**\n     * Creates a query builder used to get descendants of the entities in a tree.\n     */\n    createDescendantsQueryBuilder(alias: string, closureTableAlias: string, entity: Entity): SelectQueryBuilder<Entity> {\n\n        // create shortcuts for better readability\n        const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n\n        if (this.metadata.treeType === \"closure-table\") {\n\n            const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n                return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = \" + escape(alias) + \".\" + escape(column.referencedColumn!.propertyPath);\n            }).join(\" AND \");\n\n            const parameters: ObjectLiteral = {};\n            const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n                parameters[column.referencedColumn!.propertyName] = column.referencedColumn!.getEntityValue(entity);\n                return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = :\" + column.referencedColumn!.propertyName;\n            }).join(\" AND \");\n\n            return this\n                .createQueryBuilder(alias)\n                .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)\n                .where(whereCondition)\n                .setParameters(parameters);\n\n        } else if (this.metadata.treeType === \"nested-set\") {\n\n            const whereCondition = alias + \".\" + this.metadata.nestedSetLeftColumn!.propertyPath + \" BETWEEN \" +\n                \"joined.\" + this.metadata.nestedSetLeftColumn!.propertyPath + \" AND joined.\" + this.metadata.nestedSetRightColumn!.propertyPath;\n            const parameters: ObjectLiteral = {};\n            const joinCondition = this.metadata.treeParentRelation!.joinColumns.map(joinColumn => {\n                const parameterName = joinColumn.referencedColumn!.propertyPath.replace(\".\", \"_\");\n                parameters[parameterName] = joinColumn.referencedColumn!.getEntityValue(entity);\n                return \"joined.\" + joinColumn.referencedColumn!.propertyPath + \" = :\" + parameterName;\n            }).join(\" AND \");\n\n            return this\n                .createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", whereCondition)\n                .where(joinCondition, parameters);\n\n        } else if (this.metadata.treeType === \"materialized-path\") {\n            return this\n                .createQueryBuilder(alias)\n                .where(qb => {\n                    const subQuery = qb.subQuery()\n                        .select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn!.propertyPath}`, \"path\")\n                        .from(this.metadata.target, this.metadata.targetName)\n                        .whereInIds(this.metadata.getEntityIdMap(entity));\n\n                    qb.setNativeParameters(subQuery.expressionMap.nativeParameters);\n                    if (this.manager.connection.driver instanceof AbstractSqliteDriver) {\n                        return `${alias}.${this.metadata.materializedPathColumn!.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;\n                    } else {\n                        return `${alias}.${this.metadata.materializedPathColumn!.propertyPath} LIKE CONCAT(${subQuery.getQuery()}, '%')`;\n                    }\n                });\n        }\n\n        throw new Error(`Supported only in tree entities`);\n    }\n\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n     */\n    findAncestors(entity: Entity): Promise<Entity[]> {\n        return this\n            .createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity)\n            .getMany();\n    }\n\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n     */\n    findAncestorsTree(entity: Entity): Promise<Entity> {\n        // todo: throw exception if there is no column of this relation?\n        return this\n            .createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity)\n            .getRawAndEntities()\n            .then(entitiesAndScalars => {\n                const relationMaps = this.createRelationMaps(\"treeEntity\", entitiesAndScalars.raw);\n                this.buildParentEntityTree(entity, entitiesAndScalars.entities, relationMaps);\n                return entity;\n            });\n    }\n\n    /**\n     * Gets number of ancestors of the entity.\n     */\n    countAncestors(entity: Entity): Promise<number> {\n        return this\n            .createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity)\n            .getCount();\n    }\n\n    /**\n     * Creates a query builder used to get ancestors of the entities in the tree.\n     */\n    createAncestorsQueryBuilder(alias: string, closureTableAlias: string, entity: Entity): SelectQueryBuilder<Entity> {\n\n        // create shortcuts for better readability\n        // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n                return closureTableAlias + \".\" + column.propertyPath + \" = \" + alias + \".\" + column.referencedColumn!.propertyPath;\n            }).join(\" AND \");\n\n            const parameters: ObjectLiteral = {};\n            const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n                parameters[column.referencedColumn!.propertyName] = column.referencedColumn!.getEntityValue(entity);\n                return closureTableAlias + \".\" + column.propertyPath + \" = :\" + column.referencedColumn!.propertyName;\n            }).join(\" AND \");\n\n            return this\n                .createQueryBuilder(alias)\n                .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)\n                .where(whereCondition)\n                .setParameters(parameters);\n\n        } else if (this.metadata.treeType === \"nested-set\") {\n\n            const joinCondition = \"joined.\" + this.metadata.nestedSetLeftColumn!.propertyPath + \" BETWEEN \" +\n                alias + \".\" + this.metadata.nestedSetLeftColumn!.propertyPath + \" AND \" + alias + \".\" + this.metadata.nestedSetRightColumn!.propertyPath;\n            const parameters: ObjectLiteral = {};\n            const whereCondition = this.metadata.treeParentRelation!.joinColumns.map(joinColumn => {\n                const parameterName = joinColumn.referencedColumn!.propertyPath.replace(\".\", \"_\");\n                parameters[parameterName] = joinColumn.referencedColumn!.getEntityValue(entity);\n                return \"joined.\" + joinColumn.referencedColumn!.propertyPath + \" = :\" + parameterName;\n            }).join(\" AND \");\n\n            return this\n                .createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", joinCondition)\n                .where(whereCondition, parameters);\n\n\n        } else if (this.metadata.treeType === \"materialized-path\") {\n            // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n            return this\n                .createQueryBuilder(alias)\n                .where(qb => {\n                    const subQuery = qb.subQuery()\n                        .select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn!.propertyPath}`, \"path\")\n                        .from(this.metadata.target, this.metadata.targetName)\n                        .whereInIds(this.metadata.getEntityIdMap(entity));\n\n                    qb.setNativeParameters(subQuery.expressionMap.nativeParameters);\n                    if (this.manager.connection.driver instanceof AbstractSqliteDriver) {\n                        return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn!.propertyPath} || '%'`;\n\n                    } else {\n                        return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn!.propertyPath}, '%')`;\n                    }\n                });\n        }\n\n        throw new Error(`Supported only in tree entities`);\n    }\n\n    /**\n     * Moves entity to the children of then given entity.\n     *\n    move(entity: Entity, to: Entity): Promise<void> {\n        return Promise.resolve();\n    } */\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected createRelationMaps(alias: string, rawResults: any[]): { id: any, parentId: any }[] {\n        return rawResults.map(rawResult => {\n            const joinColumn = this.metadata.treeParentRelation!.joinColumns[0];\n            // fixes issue #2518, default to databaseName property when givenDatabaseName is not set\n            const joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n            const id = rawResult[alias + \"_\" + this.metadata.primaryColumns[0].databaseName];\n            const parentId = rawResult[alias + \"_\" + joinColumnName];\n            return {\n                id: this.manager.connection.driver.prepareHydratedValue(id, this.metadata.primaryColumns[0]),\n                parentId: this.manager.connection.driver.prepareHydratedValue(parentId, joinColumn),\n            };\n        });\n    }\n\n    protected buildChildrenEntityTree(entity: any, entities: any[], relationMaps: { id: any, parentId: any }[]): void {\n        const childProperty = this.metadata.treeChildrenRelation!.propertyName;\n        const parentEntityId = this.metadata.primaryColumns[0].getEntityValue(entity);\n        const childRelationMaps = relationMaps.filter(relationMap => relationMap.parentId === parentEntityId);\n        const childIds = new Set(childRelationMaps.map(relationMap => relationMap.id));\n        entity[childProperty] = entities.filter(entity => childIds.has(this.metadata.primaryColumns[0].getEntityValue(entity)));\n        entity[childProperty].forEach((childEntity: any) => {\n            this.buildChildrenEntityTree(childEntity, entities, relationMaps);\n        });\n    }\n\n    protected buildParentEntityTree(entity: any, entities: any[], relationMaps: { id: any, parentId: any }[]): void {\n        const parentProperty = this.metadata.treeParentRelation!.propertyName;\n        const entityId = this.metadata.primaryColumns[0].getEntityValue(entity);\n        const parentRelationMap = relationMaps.find(relationMap => relationMap.id === entityId);\n        const parentEntity = entities.find(entity => {\n            if (!parentRelationMap)\n                return false;\n\n            return this.metadata.primaryColumns[0].getEntityValue(entity) === parentRelationMap.parentId;\n        });\n        if (parentEntity) {\n            entity[parentProperty] = parentEntity;\n            this.buildParentEntityTree(entity[parentProperty], entities, relationMaps);\n        }\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}