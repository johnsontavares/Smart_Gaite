{"ast":null,"code":"import { __read } from \"tslib\";\nimport { QueryBuilderUtils } from \"../QueryBuilderUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n\nvar RelationCountAttribute =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationCountAttribute(expressionMap, relationCountAttribute) {\n    this.expressionMap = expressionMap;\n    ObjectUtils.assign(this, relationCountAttribute || {});\n  }\n\n  Object.defineProperty(RelationCountAttribute.prototype, \"joinInverseSideMetadata\", {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    get: function () {\n      return this.relation.inverseEntityMetadata;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RelationCountAttribute.prototype, \"parentAlias\", {\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get: function () {\n      if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new Error(\"Given value must be a string representation of alias property\");\n      return this.relationName.split(\".\")[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RelationCountAttribute.prototype, \"relationProperty\", {\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get: function () {\n      if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new Error(\"Given value is a string representation of alias property\");\n      return this.relationName.split(\".\")[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RelationCountAttribute.prototype, \"junctionAlias\", {\n    get: function () {\n      var _a = __read(this.relationName.split(\".\"), 2),\n          parentAlias = _a[0],\n          relationProperty = _a[1];\n\n      return parentAlias + \"_\" + relationProperty + \"_rc\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RelationCountAttribute.prototype, \"relation\", {\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get: function () {\n      if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new Error(\"Given value is a string representation of alias property\");\n\n      var _a = __read(this.relationName.split(\".\"), 2),\n          parentAlias = _a[0],\n          propertyPath = _a[1];\n\n      var relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);\n      var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);\n      if (!relation) throw new Error(\"Relation with property path \" + propertyPath + \" in entity was not found.\");\n      return relation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RelationCountAttribute.prototype, \"metadata\", {\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get: function () {\n      if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new Error(\"Given value is a string representation of alias property\");\n      var parentAlias = this.relationName.split(\".\")[0];\n      var selection = this.expressionMap.findAliasByName(parentAlias);\n      return selection.metadata;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RelationCountAttribute.prototype, \"mapToPropertyPropertyName\", {\n    get: function () {\n      return this.mapToProperty.split(\".\")[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return RelationCountAttribute;\n}();\n\nexport { RelationCountAttribute };","map":{"version":3,"sources":["../browser/src/query-builder/relation-count/RelationCountAttribute.ts"],"names":[],"mappings":"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","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {QueryBuilderUtils} from \"../QueryBuilderUtils\";\nimport {RelationMetadata} from \"../../metadata/RelationMetadata\";\nimport {QueryExpressionMap} from \"../QueryExpressionMap\";\nimport {SelectQueryBuilder} from \"../SelectQueryBuilder\";\nimport {ObjectUtils} from \"../../util/ObjectUtils\";\n\nexport class RelationCountAttribute {\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string;\n\n    /**\n     * Name of relation.\n     */\n    relationName: string;\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty: string;\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private expressionMap: QueryExpressionMap,\n                relationCountAttribute?: Partial<RelationCountAttribute>) {\n        ObjectUtils.assign(this, relationCountAttribute || {});\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get joinInverseSideMetadata(): EntityMetadata {\n        return this.relation.inverseEntityMetadata;\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new Error(`Given value must be a string representation of alias property`);\n\n        return this.relationName.split(\".\")[0];\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationProperty(): string|undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new Error(`Given value is a string representation of alias property`);\n\n        return this.relationName.split(\".\")[1];\n    }\n\n    get junctionAlias(): string {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\");\n        return parentAlias + \"_\" + relationProperty + \"_rc\";\n    }\n\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation(): RelationMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new Error(`Given value is a string representation of alias property`);\n\n        const [parentAlias, propertyPath] = this.relationName.split(\".\");\n        const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);\n        const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\n        return relation;\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new Error(`Given value is a string representation of alias property`);\n\n        const parentAlias = this.relationName.split(\".\")[0];\n        const selection = this.expressionMap.findAliasByName(parentAlias);\n        return selection.metadata;\n    }\n\n    get mapToPropertyPropertyName(): string {\n        return this.mapToProperty!.split(\".\")[1];\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}