{"ast":null,"code":"import { MissingPrimaryColumnError } from \"../error/MissingPrimaryColumnError\";\nimport { CircularRelationsError } from \"../error/CircularRelationsError\";\nimport { DepGraph } from \"../util/DepGraph\";\nimport { DataTypeNotSupportedError } from \"../error/DataTypeNotSupportedError\";\nimport { MongoDriver } from \"../driver/mongodb/MongoDriver\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { NoConnectionOptionError } from \"../error/NoConnectionOptionError\";\nimport { InitializedRelationError } from \"../error/InitializedRelationError\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\"; /// todo: add check if there are multiple tables with the same name\n/// todo: add checks when generated column / table names are too long for the specific driver\n// todo: type in function validation, inverse side function validation\n// todo: check on build for duplicate names, since naming checking was removed from MetadataStorage\n// todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?\n// todo: check if multiple tree parent metadatas in validator\n// todo: tree decorators can be used only on closure table (validation)\n// todo: throw error if parent tree metadata was not specified in a closure table\n// todo: MetadataArgsStorage: type in function validation, inverse side function validation\n// todo: MetadataArgsStorage: check on build for duplicate names, since naming checking was removed from MetadataStorage\n// todo: MetadataArgsStorage: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?\n// todo: MetadataArgsStorage: check for duplicate targets too since this check has been removed too\n// todo: check if relation decorator contains primary: true and nullable: true\n// todo: check column length, precision. scale\n// todo: MySQL index can be unique or spatial or fulltext\n\n/**\n * Validates built entity metadatas.\n */\n\nvar EntityMetadataValidator =\n/** @class */\nfunction () {\n  function EntityMetadataValidator() {} // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Validates all given entity metadatas.\n   */\n\n\n  EntityMetadataValidator.prototype.validateMany = function (entityMetadatas, driver) {\n    var _this = this;\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      return _this.validate(entityMetadata, entityMetadatas, driver);\n    });\n    this.validateDependencies(entityMetadatas);\n    this.validateEagerRelations(entityMetadatas);\n  };\n  /**\n   * Validates given entity metadata.\n   */\n\n\n  EntityMetadataValidator.prototype.validate = function (entityMetadata, allEntityMetadatas, driver) {\n    // check if table metadata has an id\n    if (!entityMetadata.primaryColumns.length && !entityMetadata.isJunction) throw new MissingPrimaryColumnError(entityMetadata); // validate if table is using inheritance it has a discriminator\n    // also validate if discriminator values are not empty and not repeated\n\n    if (entityMetadata.inheritancePattern === \"STI\" || entityMetadata.tableType === \"entity-child\") {\n      if (!entityMetadata.discriminatorColumn) throw new Error(\"Entity \" + entityMetadata.name + \" using single-table inheritance, it should also have a discriminator column. Did you forget to put discriminator column options?\");\n      if (typeof entityMetadata.discriminatorValue === \"undefined\") throw new Error(\"Entity \" + entityMetadata.name + \" has an undefined discriminator value. Discriminator value should be defined.\");\n      var sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find(function (metadata) {\n        return metadata !== entityMetadata && (metadata.inheritancePattern === \"STI\" || metadata.tableType === \"entity-child\") && metadata.discriminatorValue === entityMetadata.discriminatorValue && metadata.inheritanceTree.some(function (parent) {\n          return entityMetadata.inheritanceTree.indexOf(parent) !== -1;\n        });\n      });\n      if (sameDiscriminatorValueEntityMetadata) throw new Error(\"Entities \" + entityMetadata.name + \" and \" + sameDiscriminatorValueEntityMetadata.name + \" have the same discriminator values. Make sure they are different while using the @ChildEntity decorator.\");\n    }\n\n    entityMetadata.relationCounts.forEach(function (relationCount) {\n      if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne) throw new Error(\"Relation count can not be implemented on ManyToOne or OneToOne relations.\");\n    });\n\n    if (!(driver instanceof MongoDriver)) {\n      entityMetadata.columns.forEach(function (column) {\n        var normalizedColumn = driver.normalizeType(column);\n        if (driver.supportedDataTypes.indexOf(normalizedColumn) === -1) throw new DataTypeNotSupportedError(column, normalizedColumn, driver.options.type);\n        if (column.length && driver.withLengthColumnTypes.indexOf(normalizedColumn) === -1) throw new Error(\"Column \" + column.propertyName + \" of Entity \" + entityMetadata.name + \" does not support length property.\");\n        if (column.type === \"enum\" && !column.enum && !column.enumName) throw new Error(\"Column \\\"\" + column.propertyName + \"\\\" of Entity \\\"\" + entityMetadata.name + \"\\\" is defined as enum, but missing \\\"enum\\\" or \\\"enumName\\\" properties.\");\n      });\n    }\n\n    if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver) {\n      var generatedColumns = entityMetadata.columns.filter(function (column) {\n        return column.isGenerated && column.generationStrategy !== \"uuid\";\n      });\n      if (generatedColumns.length > 1) throw new Error(\"Error in \" + entityMetadata.name + \" entity. There can be only one auto-increment column in MySql table.\");\n    } // for mysql we are able to not define a default selected database, instead all entities can have their database\n    // defined in their decorators. To make everything work either all entities must have database define and we\n    // can live without database set in the connection options, either database in the connection options must be set\n\n\n    if (driver instanceof MysqlDriver) {\n      var metadatasWithDatabase = allEntityMetadatas.filter(function (metadata) {\n        return metadata.database;\n      });\n      if (metadatasWithDatabase.length === 0 && !driver.database) throw new NoConnectionOptionError(\"database\");\n    }\n\n    if (driver instanceof SqlServerDriver) {\n      var charsetColumns = entityMetadata.columns.filter(function (column) {\n        return column.charset;\n      });\n      if (charsetColumns.length > 1) throw new Error(\"Character set specifying is not supported in Sql Server\");\n    } // check if relations are all without initialized properties\n\n\n    var entityInstance = entityMetadata.create();\n    entityMetadata.relations.forEach(function (relation) {\n      if (relation.isManyToMany || relation.isOneToMany) {\n        // we skip relations for which persistence is disabled since initialization in them cannot harm somehow\n        if (relation.persistenceEnabled === false) return; // get entity relation value and check if its an array\n\n        var relationInitializedValue = relation.getEntityValue(entityInstance);\n        if (Array.isArray(relationInitializedValue)) throw new InitializedRelationError(relation);\n      }\n    }); // validate relations\n\n    entityMetadata.relations.forEach(function (relation) {// check join tables:\n      // using JoinTable is possible only on one side of the many-to-many relation\n      // todo(dima): fix\n      // if (relation.joinTable) {\n      //     if (!relation.isManyToMany)\n      //         throw new UsingJoinTableIsNotAllowedError(entityMetadata, relation);\n      //     // if there is inverse side of the relation, then check if it does not have join table too\n      //     if (relation.hasInverseSide && relation.inverseRelation.joinTable)\n      //         throw new UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation);\n      // }\n      // check join columns:\n      // using JoinColumn is possible only on one side of the relation and on one-to-one, many-to-one relation types\n      // first check if relation is one-to-one or many-to-one\n      // todo(dima): fix\n\n      /*if (relation.joinColumn) {\n           // join column can be applied only on one-to-one and many-to-one relations\n          if (!relation.isOneToOne && !relation.isManyToOne)\n              throw new UsingJoinColumnIsNotAllowedError(entityMetadata, relation);\n           // if there is inverse side of the relation, then check if it does not have join table too\n          if (relation.hasInverseSide && relation.inverseRelation.joinColumn && relation.isOneToOne)\n              throw new UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation);\n           // check if join column really has referenced column\n          if (relation.joinColumn && !relation.joinColumn.referencedColumn)\n              throw new Error(`Join column does not have referenced column set`);\n       }\n       // if its a one-to-one relation and JoinColumn is missing on both sides of the relation\n      // or its one-side relation without JoinColumn we should give an error\n      if (!relation.joinColumn && relation.isOneToOne && (!relation.hasInverseSide || !relation.inverseRelation.joinColumn))\n          throw new MissingJoinColumnError(entityMetadata, relation);*/\n      // if its a many-to-many relation and JoinTable is missing on both sides of the relation\n      // or its one-side relation without JoinTable we should give an error\n      // todo(dima): fix it\n      // if (!relation.joinTable && relation.isManyToMany && (!relation.hasInverseSide || !relation.inverseRelation.joinTable))\n      //     throw new MissingJoinTableError(entityMetadata, relation);\n      // todo: validate if its one-to-one and side which does not have join column MUST have inverse side\n      // todo: validate if its many-to-many and side which does not have join table MUST have inverse side\n      // todo: if there is a relation, and inverse side is specified only on one side, shall we give error\n      // todo: with message like: \"Inverse side is specified only on one side of the relationship. Specify on other side too to prevent confusion\".\n      // todo: add validation if there two entities with the same target, and show error message with description of the problem (maybe file was renamed/moved but left in output directory)\n      // todo: check if there are multiple columns on the same column applied.\n      // todo: check column type if is missing in relational databases (throw new Error(`Column type of ${type} cannot be determined.`);)\n      // todo: include driver-specific checks. for example in mongodb empty prefixes are not allowed\n      // todo: if multiple columns with same name - throw exception, including cases when columns are in embeds with same prefixes or without prefix at all\n      // todo: if multiple primary key used, at least one of them must be unique or @Index decorator must be set on entity\n      // todo: check if entity with duplicate names, some decorators exist\n    }); // make sure cascade remove is not set for both sides of relationships (can be set in OneToOne decorators)\n\n    entityMetadata.relations.forEach(function (relation) {\n      var isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation.isCascadeRemove;\n      if (isCircularCascadeRemove) throw new Error(\"Relation \" + entityMetadata.name + \"#\" + relation.propertyName + \" and \" + relation.inverseRelation.entityMetadata.name + \"#\" + relation.inverseRelation.propertyName + \" both has cascade remove set. \" + \"This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.\");\n    }); // todo: maybe better just deny removal from one to one relation without join column?\n\n    entityMetadata.eagerRelations.forEach(function (relation) {});\n  };\n  /**\n   * Validates dependencies of the entity metadatas.\n   */\n\n\n  EntityMetadataValidator.prototype.validateDependencies = function (entityMetadatas) {\n    var graph = new DepGraph();\n    entityMetadatas.forEach(function (entityMetadata) {\n      graph.addNode(entityMetadata.name);\n    });\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.relationsWithJoinColumns.filter(function (relation) {\n        return !relation.isNullable;\n      }).forEach(function (relation) {\n        graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);\n      });\n    });\n\n    try {\n      graph.overallOrder();\n    } catch (err) {\n      throw new CircularRelationsError(err.toString().replace(\"Error: Dependency Cycle Found: \", \"\"));\n    }\n  };\n  /**\n   * Validates eager relations to prevent circular dependency in them.\n   */\n\n\n  EntityMetadataValidator.prototype.validateEagerRelations = function (entityMetadatas) {\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.eagerRelations.forEach(function (relation) {\n        if (relation.inverseRelation && relation.inverseRelation.isEager) throw new Error(\"Circular eager relations are disallowed. \" + (entityMetadata.targetName + \"#\" + relation.propertyPath + \" contains \\\"eager: true\\\", and its inverse side \") + (relation.inverseEntityMetadata.targetName + \"#\" + relation.inverseRelation.propertyPath + \" contains \\\"eager: true\\\" as well.\") + \" Remove \\\"eager: true\\\" from one side of the relation.\");\n      });\n    });\n  };\n\n  return EntityMetadataValidator;\n}();\n\nexport { EntityMetadataValidator };","map":{"version":3,"sources":["../browser/src/metadata-builder/EntityMetadataValidator.ts"],"names":[],"mappings":"AACA,SAAQ,yBAAR,QAAwC,oCAAxC;AACA,SAAQ,sBAAR,QAAqC,iCAArC;AACA,SAAQ,QAAR,QAAuB,kBAAvB;AAEA,SAAQ,yBAAR,QAAwC,oCAAxC;AAEA,SAAQ,WAAR,QAA0B,+BAA1B;AACA,SAAQ,eAAR,QAA8B,qCAA9B;AACA,SAAQ,WAAR,QAA0B,6BAA1B;AACA,SAAQ,uBAAR,QAAsC,kCAAtC;AACA,SAAQ,wBAAR,QAAuC,mCAAvC;AACA,SAAQ,mBAAR,QAAkC,+CAAlC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEG;;AACH,IAAA,uBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,uBAAA,GAAA,CAmNC,CAnND,CAEI;AACA;AACA;;AAEA;;AAEG;;;AACH,EAAA,uBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,eAAb,EAAgD,MAAhD,EAA8D;AAA9D,QAAA,KAAA,GAAA,IAAA;;AACI,IAAA,eAAe,CAAC,OAAhB,CAAwB,UAAA,cAAA,EAAc;AAAI,aAAA,KAAI,CAAC,QAAL,CAAc,cAAd,EAA8B,eAA9B,EAAA,MAAA,CAAA;AAAsD,KAAhG;AACA,SAAK,oBAAL,CAA0B,eAA1B;AACA,SAAK,sBAAL,CAA4B,eAA5B;AACH,GAJD;AAMA;;AAEG;;;AACH,EAAA,uBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,cAAT,EAAyC,kBAAzC,EAA+E,MAA/E,EAA6F;AAEzF;AACA,QAAI,CAAC,cAAc,CAAC,cAAf,CAA8B,MAA/B,IAAyC,CAAC,cAAc,CAAC,UAA7D,EACI,MAAM,IAAI,yBAAJ,CAA8B,cAA9B,CAAN,CAJqF,CAMzF;AACA;;AACA,QAAI,cAAc,CAAC,kBAAf,KAAsC,KAAtC,IAA+C,cAAc,CAAC,SAAf,KAA6B,cAAhF,EAAgG;AAC5F,UAAI,CAAC,cAAc,CAAC,mBAApB,EACI,MAAM,IAAI,KAAJ,CAAU,YAAU,cAAc,CAAC,IAAzB,GAA6B,kIAAvC,CAAN;AAEJ,UAAI,OAAO,cAAc,CAAC,kBAAtB,KAA6C,WAAjD,EACI,MAAM,IAAI,KAAJ,CAAU,YAAU,cAAc,CAAC,IAAzB,GAA6B,+EAAvC,CAAN;AAEJ,UAAM,oCAAoC,GAAG,kBAAkB,CAAC,IAAnB,CAAwB,UAAA,QAAA,EAAQ;AACzE,eAAO,QAAQ,KAAK,cAAb,KACC,QAAQ,CAAC,kBAAT,KAAgC,KAAhC,IAAyC,QAAQ,CAAC,SAAT,KAAuB,cADjE,KAEA,QAAQ,CAAC,kBAAT,KAAgC,cAAc,CAAC,kBAF/C,IAGA,QAAQ,CAAC,eAAT,CAAyB,IAAzB,CAA8B,UAAA,MAAA,EAAM;AAAI,iBAAA,cAAc,CAAC,eAAf,CAA+B,OAA/B,CAAuC,MAAvC,MAAmD,CAAnD,CAAA;AAAqD,SAA7F,CAHP;AAIH,OAL4C,CAA7C;AAMA,UAAI,oCAAJ,EACI,MAAM,IAAI,KAAJ,CAAU,cAAY,cAAc,CAAC,IAA3B,GAA+B,OAA/B,GAAuC,oCAAoC,CAAC,IAA5E,GAAgF,2GAA1F,CAAN;AACP;;AAED,IAAA,cAAc,CAAC,cAAf,CAA8B,OAA9B,CAAsC,UAAA,aAAA,EAAa;AAC/C,UAAI,aAAa,CAAC,QAAd,CAAuB,WAAvB,IAAsC,aAAa,CAAC,QAAd,CAAuB,UAAjE,EACI,MAAM,IAAI,KAAJ,CAAU,2EAAV,CAAN;AACP,KAHD;;AAKA,QAAI,EAAE,MAAM,YAAY,WAApB,CAAJ,EAAsC;AAClC,MAAA,cAAc,CAAC,OAAf,CAAuB,OAAvB,CAA+B,UAAA,MAAA,EAAM;AACjC,YAAM,gBAAgB,GAAG,MAAM,CAAC,aAAP,CAAqB,MAArB,CAAzB;AACA,YAAI,MAAM,CAAC,kBAAP,CAA0B,OAA1B,CAAkC,gBAAlC,MAAwD,CAAC,CAA7D,EACI,MAAM,IAAI,yBAAJ,CAA8B,MAA9B,EAAsC,gBAAtC,EAAwD,MAAM,CAAC,OAAP,CAAe,IAAvE,CAAN;AACJ,YAAI,MAAM,CAAC,MAAP,IAAiB,MAAM,CAAC,qBAAP,CAA6B,OAA7B,CAAqC,gBAArC,MAA2D,CAAC,CAAjF,EACI,MAAM,IAAI,KAAJ,CAAU,YAAU,MAAM,CAAC,YAAjB,GAA6B,aAA7B,GAA2C,cAAc,CAAC,IAA1D,GAA8D,oCAAxE,CAAN;AACJ,YAAI,MAAM,CAAC,IAAP,KAAgB,MAAhB,IAA0B,CAAC,MAAM,CAAC,IAAlC,IAA0C,CAAC,MAAM,CAAC,QAAtD,EACI,MAAM,IAAI,KAAJ,CAAU,cAAW,MAAM,CAAC,YAAlB,GAA8B,iBAA9B,GAA8C,cAAc,CAAC,IAA7D,GAAiE,yEAA3E,CAAN;AACP,OARD;AASH;;AAED,QAAI,MAAM,YAAY,WAAlB,IAAiC,MAAM,YAAY,mBAAvD,EAA4E;AACxE,UAAM,gBAAgB,GAAG,cAAc,CAAC,OAAf,CAAuB,MAAvB,CAA8B,UAAA,MAAA,EAAM;AAAI,eAAA,MAAM,CAAC,WAAP,IAAsB,MAAM,CAAC,kBAAP,KAAtB,MAAA;AAA0D,OAAlG,CAAzB;AACA,UAAI,gBAAgB,CAAC,MAAjB,GAA0B,CAA9B,EACI,MAAM,IAAI,KAAJ,CAAU,cAAY,cAAc,CAAC,IAA3B,GAA+B,sEAAzC,CAAN;AACP,KA9CwF,CAgDzF;AACA;AACA;;;AACA,QAAI,MAAM,YAAY,WAAtB,EAAmC;AAC/B,UAAM,qBAAqB,GAAG,kBAAkB,CAAC,MAAnB,CAA0B,UAAA,QAAA,EAAQ;AAAI,eAAA,QAAQ,CAAR,QAAA;AAAiB,OAAvD,CAA9B;AACA,UAAI,qBAAqB,CAAC,MAAtB,KAAiC,CAAjC,IAAsC,CAAC,MAAM,CAAC,QAAlD,EACI,MAAM,IAAI,uBAAJ,CAA4B,UAA5B,CAAN;AACP;;AAED,QAAI,MAAM,YAAY,eAAtB,EAAuC;AACnC,UAAM,cAAc,GAAG,cAAc,CAAC,OAAf,CAAuB,MAAvB,CAA8B,UAAA,MAAA,EAAM;AAAI,eAAA,MAAM,CAAN,OAAA;AAAc,OAAtD,CAAvB;AACA,UAAI,cAAc,CAAC,MAAf,GAAwB,CAA5B,EACI,MAAM,IAAI,KAAJ,CAAU,yDAAV,CAAN;AACP,KA7DwF,CA+DzF;;;AACA,QAAM,cAAc,GAAG,cAAc,CAAC,MAAf,EAAvB;AACA,IAAA,cAAc,CAAC,SAAf,CAAyB,OAAzB,CAAiC,UAAA,QAAA,EAAQ;AACrC,UAAI,QAAQ,CAAC,YAAT,IAAyB,QAAQ,CAAC,WAAtC,EAAmD;AAE/C;AACA,YAAI,QAAQ,CAAC,kBAAT,KAAgC,KAApC,EACI,OAJ2C,CAM/C;;AACA,YAAM,wBAAwB,GAAG,QAAQ,CAAC,cAAT,CAAwB,cAAxB,CAAjC;AACA,YAAI,KAAK,CAAC,OAAN,CAAc,wBAAd,CAAJ,EACI,MAAM,IAAI,wBAAJ,CAA6B,QAA7B,CAAN;AACP;AACJ,KAZD,EAjEyF,CA+EzF;;AACA,IAAA,cAAc,CAAC,SAAf,CAAyB,OAAzB,CAAiC,UAAA,QAAA,EAAQ,CAErC;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;;;;;;;;;;;;;;;AAqBA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGH,KA3DD,EAhFyF,CA6IzF;;AACA,IAAA,cAAc,CAAC,SAAf,CAAyB,OAAzB,CAAiC,UAAA,QAAA,EAAQ;AACrC,UAAM,uBAAuB,GAAG,QAAQ,CAAC,eAAT,IAA4B,QAAQ,CAAC,eAArC,IAAwD,QAAQ,CAAC,eAAT,CAA0B,eAAlH;AACA,UAAI,uBAAJ,EACI,MAAM,IAAI,KAAJ,CAAU,cAAY,cAAc,CAAC,IAA3B,GAA+B,GAA/B,GAAmC,QAAQ,CAAC,YAA5C,GAAwD,OAAxD,GAAgE,QAAQ,CAAC,eAAT,CAA0B,cAA1B,CAAyC,IAAzG,GAA6G,GAA7G,GAAiH,QAAQ,CAAC,eAAT,CAA0B,YAA3I,GAAuJ,gCAAvJ,GACZ,8GADE,CAAN;AAEP,KALD,EA9IyF,CAmJrF;;AAEJ,IAAA,cAAc,CAAC,cAAf,CAA8B,OAA9B,CAAsC,UAAA,QAAA,EAAQ,CAE7C,CAFD;AAGH,GAxJD;AA0JA;;AAEG;;;AACO,EAAA,uBAAA,CAAA,SAAA,CAAA,oBAAA,GAAV,UAA+B,eAA/B,EAAgE;AAE5D,QAAM,KAAK,GAAG,IAAI,QAAJ,EAAd;AACA,IAAA,eAAe,CAAC,OAAhB,CAAwB,UAAA,cAAA,EAAc;AAClC,MAAA,KAAK,CAAC,OAAN,CAAc,cAAc,CAAC,IAA7B;AACH,KAFD;AAGA,IAAA,eAAe,CAAC,OAAhB,CAAwB,UAAA,cAAA,EAAc;AAClC,MAAA,cAAc,CAAC,wBAAf,CACK,MADL,CACY,UAAA,QAAA,EAAQ;AAAI,eAAA,CAAC,QAAQ,CAAT,UAAA;AAAoB,OAD5C,EAEK,OAFL,CAEa,UAAA,QAAA,EAAQ;AACb,QAAA,KAAK,CAAC,aAAN,CAAoB,cAAc,CAAC,IAAnC,EAAyC,QAAQ,CAAC,qBAAT,CAA+B,IAAxE;AACH,OAJL;AAKH,KAND;;AAOA,QAAI;AACA,MAAA,KAAK,CAAC,YAAN;AAEH,KAHD,CAGE,OAAO,GAAP,EAAY;AACV,YAAM,IAAI,sBAAJ,CAA2B,GAAG,CAAC,QAAJ,GAAe,OAAf,CAAuB,iCAAvB,EAA0D,EAA1D,CAA3B,CAAN;AACH;AACJ,GAnBS;AAqBV;;AAEG;;;AACO,EAAA,uBAAA,CAAA,SAAA,CAAA,sBAAA,GAAV,UAAiC,eAAjC,EAAkE;AAC9D,IAAA,eAAe,CAAC,OAAhB,CAAwB,UAAA,cAAA,EAAc;AAClC,MAAA,cAAc,CAAC,cAAf,CAA8B,OAA9B,CAAsC,UAAA,QAAA,EAAQ;AAC1C,YAAI,QAAQ,CAAC,eAAT,IAA4B,QAAQ,CAAC,eAAT,CAAyB,OAAzD,EACI,MAAM,IAAI,KAAJ,CAAU,+CACT,cAAc,CAAC,UAAf,GAAyB,GAAzB,GAA6B,QAAQ,CAAC,YAAtC,GAAkD,kDADzC,KAET,QAAQ,CAAC,qBAAT,CAA+B,UAA/B,GAAyC,GAAzC,GAA6C,QAAQ,CAAC,eAAT,CAAyB,YAAtE,GAAkF,oCAFzE,IAGZ,wDAHE,CAAN;AAIP,OAND;AAOH,KARD;AASH,GAVS;;AAYd,SAAA,uBAAA;AAAC,CAnND,EAAA","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {MissingPrimaryColumnError} from \"../error/MissingPrimaryColumnError\";\nimport {CircularRelationsError} from \"../error/CircularRelationsError\";\nimport {DepGraph} from \"../util/DepGraph\";\nimport {Driver} from \"../driver/Driver\";\nimport {DataTypeNotSupportedError} from \"../error/DataTypeNotSupportedError\";\nimport {ColumnType} from \"../driver/types/ColumnTypes\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {NoConnectionOptionError} from \"../error/NoConnectionOptionError\";\nimport {InitializedRelationError} from \"../error/InitializedRelationError\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n\n/// todo: add check if there are multiple tables with the same name\n/// todo: add checks when generated column / table names are too long for the specific driver\n// todo: type in function validation, inverse side function validation\n// todo: check on build for duplicate names, since naming checking was removed from MetadataStorage\n// todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?\n// todo: check if multiple tree parent metadatas in validator\n// todo: tree decorators can be used only on closure table (validation)\n// todo: throw error if parent tree metadata was not specified in a closure table\n\n// todo: MetadataArgsStorage: type in function validation, inverse side function validation\n// todo: MetadataArgsStorage: check on build for duplicate names, since naming checking was removed from MetadataStorage\n// todo: MetadataArgsStorage: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?\n// todo: MetadataArgsStorage: check for duplicate targets too since this check has been removed too\n// todo: check if relation decorator contains primary: true and nullable: true\n// todo: check column length, precision. scale\n// todo: MySQL index can be unique or spatial or fulltext\n\n/**\n * Validates built entity metadatas.\n */\nexport class EntityMetadataValidator {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given entity metadatas.\n     */\n    validateMany(entityMetadatas: EntityMetadata[], driver: Driver) {\n        entityMetadatas.forEach(entityMetadata => this.validate(entityMetadata, entityMetadatas, driver));\n        this.validateDependencies(entityMetadatas);\n        this.validateEagerRelations(entityMetadatas);\n    }\n\n    /**\n     * Validates given entity metadata.\n     */\n    validate(entityMetadata: EntityMetadata, allEntityMetadatas: EntityMetadata[], driver: Driver) {\n\n        // check if table metadata has an id\n        if (!entityMetadata.primaryColumns.length && !entityMetadata.isJunction)\n            throw new MissingPrimaryColumnError(entityMetadata);\n\n        // validate if table is using inheritance it has a discriminator\n        // also validate if discriminator values are not empty and not repeated\n        if (entityMetadata.inheritancePattern === \"STI\" || entityMetadata.tableType === \"entity-child\") {\n            if (!entityMetadata.discriminatorColumn)\n                throw new Error(`Entity ${entityMetadata.name} using single-table inheritance, it should also have a discriminator column. Did you forget to put discriminator column options?`);\n\n            if (typeof entityMetadata.discriminatorValue === \"undefined\")\n                throw new Error(`Entity ${entityMetadata.name} has an undefined discriminator value. Discriminator value should be defined.`);\n\n            const sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find(metadata => {\n                return metadata !== entityMetadata\n                    && (metadata.inheritancePattern === \"STI\" || metadata.tableType === \"entity-child\")\n                    && metadata.discriminatorValue === entityMetadata.discriminatorValue\n                    && metadata.inheritanceTree.some(parent => entityMetadata.inheritanceTree.indexOf(parent) !== -1);\n            });\n            if (sameDiscriminatorValueEntityMetadata)\n                throw new Error(`Entities ${entityMetadata.name} and ${sameDiscriminatorValueEntityMetadata.name} have the same discriminator values. Make sure they are different while using the @ChildEntity decorator.`);\n        }\n\n        entityMetadata.relationCounts.forEach(relationCount => {\n            if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne)\n                throw new Error(`Relation count can not be implemented on ManyToOne or OneToOne relations.`);\n        });\n\n        if (!(driver instanceof MongoDriver)) {\n            entityMetadata.columns.forEach(column => {\n                const normalizedColumn = driver.normalizeType(column) as ColumnType;\n                if (driver.supportedDataTypes.indexOf(normalizedColumn) === -1)\n                    throw new DataTypeNotSupportedError(column, normalizedColumn, driver.options.type);\n                if (column.length && driver.withLengthColumnTypes.indexOf(normalizedColumn) === -1)\n                    throw new Error(`Column ${column.propertyName} of Entity ${entityMetadata.name} does not support length property.`);\n                if (column.type === \"enum\" && !column.enum && !column.enumName)\n                    throw new Error(`Column \"${column.propertyName}\" of Entity \"${entityMetadata.name}\" is defined as enum, but missing \"enum\" or \"enumName\" properties.`);\n            });\n        }\n\n        if (driver instanceof MysqlDriver || driver instanceof AuroraDataApiDriver) {\n            const generatedColumns = entityMetadata.columns.filter(column => column.isGenerated && column.generationStrategy !== \"uuid\");\n            if (generatedColumns.length > 1)\n                throw new Error(`Error in ${entityMetadata.name} entity. There can be only one auto-increment column in MySql table.`);\n        }\n\n        // for mysql we are able to not define a default selected database, instead all entities can have their database\n        // defined in their decorators. To make everything work either all entities must have database define and we\n        // can live without database set in the connection options, either database in the connection options must be set\n        if (driver instanceof MysqlDriver) {\n            const metadatasWithDatabase = allEntityMetadatas.filter(metadata => metadata.database);\n            if (metadatasWithDatabase.length === 0 && !driver.database)\n                throw new NoConnectionOptionError(\"database\");\n        }\n\n        if (driver instanceof SqlServerDriver) {\n            const charsetColumns = entityMetadata.columns.filter(column => column.charset);\n            if (charsetColumns.length > 1)\n                throw new Error(`Character set specifying is not supported in Sql Server`);\n        }\n\n        // check if relations are all without initialized properties\n        const entityInstance = entityMetadata.create();\n        entityMetadata.relations.forEach(relation => {\n            if (relation.isManyToMany || relation.isOneToMany) {\n\n                // we skip relations for which persistence is disabled since initialization in them cannot harm somehow\n                if (relation.persistenceEnabled === false)\n                    return;\n\n                // get entity relation value and check if its an array\n                const relationInitializedValue = relation.getEntityValue(entityInstance);\n                if (Array.isArray(relationInitializedValue))\n                    throw new InitializedRelationError(relation);\n            }\n        });\n\n        // validate relations\n        entityMetadata.relations.forEach(relation => {\n\n            // check join tables:\n            // using JoinTable is possible only on one side of the many-to-many relation\n            // todo(dima): fix\n            // if (relation.joinTable) {\n            //     if (!relation.isManyToMany)\n            //         throw new UsingJoinTableIsNotAllowedError(entityMetadata, relation);\n\n            //     // if there is inverse side of the relation, then check if it does not have join table too\n            //     if (relation.hasInverseSide && relation.inverseRelation.joinTable)\n            //         throw new UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation);\n            // }\n\n            // check join columns:\n            // using JoinColumn is possible only on one side of the relation and on one-to-one, many-to-one relation types\n            // first check if relation is one-to-one or many-to-one\n            // todo(dima): fix\n            /*if (relation.joinColumn) {\n\n                // join column can be applied only on one-to-one and many-to-one relations\n                if (!relation.isOneToOne && !relation.isManyToOne)\n                    throw new UsingJoinColumnIsNotAllowedError(entityMetadata, relation);\n\n                // if there is inverse side of the relation, then check if it does not have join table too\n                if (relation.hasInverseSide && relation.inverseRelation.joinColumn && relation.isOneToOne)\n                    throw new UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation);\n\n                // check if join column really has referenced column\n                if (relation.joinColumn && !relation.joinColumn.referencedColumn)\n                    throw new Error(`Join column does not have referenced column set`);\n\n            }\n\n            // if its a one-to-one relation and JoinColumn is missing on both sides of the relation\n            // or its one-side relation without JoinColumn we should give an error\n            if (!relation.joinColumn && relation.isOneToOne && (!relation.hasInverseSide || !relation.inverseRelation.joinColumn))\n                throw new MissingJoinColumnError(entityMetadata, relation);*/\n\n            // if its a many-to-many relation and JoinTable is missing on both sides of the relation\n            // or its one-side relation without JoinTable we should give an error\n            // todo(dima): fix it\n            // if (!relation.joinTable && relation.isManyToMany && (!relation.hasInverseSide || !relation.inverseRelation.joinTable))\n            //     throw new MissingJoinTableError(entityMetadata, relation);\n\n\n            // todo: validate if its one-to-one and side which does not have join column MUST have inverse side\n            // todo: validate if its many-to-many and side which does not have join table MUST have inverse side\n            // todo: if there is a relation, and inverse side is specified only on one side, shall we give error\n            // todo: with message like: \"Inverse side is specified only on one side of the relationship. Specify on other side too to prevent confusion\".\n            // todo: add validation if there two entities with the same target, and show error message with description of the problem (maybe file was renamed/moved but left in output directory)\n            // todo: check if there are multiple columns on the same column applied.\n            // todo: check column type if is missing in relational databases (throw new Error(`Column type of ${type} cannot be determined.`);)\n            // todo: include driver-specific checks. for example in mongodb empty prefixes are not allowed\n            // todo: if multiple columns with same name - throw exception, including cases when columns are in embeds with same prefixes or without prefix at all\n            // todo: if multiple primary key used, at least one of them must be unique or @Index decorator must be set on entity\n            // todo: check if entity with duplicate names, some decorators exist\n\n\n        });\n\n        // make sure cascade remove is not set for both sides of relationships (can be set in OneToOne decorators)\n        entityMetadata.relations.forEach(relation => {\n            const isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation!.isCascadeRemove;\n            if (isCircularCascadeRemove)\n                throw new Error(`Relation ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseRelation!.entityMetadata.name}#${relation.inverseRelation!.propertyName} both has cascade remove set. ` +\n                    `This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.`);\n        }); // todo: maybe better just deny removal from one to one relation without join column?\n\n        entityMetadata.eagerRelations.forEach(relation => {\n\n        });\n    }\n\n    /**\n     * Validates dependencies of the entity metadatas.\n     */\n    protected validateDependencies(entityMetadatas: EntityMetadata[]) {\n\n        const graph = new DepGraph();\n        entityMetadatas.forEach(entityMetadata => {\n            graph.addNode(entityMetadata.name);\n        });\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.relationsWithJoinColumns\n                .filter(relation => !relation.isNullable)\n                .forEach(relation => {\n                    graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);\n                });\n        });\n        try {\n            graph.overallOrder();\n\n        } catch (err) {\n            throw new CircularRelationsError(err.toString().replace(\"Error: Dependency Cycle Found: \", \"\"));\n        }\n    }\n\n    /**\n     * Validates eager relations to prevent circular dependency in them.\n     */\n    protected validateEagerRelations(entityMetadatas: EntityMetadata[]) {\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.eagerRelations.forEach(relation => {\n                if (relation.inverseRelation && relation.inverseRelation.isEager)\n                    throw new Error(`Circular eager relations are disallowed. ` +\n                        `${entityMetadata.targetName}#${relation.propertyPath} contains \"eager: true\", and its inverse side ` +\n                        `${relation.inverseEntityMetadata.targetName}#${relation.inverseRelation.propertyPath} contains \"eager: true\" as well.` +\n                        ` Remove \"eager: true\" from one side of the relation.`);\n            });\n        });\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}