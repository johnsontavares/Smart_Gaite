{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { SapDriver } from \"../driver/sap/SapDriver\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { shorten } from \"../util/StringUtils\";\n/**\n * Contains all entity metadata.\n */\n\nvar EntityMetadata =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function EntityMetadata(options) {\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    this.childEntityMetadatas = [];\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n\n    this.inheritanceTree = [];\n    /**\n     * Table type. Tables can be abstract, closure, junction, embedded, etc.\n     */\n\n    this.tableType = \"regular\";\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n\n    this.withoutRowid = false;\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n\n    this.synchronize = true;\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n\n    this.hasNonNullableRelations = false;\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n\n    this.isJunction = false;\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n\n    this.isClosureJunction = false;\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n\n    this.hasMultiplePrimaryKeys = false;\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n\n    this.hasUUIDGeneratedColumns = false;\n    /**\n     * Entity's column metadatas defined by user.\n     */\n\n    this.ownColumns = [];\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n\n    this.columns = [];\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n\n    this.ancestorColumns = [];\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n\n    this.descendantColumns = [];\n    /**\n     * All columns except for virtual columns.\n     */\n\n    this.nonVirtualColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n\n    this.ownerColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n\n    this.inverseColumns = [];\n    /**\n     * Gets the column with generated flag.\n     */\n\n    this.generatedColumns = [];\n    /**\n     * Gets the primary columns.\n     */\n\n    this.primaryColumns = [];\n    /**\n     * Entity's relation metadatas.\n     */\n\n    this.ownRelations = [];\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n\n    this.relations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n\n    this.eagerRelations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n\n    this.lazyRelations = [];\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n\n    this.oneToOneRelations = [];\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n\n    this.ownerOneToOneRelations = [];\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n\n    this.oneToManyRelations = [];\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n\n    this.manyToOneRelations = [];\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n\n    this.manyToManyRelations = [];\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n\n    this.ownerManyToManyRelations = [];\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n\n    this.relationsWithJoinColumns = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n\n    this.relationIds = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n\n    this.relationCounts = [];\n    /**\n     * Entity's foreign key metadatas.\n     */\n\n    this.foreignKeys = [];\n    /**\n     * Entity's embedded metadatas.\n     */\n\n    this.embeddeds = [];\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n\n    this.allEmbeddeds = [];\n    /**\n     * Entity's own indices.\n     */\n\n    this.ownIndices = [];\n    /**\n     * Entity's index metadatas.\n     */\n\n    this.indices = [];\n    /**\n     * Entity's unique metadatas.\n     */\n\n    this.uniques = [];\n    /**\n     * Entity's own uniques.\n     */\n\n    this.ownUniques = [];\n    /**\n     * Entity's check metadatas.\n     */\n\n    this.checks = [];\n    /**\n     * Entity's exclusion metadatas.\n     */\n\n    this.exclusions = [];\n    /**\n     * Entity's own listener metadatas.\n     */\n\n    this.ownListeners = [];\n    /**\n     * Entity listener metadatas.\n     */\n\n    this.listeners = [];\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n\n    this.afterLoadListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n\n    this.beforeInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n\n    this.afterInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n\n    this.beforeUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n\n    this.afterUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n\n    this.beforeRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n\n    this.afterRemoveListeners = [];\n    this.connection = options.connection;\n    this.inheritanceTree = options.inheritanceTree || [];\n    this.inheritancePattern = options.inheritancePattern;\n    this.treeType = options.tableTree ? options.tableTree.type : undefined;\n    this.treeOptions = options.tableTree ? options.tableTree.options : undefined;\n    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;\n    this.tableMetadataArgs = options.args;\n    this.target = this.tableMetadataArgs.target;\n    this.tableType = this.tableMetadataArgs.type;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a new entity.\n   */\n\n\n  EntityMetadata.prototype.create = function (queryRunner) {\n    var _this = this; // if target is set to a function (e.g. class) that can be created then create it\n\n\n    var ret;\n\n    if (this.target instanceof Function) {\n      ret = new this.target();\n      this.lazyRelations.forEach(function (relation) {\n        return _this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner);\n      });\n      return ret;\n    } // otherwise simply return a new empty object\n\n\n    var newObject = {};\n    this.lazyRelations.forEach(function (relation) {\n      return _this.connection.relationLoader.enableLazyLoad(relation, newObject, queryRunner);\n    });\n    return newObject;\n  };\n  /**\n   * Checks if given entity has an id.\n   */\n\n\n  EntityMetadata.prototype.hasId = function (entity) {\n    if (!entity) return false;\n    return this.primaryColumns.every(function (primaryColumn) {\n      var value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined && value !== \"\";\n    });\n  };\n  /**\n   * Checks if given entity / object contains ALL primary keys entity must have.\n   * Returns true if it contains all of them, false if at least one of them is not defined.\n   */\n\n\n  EntityMetadata.prototype.hasAllPrimaryKeys = function (entity) {\n    return this.primaryColumns.every(function (primaryColumn) {\n      var value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined;\n    });\n  };\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n\n\n  EntityMetadata.prototype.ensureEntityIdMap = function (id) {\n    if (id instanceof Object) return id;\n    if (this.hasMultiplePrimaryKeys) throw new CannotCreateEntityIdMapError(this, id);\n    return this.primaryColumns[0].createValueMap(id);\n  };\n  /**\n   * Gets primary keys of the entity and returns them in a literal object.\n   * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n   * For multiple primary keys it returns multiple keys in object.\n   * For primary keys inside embeds it returns complex object literal with keys in them.\n   */\n\n\n  EntityMetadata.prototype.getEntityIdMap = function (entity) {\n    if (!entity) return undefined;\n    return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n      skipNulls: true\n    });\n  };\n  /**\n   * Creates a \"mixed id map\".\n   * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n   * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n   * This is called mixed id map.\n   */\n\n\n  EntityMetadata.prototype.getEntityIdMixedMap = function (entity) {\n    if (!entity) return entity;\n    var idMap = this.getEntityIdMap(entity);\n\n    if (this.hasMultiplePrimaryKeys) {\n      return idMap;\n    } else if (idMap) {\n      return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\n    }\n\n    return idMap;\n  };\n  /**\n   * Compares two different entities by their ids.\n   * Returns true if they match, false otherwise.\n   */\n\n\n  EntityMetadata.prototype.compareEntities = function (firstEntity, secondEntity) {\n    var firstEntityIdMap = this.getEntityIdMap(firstEntity);\n    if (!firstEntityIdMap) return false;\n    var secondEntityIdMap = this.getEntityIdMap(secondEntity);\n    if (!secondEntityIdMap) return false;\n    return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);\n  };\n  /**\n   * Finds column with a given property name.\n   */\n\n\n  EntityMetadata.prototype.findColumnWithPropertyName = function (propertyName) {\n    return this.columns.find(function (column) {\n      return column.propertyName === propertyName;\n    });\n  };\n  /**\n   * Finds column with a given database name.\n   */\n\n\n  EntityMetadata.prototype.findColumnWithDatabaseName = function (databaseName) {\n    return this.columns.find(function (column) {\n      return column.databaseName === databaseName;\n    });\n  };\n  /**\n   * Finds column with a given property path.\n   */\n\n\n  EntityMetadata.prototype.findColumnWithPropertyPath = function (propertyPath) {\n    var column = this.columns.find(function (column) {\n      return column.propertyPath === propertyPath;\n    });\n    if (column) return column; // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n\n    var relation = this.relations.find(function (relation) {\n      return relation.propertyPath === propertyPath;\n    });\n    if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];\n    return undefined;\n  };\n  /**\n   * Finds columns with a given property path.\n   * Property path can match a relation, and relations can contain multiple columns.\n   */\n\n\n  EntityMetadata.prototype.findColumnsWithPropertyPath = function (propertyPath) {\n    var column = this.columns.find(function (column) {\n      return column.propertyPath === propertyPath;\n    });\n    if (column) return [column]; // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n\n    var relation = this.relations.find(function (relation) {\n      return relation.propertyPath === propertyPath;\n    });\n    if (relation && relation.joinColumns) return relation.joinColumns;\n    return [];\n  };\n  /**\n   * Finds relation with the given property path.\n   */\n\n\n  EntityMetadata.prototype.findRelationWithPropertyPath = function (propertyPath) {\n    return this.relations.find(function (relation) {\n      return relation.propertyPath === propertyPath;\n    });\n  };\n  /**\n   * Checks if there is an embedded with a given property path.\n   */\n\n\n  EntityMetadata.prototype.hasEmbeddedWithPropertyPath = function (propertyPath) {\n    return this.allEmbeddeds.some(function (embedded) {\n      return embedded.propertyPath === propertyPath;\n    });\n  };\n  /**\n   * Finds embedded with a given property path.\n   */\n\n\n  EntityMetadata.prototype.findEmbeddedWithPropertyPath = function (propertyPath) {\n    return this.allEmbeddeds.find(function (embedded) {\n      return embedded.propertyPath === propertyPath;\n    });\n  };\n  /**\n   * Iterates through entity and finds and extracts all values from relations in the entity.\n   * If relation value is an array its being flattened.\n   */\n\n\n  EntityMetadata.prototype.extractRelationValuesFromEntity = function (entity, relations) {\n    var _this = this;\n\n    var relationsAndValues = [];\n    relations.forEach(function (relation) {\n      var value = relation.getEntityValue(entity);\n\n      if (Array.isArray(value)) {\n        value.forEach(function (subValue) {\n          return relationsAndValues.push([relation, subValue, _this.getInverseEntityMetadata(subValue, relation)]);\n        });\n      } else if (value) {\n        relationsAndValues.push([relation, value, _this.getInverseEntityMetadata(value, relation)]);\n      }\n    });\n    return relationsAndValues;\n  };\n\n  EntityMetadata.prototype.getInverseEntityMetadata = function (value, relation) {\n    var childEntityMetadata = relation.inverseEntityMetadata.childEntityMetadatas.find(function (metadata) {\n      return metadata.target === value.constructor;\n    });\n    return childEntityMetadata ? childEntityMetadata : relation.inverseEntityMetadata;\n  }; // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a property paths for a given entity.\n   */\n\n\n  EntityMetadata.createPropertyPath = function (metadata, entity, prefix) {\n    var _this = this;\n\n    if (prefix === void 0) {\n      prefix = \"\";\n    }\n\n    var paths = [];\n    Object.keys(entity).forEach(function (key) {\n      // check for function is needed in the cases when createPropertyPath used on values containg a function as a value\n      // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n      var parentPath = prefix ? prefix + \".\" + key : key;\n\n      if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n        var subPaths = _this.createPropertyPath(metadata, entity[key], parentPath);\n\n        paths.push.apply(paths, __spreadArray([], __read(subPaths)));\n      } else {\n        var path = prefix ? prefix + \".\" + key : key;\n        paths.push(path);\n      }\n    });\n    return paths;\n  };\n  /**\n   * Finds difference between two entity id maps.\n   * Returns items that exist in the first array and absent in the second array.\n   */\n\n\n  EntityMetadata.difference = function (firstIdMaps, secondIdMaps) {\n    return firstIdMaps.filter(function (firstIdMap) {\n      return !secondIdMaps.find(function (secondIdMap) {\n        return OrmUtils.compareIds(firstIdMap, secondIdMap);\n      });\n    });\n  };\n  /**\n   * Creates value map from the given values and columns.\n   * Examples of usages are primary columns map and join columns map.\n   */\n\n\n  EntityMetadata.getValueMap = function (entity, columns, options) {\n    return columns.reduce(function (map, column) {\n      var value = column.getEntityValueMap(entity, options); // make sure that none of the values of the columns are not missing\n\n      if (map === undefined || value === null || value === undefined) return undefined;\n      return column.isObjectId ? Object.assign(map, value) : OrmUtils.mergeDeep(map, value);\n    }, {});\n  }; // ---------------------------------------------------------------------\n  // Public Builder Methods\n  // ---------------------------------------------------------------------\n\n\n  EntityMetadata.prototype.build = function () {\n    var namingStrategy = this.connection.namingStrategy;\n    var entityPrefix = this.connection.options.entityPrefix;\n    this.engine = this.tableMetadataArgs.engine;\n    this.database = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;\n\n    if (this.tableMetadataArgs.schema) {\n      this.schema = this.tableMetadataArgs.schema;\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.schema = this.parentEntityMetadata.schema;\n    } else {\n      this.schema = this.connection.options.schema;\n    }\n\n    this.givenTableName = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;\n    this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;\n    this.targetName = this.tableMetadataArgs.target instanceof Function ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;\n\n    if (this.tableMetadataArgs.type === \"closure-junction\") {\n      this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\n    } else {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\n\n      if (this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {\n        this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, {\n          separator: \"_\",\n          segmentLength: 3\n        });\n      }\n    }\n\n    this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\n    this.target = this.target ? this.target : this.tableName;\n    this.name = this.targetName ? this.targetName : this.tableName;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;\n    this.tablePath = this.buildTablePath();\n    this.schemaPath = this.buildSchemaPath();\n    this.orderBy = this.tableMetadataArgs.orderBy instanceof Function ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\n\n    this.isJunction = this.tableMetadataArgs.type === \"closure-junction\" || this.tableMetadataArgs.type === \"junction\";\n    this.isClosureJunction = this.tableMetadataArgs.type === \"closure-junction\";\n  };\n  /**\n   * Registers a new column in the entity and recomputes all depend properties.\n   */\n\n\n  EntityMetadata.prototype.registerColumn = function (column) {\n    if (this.ownColumns.indexOf(column) !== -1) return;\n    this.ownColumns.push(column);\n    this.columns = this.embeddeds.reduce(function (columns, embedded) {\n      return columns.concat(embedded.columnsFromTree);\n    }, this.ownColumns);\n    this.primaryColumns = this.columns.filter(function (column) {\n      return column.isPrimary;\n    });\n    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n    this.hasUUIDGeneratedColumns = this.columns.filter(function (column) {\n      return column.isGenerated || column.generationStrategy === \"uuid\";\n    }).length > 0;\n    this.propertiesMap = this.createPropertiesMap();\n    if (this.childEntityMetadatas) this.childEntityMetadatas.forEach(function (entityMetadata) {\n      return entityMetadata.registerColumn(column);\n    });\n  };\n  /**\n   * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n   * in a special format - { propertyName: propertyName }.\n   *\n   * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n   * This method will create following object:\n   * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n   */\n\n\n  EntityMetadata.prototype.createPropertiesMap = function () {\n    var map = {};\n    this.columns.forEach(function (column) {\n      return OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath));\n    });\n    this.relations.forEach(function (relation) {\n      return OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath));\n    });\n    return map;\n  };\n  /**\n   * Builds table path using database name, schema name and table name.\n   */\n\n\n  EntityMetadata.prototype.buildTablePath = function () {\n    var tablePath = this.tableName;\n\n    if (this.schema && (this.connection.driver instanceof OracleDriver || this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof SqlServerDriver || this.connection.driver instanceof SapDriver)) {\n      tablePath = this.schema + \".\" + tablePath;\n    }\n\n    if (this.database && !(this.connection.driver instanceof PostgresDriver)) {\n      if (!this.schema && this.connection.driver instanceof SqlServerDriver) {\n        tablePath = this.database + \"..\" + tablePath;\n      } else {\n        tablePath = this.database + \".\" + tablePath;\n      }\n    }\n\n    return tablePath;\n  };\n  /**\n   * Builds table path using schema name and database name.\n   */\n\n\n  EntityMetadata.prototype.buildSchemaPath = function () {\n    if (!this.schema) return undefined;\n    return this.database && !(this.connection.driver instanceof PostgresDriver) ? this.database + \".\" + this.schema : this.schema;\n  };\n\n  return EntityMetadata;\n}();\n\nexport { EntityMetadata };","map":{"version":3,"sources":["../browser/src/metadata/EntityMetadata.ts"],"names":[],"mappings":"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","sourcesContent":["import {QueryRunner, SelectQueryBuilder} from \"..\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {Connection} from \"../connection/Connection\";\nimport {PostgresConnectionOptions} from \"../driver/postgres/PostgresConnectionOptions\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {SapDriver} from \"../driver/sap/SapDriver\";\nimport {SqlServerConnectionOptions} from \"../driver/sqlserver/SqlServerConnectionOptions\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {CannotCreateEntityIdMapError} from \"../error/CannotCreateEntityIdMapError\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\nimport {TreeMetadataArgs} from \"../metadata-args/TreeMetadataArgs\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {shorten} from \"../util/StringUtils\";\nimport {CheckMetadata} from \"./CheckMetadata\";\nimport {ColumnMetadata} from \"./ColumnMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\nimport {EntityListenerMetadata} from \"./EntityListenerMetadata\";\nimport {ExclusionMetadata} from \"./ExclusionMetadata\";\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\nimport {IndexMetadata} from \"./IndexMetadata\";\nimport {RelationCountMetadata} from \"./RelationCountMetadata\";\nimport {RelationIdMetadata} from \"./RelationIdMetadata\";\nimport {RelationMetadata} from \"./RelationMetadata\";\nimport {TableType} from \"./types/TableTypes\";\nimport {TreeType} from \"./types/TreeTypes\";\nimport {UniqueMetadata} from \"./UniqueMetadata\";\nimport {ClosureTreeOptions} from \"./types/ClosureTreeOptions\";\n\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection where this entity metadata is created.\n     */\n    connection: Connection;\n\n    /**\n     * Metadata arguments used to build this entity metadata.\n     */\n    tableMetadataArgs: TableMetadataArgs;\n\n    /**\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\n     */\n    closureJunctionTable: EntityMetadata;\n\n    /**\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\n     */\n    parentClosureEntityMetadata: EntityMetadata;\n\n    /**\n     * Parent's entity metadata. Used in inheritance patterns.\n     */\n    parentEntityMetadata: EntityMetadata;\n\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    childEntityMetadatas: EntityMetadata[] = [];\n\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n    inheritanceTree: Function[] = [];\n\n    /**\n     * Table type. Tables can be abstract, closure, junction, embedded, etc.\n     */\n    tableType: TableType = \"regular\";\n\n    /**\n     * Target class to which this entity metadata is bind.\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\n     */\n    target: Function|string;\n\n    /**\n     * Gets the name of the target.\n     */\n    targetName: string;\n\n    /**\n     * Entity's name.\n     * Equal to entity target class's name if target is set to table.\n     * If target class is not then then it equals to table name.\n     */\n    name: string;\n\n    /**\n     * View's expression.\n     * Used in views\n     */\n    expression?: string|((connection: Connection) => SelectQueryBuilder<any>);\n\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n    withoutRowid?: boolean = false;\n\n    /**\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\n     * If user haven't specified a table name this property will be undefined.\n     */\n    givenTableName?: string;\n\n    /**\n     * Entity table name in the database.\n     * This is final table name of the entity.\n     * This name already passed naming strategy, and generated based on\n     * multiple criteria, including user table name and global table prefix.\n     */\n    tableName: string;\n\n    /**\n     * Entity table path. Contains database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    tablePath: string;\n\n    /**\n     * Entity schema path. Contains database name and schema name.\n     * E.g. myDB.mySchema\n     */\n    schemaPath?: string;\n\n    /**\n     * Gets the table name without global table prefix.\n     * When querying table you need a table name with prefix, but in some scenarios,\n     * for example when you want to name a junction table that contains names of two other tables,\n     * you may want a table name without prefix.\n     */\n    tableNameWithoutPrefix: string;\n\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n    synchronize: boolean = true;\n\n    /**\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\n     */\n    engine?: string;\n\n    /**\n     * Database name.\n     */\n    database?: string;\n\n    /**\n     * Schema name. Used in Postgres and Sql Server.\n     */\n    schema?: string;\n\n    /**\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\n     */\n    orderBy?: OrderByCondition;\n\n    /**\n     * If this entity metadata's table using one of the inheritance patterns,\n     * then this will contain what pattern it uses.\n     */\n    inheritancePattern?: \"STI\"/*|\"CTI\"*/;\n\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    hasNonNullableRelations: boolean = false;\n\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    isJunction: boolean = false;\n\n    /**\n     * Indicates if this entity is a tree, what type of tree it is.\n     */\n    treeType?: TreeType;\n\n    /**\n     * Indicates if this entity is a tree, what options of tree it has.\n     */\n    treeOptions?: ClosureTreeOptions;\n\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    isClosureJunction: boolean = false;\n\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    hasMultiplePrimaryKeys: boolean = false;\n\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n    hasUUIDGeneratedColumns: boolean = false;\n\n    /**\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\n     * Used to store a value in a discriminator column.\n     */\n    discriminatorValue?: string;\n\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    ownColumns: ColumnMetadata[] = [];\n\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    columns: ColumnMetadata[] = [];\n\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n    ancestorColumns: ColumnMetadata[] = [];\n\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n    descendantColumns: ColumnMetadata[] = [];\n\n    /**\n     * All columns except for virtual columns.\n     */\n    nonVirtualColumns: ColumnMetadata[] = [];\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    ownerColumns: ColumnMetadata[] = [];\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    inverseColumns: ColumnMetadata[] = [];\n\n    /**\n     * Gets the column with generated flag.\n     */\n    generatedColumns: ColumnMetadata[] = [];\n\n    /**\n     * Gets the object id column used with mongodb database.\n     */\n    objectIdColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains a create date value.\n     */\n    createDateColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains an update date value.\n     */\n    updateDateColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains a delete date value.\n     */\n    deleteDateColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains an entity version.\n     */\n    versionColumn?: ColumnMetadata;\n\n    /**\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\n     */\n    discriminatorColumn?: ColumnMetadata;\n\n    /**\n     * Special column that stores tree level in tree entities.\n     */\n    treeLevelColumn?: ColumnMetadata;\n\n    /**\n     * Nested set's left value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetLeftColumn?: ColumnMetadata;\n\n    /**\n     * Nested set's right value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetRightColumn?: ColumnMetadata;\n\n    /**\n     * Materialized path column.\n     * Used only in tree entities with materialized path pattern applied.\n     */\n    materializedPathColumn?: ColumnMetadata;\n\n    /**\n     * Gets the primary columns.\n     */\n    primaryColumns: ColumnMetadata[] = [];\n\n    /**\n     * Entity's relation metadatas.\n     */\n    ownRelations: RelationMetadata[] = [];\n\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    relations: RelationMetadata[] = [];\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    eagerRelations: RelationMetadata[] = [];\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    lazyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    oneToOneRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    ownerOneToOneRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    oneToManyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    manyToOneRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    manyToManyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    ownerManyToManyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    relationsWithJoinColumns: RelationMetadata[] = [];\n\n    /**\n     * Tree parent relation. Used only in tree-tables.\n     */\n    treeParentRelation?: RelationMetadata;\n\n    /**\n     * Tree children relation. Used only in tree-tables.\n     */\n    treeChildrenRelation?: RelationMetadata;\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationIds: RelationIdMetadata[] = [];\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationCounts: RelationCountMetadata[] = [];\n\n    /**\n     * Entity's foreign key metadatas.\n     */\n    foreignKeys: ForeignKeyMetadata[] = [];\n\n    /**\n     * Entity's embedded metadatas.\n     */\n    embeddeds: EmbeddedMetadata[] = [];\n\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n    allEmbeddeds: EmbeddedMetadata[] = [];\n\n    /**\n     * Entity's own indices.\n     */\n    ownIndices: IndexMetadata[] = [];\n\n    /**\n     * Entity's index metadatas.\n     */\n    indices: IndexMetadata[] = [];\n\n    /**\n     * Entity's unique metadatas.\n     */\n    uniques: UniqueMetadata[] = [];\n\n    /**\n     * Entity's own uniques.\n     */\n    ownUniques: UniqueMetadata[] = [];\n\n    /**\n     * Entity's check metadatas.\n     */\n    checks: CheckMetadata[] = [];\n\n    /**\n     * Entity's exclusion metadatas.\n     */\n    exclusions: ExclusionMetadata[] = [];\n\n    /**\n     * Entity's own listener metadatas.\n     */\n    ownListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Entity listener metadatas.\n     */\n    listeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n    afterLoadListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    beforeInsertListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    afterInsertListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    beforeUpdateListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    afterUpdateListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    beforeRemoveListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    afterRemoveListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Map of columns and relations of the entity.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    propertiesMap: ObjectLiteral;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: Connection,\n        inheritanceTree?: Function[],\n        inheritancePattern?: \"STI\"/*|\"CTI\"*/,\n        tableTree?: TreeMetadataArgs,\n        parentClosureEntityMetadata?: EntityMetadata,\n        args: TableMetadataArgs\n    }) {\n        this.connection = options.connection;\n        this.inheritanceTree = options.inheritanceTree || [];\n        this.inheritancePattern = options.inheritancePattern;\n        this.treeType = options.tableTree ? options.tableTree.type : undefined;\n        this.treeOptions = options.tableTree ? options.tableTree.options : undefined;\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!;\n        this.tableMetadataArgs = options.args;\n        this.target = this.tableMetadataArgs.target;\n        this.tableType = this.tableMetadataArgs.type;\n        this.expression = this.tableMetadataArgs.expression;\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new entity.\n     */\n    create(queryRunner?: QueryRunner): any {\n        // if target is set to a function (e.g. class) that can be created then create it\n        let ret: any;\n        if (this.target instanceof Function) {\n            ret = new (<any> this.target)();\n            this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));\n            return ret;\n        }\n\n        // otherwise simply return a new empty object\n        const newObject = {};\n        this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, newObject, queryRunner));\n        return newObject;\n    }\n\n    /**\n     * Checks if given entity has an id.\n     */\n    hasId(entity: ObjectLiteral): boolean {\n        if (!entity)\n            return false;\n\n        return this.primaryColumns.every(primaryColumn => {\n            const value = primaryColumn.getEntityValue(entity);\n            return value !== null && value !== undefined && value !== \"\";\n        });\n    }\n\n    /**\n     * Checks if given entity / object contains ALL primary keys entity must have.\n     * Returns true if it contains all of them, false if at least one of them is not defined.\n     */\n    hasAllPrimaryKeys(entity: ObjectLiteral): boolean {\n        return this.primaryColumns.every(primaryColumn => {\n            const value = primaryColumn.getEntityValue(entity);\n            return value !== null && value !== undefined;\n        });\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureEntityIdMap(id: any): ObjectLiteral {\n        if (id instanceof Object)\n            return id;\n\n        if (this.hasMultiplePrimaryKeys)\n            throw new CannotCreateEntityIdMapError(this, id);\n\n        return this.primaryColumns[0].createValueMap(id);\n    }\n\n    /**\n     * Gets primary keys of the entity and returns them in a literal object.\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n     * For multiple primary keys it returns multiple keys in object.\n     * For primary keys inside embeds it returns complex object literal with keys in them.\n     */\n    getEntityIdMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\n        if (!entity)\n            return undefined;\n\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, { skipNulls: true });\n    }\n\n    /**\n     * Creates a \"mixed id map\".\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n     * This is called mixed id map.\n     */\n    getEntityIdMixedMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\n        if (!entity)\n            return entity;\n\n        const idMap = this.getEntityIdMap(entity);\n        if (this.hasMultiplePrimaryKeys) {\n            return idMap;\n\n        } else if (idMap) {\n            return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\n        }\n\n        return idMap;\n    }\n\n    /**\n     * Compares two different entities by their ids.\n     * Returns true if they match, false otherwise.\n     */\n    compareEntities(firstEntity: ObjectLiteral, secondEntity: ObjectLiteral): boolean {\n\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity);\n        if (!firstEntityIdMap) return false;\n\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity);\n        if (!secondEntityIdMap) return false;\n\n        return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);\n    }\n\n    /**\n     * Finds column with a given property name.\n     */\n    findColumnWithPropertyName(propertyName: string): ColumnMetadata|undefined {\n        return this.columns.find(column => column.propertyName === propertyName);\n    }\n\n    /**\n     * Finds column with a given database name.\n     */\n    findColumnWithDatabaseName(databaseName: string): ColumnMetadata|undefined {\n        return this.columns.find(column => column.databaseName === databaseName);\n    }\n\n    /**\n     * Finds column with a given property path.\n     */\n    findColumnWithPropertyPath(propertyPath: string): ColumnMetadata|undefined {\n        const column = this.columns.find(column => column.propertyPath === propertyPath);\n        if (column)\n            return column;\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n        if (relation && relation.joinColumns.length === 1)\n            return relation.joinColumns[0];\n\n        return undefined;\n    }\n\n    /**\n     * Finds columns with a given property path.\n     * Property path can match a relation, and relations can contain multiple columns.\n     */\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\n        const column = this.columns.find(column => column.propertyPath === propertyPath);\n        if (column)\n            return [column];\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n        if (relation && relation.joinColumns)\n            return relation.joinColumns;\n\n        return [];\n    }\n\n    /**\n     * Finds relation with the given property path.\n     */\n    findRelationWithPropertyPath(propertyPath: string): RelationMetadata|undefined {\n        return this.relations.find(relation => relation.propertyPath === propertyPath);\n    }\n\n    /**\n     * Checks if there is an embedded with a given property path.\n     */\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\n        return this.allEmbeddeds.some(embedded => embedded.propertyPath === propertyPath);\n    }\n\n    /**\n     * Finds embedded with a given property path.\n     */\n    findEmbeddedWithPropertyPath(propertyPath: string): EmbeddedMetadata|undefined {\n        return this.allEmbeddeds.find(embedded => embedded.propertyPath === propertyPath);\n    }\n\n    /**\n     * Iterates through entity and finds and extracts all values from relations in the entity.\n     * If relation value is an array its being flattened.\n     */\n    extractRelationValuesFromEntity(entity: ObjectLiteral, relations: RelationMetadata[]): [RelationMetadata, any, EntityMetadata][] {\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = [];\n        relations.forEach(relation => {\n            const value = relation.getEntityValue(entity);\n            if (Array.isArray(value)) {\n                value.forEach(subValue => relationsAndValues.push([relation, subValue, this.getInverseEntityMetadata(subValue, relation)]));\n            } else if (value) {\n                relationsAndValues.push([relation, value, this.getInverseEntityMetadata(value, relation)]);\n            }\n        });\n        return relationsAndValues;\n    }\n\n    private getInverseEntityMetadata(value: any, relation: RelationMetadata): EntityMetadata {\n        const childEntityMetadata = relation.inverseEntityMetadata.childEntityMetadatas.find(metadata =>\n            metadata.target === value.constructor\n        );\n        return childEntityMetadata ? childEntityMetadata : relation.inverseEntityMetadata;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a property paths for a given entity.\n     */\n    static createPropertyPath(metadata: EntityMetadata, entity: ObjectLiteral, prefix: string = \"\") {\n        const paths: string[] = [];\n        Object.keys(entity).forEach(key => {\n\n            // check for function is needed in the cases when createPropertyPath used on values containg a function as a value\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n            const parentPath = prefix ? prefix + \".\" + key : key;\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n                const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);\n                paths.push(...subPaths);\n            } else {\n                const path = prefix ? prefix + \".\" + key : key;\n                paths.push(path);\n            }\n        });\n        return paths;\n    }\n\n    /**\n     * Finds difference between two entity id maps.\n     * Returns items that exist in the first array and absent in the second array.\n     */\n    static difference(firstIdMaps: ObjectLiteral[], secondIdMaps: ObjectLiteral[]): ObjectLiteral[] {\n        return firstIdMaps.filter(firstIdMap => {\n            return !secondIdMaps.find(secondIdMap => OrmUtils.compareIds(firstIdMap, secondIdMap));\n        });\n    }\n\n    /**\n     * Creates value map from the given values and columns.\n     * Examples of usages are primary columns map and join columns map.\n     */\n    static getValueMap(entity: ObjectLiteral, columns: ColumnMetadata[], options?: { skipNulls?: boolean }): ObjectLiteral|undefined {\n        return columns.reduce((map, column) => {\n            const value = column.getEntityValueMap(entity, options);\n\n            // make sure that none of the values of the columns are not missing\n            if (map === undefined || value === null || value === undefined)\n                return undefined;\n\n            return column.isObjectId ? Object.assign(map, value) : OrmUtils.mergeDeep(map, value);\n        }, {} as ObjectLiteral|undefined);\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    build() {\n        const namingStrategy = this.connection.namingStrategy;\n        const entityPrefix = this.connection.options.entityPrefix;\n        this.engine = this.tableMetadataArgs.engine;\n        this.database = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;\n        if (this.tableMetadataArgs.schema) {\n            this.schema = this.tableMetadataArgs.schema;\n        }\n        else if ((this.tableMetadataArgs.type === \"entity-child\") && this.parentEntityMetadata) {\n            this.schema = this.parentEntityMetadata.schema;\n        }\n        else {\n            this.schema = (this.connection.options as PostgresConnectionOptions|SqlServerConnectionOptions).schema;\n        }\n        this.givenTableName = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;\n        this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;\n        this.targetName = this.tableMetadataArgs.target instanceof Function ? (this.tableMetadataArgs.target as any).name : this.tableMetadataArgs.target;\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\n            this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName!);\n        } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\n        } else {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\n\n            if (this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {\n                this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, { separator: \"_\", segmentLength: 3 });\n            }\n        }\n        this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\n        this.target = this.target ? this.target : this.tableName;\n        this.name = this.targetName ? this.targetName : this.tableName;\n        this.expression = this.tableMetadataArgs.expression;\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;\n        this.tablePath = this.buildTablePath();\n        this.schemaPath = this.buildSchemaPath();\n        this.orderBy = (this.tableMetadataArgs.orderBy instanceof Function) ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\n\n        this.isJunction = this.tableMetadataArgs.type === \"closure-junction\" || this.tableMetadataArgs.type === \"junction\";\n        this.isClosureJunction = this.tableMetadataArgs.type === \"closure-junction\";\n    }\n\n    /**\n     * Registers a new column in the entity and recomputes all depend properties.\n     */\n    registerColumn(column: ColumnMetadata) {\n        if (this.ownColumns.indexOf(column) !== -1)\n            return;\n\n        this.ownColumns.push(column);\n        this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\n        this.primaryColumns = this.columns.filter(column => column.isPrimary);\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n        this.hasUUIDGeneratedColumns = this.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n        this.propertiesMap = this.createPropertiesMap();\n        if (this.childEntityMetadatas)\n            this.childEntityMetadatas.forEach(entityMetadata => entityMetadata.registerColumn(column));\n    }\n\n    /**\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n     * in a special format - { propertyName: propertyName }.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    createPropertiesMap(): { [name: string]: string|any } {\n        const map: { [name: string]: string|any } = {};\n        this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\n        this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\n        return map;\n    }\n\n    /**\n     * Builds table path using database name, schema name and table name.\n     */\n    protected buildTablePath(): string {\n        let tablePath = this.tableName;\n        if (this.schema && ((this.connection.driver instanceof OracleDriver) || (this.connection.driver instanceof PostgresDriver) || (this.connection.driver instanceof SqlServerDriver) || (this.connection.driver instanceof SapDriver))) {\n            tablePath = this.schema + \".\" + tablePath;\n        }\n\n        if (this.database && !(this.connection.driver instanceof PostgresDriver)) {\n            if (!this.schema && this.connection.driver instanceof SqlServerDriver) {\n                tablePath = this.database + \"..\" + tablePath;\n            } else {\n                tablePath = this.database + \".\" + tablePath;\n            }\n        }\n\n        return tablePath;\n    }\n\n    /**\n     * Builds table path using schema name and database name.\n     */\n    protected buildSchemaPath(): string|undefined {\n        if (!this.schema)\n            return undefined;\n\n        return this.database && !(this.connection.driver instanceof PostgresDriver) ? this.database + \".\" + this.schema : this.schema;\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}