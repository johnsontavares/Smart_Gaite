{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\n\nexport function Column(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    var type;\n\n    if (typeof typeOrOptions === \"string\" || typeOrOptions instanceof Function) {\n      type = typeOrOptions;\n    } else if (typeOrOptions) {\n      options = typeOrOptions;\n      type = typeOrOptions.type;\n    }\n\n    if (!options) options = {}; // if type is not given explicitly then try to guess it\n\n    var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType) // if type is not given explicitly then try to guess it\n      type = reflectMetadataType; // check if there is no type in column options then set type from first function argument, or guessed one\n\n    if (!options.type && type) options.type = type; // specify HSTORE type if column is HSTORE\n\n    if (options.type === \"hstore\" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n\n    if (typeOrOptions instanceof Function) {\n      // register an embedded\n      getMetadataArgsStorage().embeddeds.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        isArray: reflectMetadataType === Array || options.array === true,\n        prefix: options.prefix !== undefined ? options.prefix : undefined,\n        type: typeOrOptions\n      });\n    } else {\n      // register a regular column\n      // if we still don't have a type then we need to give error to user that type is required\n      if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName); // create unique\n\n      if (options.unique === true) getMetadataArgsStorage().uniques.push({\n        target: object.constructor,\n        columns: [propertyName]\n      });\n      getMetadataArgsStorage().columns.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        mode: \"regular\",\n        options: options\n      });\n\n      if (options.generated) {\n        getMetadataArgsStorage().generations.push({\n          target: object.constructor,\n          propertyName: propertyName,\n          strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n        });\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../browser/src/decorator/columns/Column.ts"],"names":[],"mappings":"AAAA,SAAuB,sBAAvB,QAAoD,QAApD;AAiBA,SAAQ,wBAAR,QAAuC,sCAAvC;AAiFA;;;AAGG;;AACH,OAAM,SAAU,MAAV,CAAiB,aAAjB,EAA8G,OAA9G,EAA6J;AAC/J,SAAO,UAAU,MAAV,EAA0B,YAA1B,EAA8C;AAEjD;AACA,QAAI,IAAJ;;AACA,QAAI,OAAO,aAAP,KAAyB,QAAzB,IAAqC,aAAa,YAAY,QAAlE,EAA4E;AACxE,MAAA,IAAI,GAAgB,aAApB;AAEH,KAHD,MAGO,IAAI,aAAJ,EAAmB;AACtB,MAAA,OAAO,GAAmB,aAA1B;AACA,MAAA,IAAI,GAAG,aAAa,CAAC,IAArB;AACH;;AACD,QAAI,CAAC,OAAL,EAAc,OAAO,GAAG,EAAV,CAXmC,CAajD;;AACA,QAAM,mBAAmB,GAAG,OAAO,IAAK,OAAe,CAAC,WAA5B,GAA2C,OAAe,CAAC,WAAhB,CAA4B,aAA5B,EAA2C,MAA3C,EAAmD,YAAnD,CAA3C,GAA8G,SAA1I;AACA,QAAI,CAAC,IAAD,IAAS,mBAAb,EAAkC;AAC9B,MAAA,IAAI,GAAG,mBAAP,CAhB6C,CAkBjD;;AACA,QAAI,CAAC,OAAO,CAAC,IAAT,IAAiB,IAArB,EACI,OAAO,CAAC,IAAR,GAAe,IAAf,CApB6C,CAsBjD;;AACA,QAAI,OAAO,CAAC,IAAR,KAAiB,QAAjB,IAA6B,CAAC,OAAO,CAAC,UAA1C,EACI,OAAO,CAAC,UAAR,GAAqB,mBAAmB,KAAK,MAAxB,GAAiC,QAAjC,GAA4C,QAAjE;;AAEJ,QAAI,aAAa,YAAY,QAA7B,EAAuC;AAAE;AACrC,MAAA,sBAAsB,GAAG,SAAzB,CAAmC,IAAnC,CAAwC;AACpC,QAAA,MAAM,EAAE,MAAM,CAAC,WADqB;AAEpC,QAAA,YAAY,EAAE,YAFsB;AAGpC,QAAA,OAAO,EAAE,mBAAmB,KAAK,KAAxB,IAAiC,OAAO,CAAC,KAAR,KAAkB,IAHxB;AAIpC,QAAA,MAAM,EAAE,OAAO,CAAC,MAAR,KAAmB,SAAnB,GAA+B,OAAO,CAAC,MAAvC,GAAgD,SAJpB;AAKpC,QAAA,IAAI,EAAE;AAL8B,OAAxC;AAQH,KATD,MASO;AAAE;AAEL;AACA,UAAI,CAAC,OAAO,CAAC,IAAb,EACI,MAAM,IAAI,wBAAJ,CAA6B,MAA7B,EAAqC,YAArC,CAAN,CAJD,CAMH;;AACA,UAAI,OAAO,CAAC,MAAR,KAAmB,IAAvB,EACI,sBAAsB,GAAG,OAAzB,CAAiC,IAAjC,CAAsC;AAAE,QAAA,MAAM,EAAE,MAAM,CAAC,WAAjB;AAA8B,QAAA,OAAO,EAAE,CAAC,YAAD;AAAvC,OAAtC;AAEJ,MAAA,sBAAsB,GAAG,OAAzB,CAAiC,IAAjC,CAAsC;AAClC,QAAA,MAAM,EAAE,MAAM,CAAC,WADmB;AAElC,QAAA,YAAY,EAAE,YAFoB;AAGlC,QAAA,IAAI,EAAE,SAH4B;AAIlC,QAAA,OAAO,EAAE;AAJyB,OAAtC;;AAOA,UAAI,OAAO,CAAC,SAAZ,EAAuB;AACnB,QAAA,sBAAsB,GAAG,WAAzB,CAAqC,IAArC,CAA0C;AACtC,UAAA,MAAM,EAAE,MAAM,CAAC,WADuB;AAEtC,UAAA,YAAY,EAAE,YAFwB;AAGtC,UAAA,QAAQ,EAAE,OAAO,OAAO,CAAC,SAAf,KAA6B,QAA7B,GAAwC,OAAO,CAAC,SAAhD,GAA4D;AAHhC,SAA1C;AAKH;AACJ;AACJ,GA5DD;AA6DH","sourcesContent":["import {ColumnOptions, getMetadataArgsStorage} from \"../../\";\nimport {\n    ColumnType,\n    SimpleColumnType,\n    SpatialColumnType,\n    WithLengthColumnType,\n    WithPrecisionColumnType,\n    WithWidthColumnType\n} from \"../../driver/types/ColumnTypes\";\nimport {ColumnMetadataArgs} from \"../../metadata-args/ColumnMetadataArgs\";\nimport {ColumnCommonOptions} from \"../options/ColumnCommonOptions\";\nimport {SpatialColumnOptions} from \"../options/SpatialColumnOptions\";\nimport {ColumnWithLengthOptions} from \"../options/ColumnWithLengthOptions\";\nimport {ColumnNumericOptions} from \"../options/ColumnNumericOptions\";\nimport {ColumnEnumOptions} from \"../options/ColumnEnumOptions\";\nimport {ColumnEmbeddedOptions} from \"../options/ColumnEmbeddedOptions\";\nimport {EmbeddedMetadataArgs} from \"../../metadata-args/EmbeddedMetadataArgs\";\nimport {ColumnTypeUndefinedError} from \"../../error/ColumnTypeUndefinedError\";\nimport {ColumnHstoreOptions} from \"../options/ColumnHstoreOptions\";\nimport {ColumnWithWidthOptions} from \"../options/ColumnWithWidthOptions\";\nimport {GeneratedMetadataArgs} from \"../../metadata-args/GeneratedMetadataArgs\";\n\n/**\n * Column decorator is used to mark a specific class property as a table column. Only properties decorated with this\n * decorator will be persisted to the database when entity be saved.\n */\nexport function Column(): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(options: ColumnOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: SimpleColumnType, options?: ColumnCommonOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: SpatialColumnType, options?: ColumnCommonOptions & SpatialColumnOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: WithLengthColumnType, options?: ColumnCommonOptions & ColumnWithLengthOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: WithWidthColumnType, options?: ColumnCommonOptions & ColumnWithWidthOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: WithPrecisionColumnType, options?: ColumnCommonOptions & ColumnNumericOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: \"enum\", options?: ColumnCommonOptions & ColumnEnumOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: \"simple-enum\", options?: ColumnCommonOptions & ColumnEnumOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: \"set\", options?: ColumnCommonOptions & ColumnEnumOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(type: \"hstore\", options?: ColumnCommonOptions & ColumnHstoreOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n *\n * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the\n * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the\n * embedded will be mapped to it from the single table.\n */\nexport function Column(type: (type?: any) => Function, options?: ColumnEmbeddedOptions): PropertyDecorator;\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(typeOrOptions?: ((type?: any) => Function)|ColumnType|(ColumnOptions&ColumnEmbeddedOptions), options?: (ColumnOptions&ColumnEmbeddedOptions)): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n\n        // normalize parameters\n        let type: ColumnType|undefined;\n        if (typeof typeOrOptions === \"string\" || typeOrOptions instanceof Function) {\n            type = <ColumnType> typeOrOptions;\n\n        } else if (typeOrOptions) {\n            options = <ColumnOptions> typeOrOptions;\n            type = typeOrOptions.type;\n        }\n        if (!options) options = {} as ColumnOptions;\n\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType = Reflect && (Reflect as any).getMetadata ? (Reflect as any).getMetadata(\"design:type\", object, propertyName) : undefined;\n        if (!type && reflectMetadataType) // if type is not given explicitly then try to guess it\n            type = reflectMetadataType;\n\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type)\n            options.type = type;\n\n        // specify HSTORE type if column is HSTORE\n        if (options.type === \"hstore\" && !options.hstoreType)\n            options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n\n        if (typeOrOptions instanceof Function) { // register an embedded\n            getMetadataArgsStorage().embeddeds.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                isArray: reflectMetadataType === Array || options.array === true,\n                prefix: options.prefix !== undefined ? options.prefix : undefined,\n                type: typeOrOptions as (type?: any) => Function\n            } as EmbeddedMetadataArgs);\n\n        } else { // register a regular column\n\n            // if we still don't have a type then we need to give error to user that type is required\n            if (!options.type)\n                throw new ColumnTypeUndefinedError(object, propertyName);\n\n            // create unique\n            if (options.unique === true)\n                getMetadataArgsStorage().uniques.push({ target: object.constructor, columns: [propertyName] });\n\n            getMetadataArgsStorage().columns.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                mode: \"regular\",\n                options: options\n            } as ColumnMetadataArgs);\n\n            if (options.generated) {\n                getMetadataArgsStorage().generations.push({\n                    target: object.constructor,\n                    propertyName: propertyName,\n                    strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n                } as GeneratedMetadataArgs);\n            }\n        }\n    };\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}