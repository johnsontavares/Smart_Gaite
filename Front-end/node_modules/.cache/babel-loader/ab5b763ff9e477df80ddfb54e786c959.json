{"ast":null,"code":"import { DateUtils } from \"../util/DateUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\n/**\n * Finds what columns are changed in the subject entities.\n */\n\nvar SubjectChangedColumnsComputer =\n/** @class */\nfunction () {\n  function SubjectChangedColumnsComputer() {} // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Finds what columns are changed in the subject entities.\n   */\n\n\n  SubjectChangedColumnsComputer.prototype.compute = function (subjects) {\n    var _this = this;\n\n    subjects.forEach(function (subject) {\n      _this.computeDiffColumns(subject);\n\n      _this.computeDiffRelationalColumns(subjects, subject);\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Differentiate columns from the updated entity and entity stored in the database.\n   */\n\n\n  SubjectChangedColumnsComputer.prototype.computeDiffColumns = function (subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.columns.forEach(function (column) {\n      // ignore special columns\n      if (column.isVirtual || column.isDiscriminator // ||\n      // column.isUpdateDate ||\n      // column.isVersion ||\n      // column.isCreateDate\n      ) return;\n      var changeMap = subject.changeMaps.find(function (changeMap) {\n        return changeMap.column === column;\n      });\n\n      if (changeMap) {\n        subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);\n      } // get user provided value - column value from the user provided persisted entity\n\n\n      var entityValue = column.getEntityValue(subject.entity); // we don't perform operation over undefined properties (but we DO need null properties!)\n\n      if (entityValue === undefined) return; // if there is no database entity then all columns are treated as new, e.g. changed\n\n      if (subject.databaseEntity) {\n        // skip transform database value for json / jsonb for comparison later on\n        var shouldTransformDatabaseEntity = column.type !== \"json\" && column.type !== \"jsonb\"; // get database value of the column\n\n        var databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity); // filter out \"relational columns\" only in the case if there is a relation object in entity\n\n        if (column.relationMetadata) {\n          var value = column.relationMetadata.getEntityValue(subject.entity);\n          if (value !== null && value !== undefined) return;\n        }\n\n        var normalizedValue = entityValue; // normalize special values to make proper comparision\n\n        if (entityValue !== null) {\n          switch (column.type) {\n            case \"date\":\n              normalizedValue = DateUtils.mixedDateToDateString(entityValue);\n              break;\n\n            case \"time\":\n            case \"time with time zone\":\n            case \"time without time zone\":\n            case \"timetz\":\n              normalizedValue = DateUtils.mixedDateToTimeString(entityValue);\n              break;\n\n            case \"datetime\":\n            case \"datetime2\":\n            case Date:\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n            case \"timestamp with time zone\":\n            case \"timestamp with local time zone\":\n            case \"timestamptz\":\n              normalizedValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);\n              databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n              break;\n\n            case \"json\":\n            case \"jsonb\":\n              // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n              // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n              // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n              if (OrmUtils.deepCompare(entityValue, databaseValue)) return;\n              break;\n\n            case \"simple-array\":\n              normalizedValue = DateUtils.simpleArrayToString(entityValue);\n              databaseValue = DateUtils.simpleArrayToString(databaseValue);\n              break;\n\n            case \"simple-enum\":\n              normalizedValue = DateUtils.simpleEnumToString(entityValue);\n              databaseValue = DateUtils.simpleEnumToString(databaseValue);\n              break;\n\n            case \"simple-json\":\n              normalizedValue = DateUtils.simpleJsonToString(entityValue);\n              databaseValue = DateUtils.simpleJsonToString(databaseValue);\n              break;\n          }\n\n          if (column.transformer) {\n            normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);\n          }\n        } // if value is not changed - then do nothing\n\n\n        if (normalizedValue === databaseValue) return;\n      }\n\n      subject.diffColumns.push(column);\n      subject.changeMaps.push({\n        column: column,\n        value: entityValue\n      });\n    });\n  };\n  /**\n   * Difference columns of the owning one-to-one and many-to-one columns.\n   */\n\n\n  SubjectChangedColumnsComputer.prototype.computeDiffRelationalColumns = function (allSubjects, subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.relationsWithJoinColumns.forEach(function (relation) {\n      // get the related entity from the persisted entity\n      var relatedEntity = relation.getEntityValue(subject.entity); // we don't perform operation over undefined properties (but we DO need null properties!)\n\n      if (relatedEntity === undefined) return; // if there is no database entity then all relational columns are treated as new, e.g. changed\n\n      if (subject.databaseEntity) {\n        // here we cover two scenarios:\n        // 1. related entity can be another entity which is natural way\n        // 2. related entity can be just an entity id\n        // if relation entity is just a relation id set (for example post.tag = 1)\n        // then we create an id map from it to make a proper comparision\n        var relatedEntityRelationIdMap = relatedEntity;\n        if (relatedEntityRelationIdMap !== null && relatedEntityRelationIdMap instanceof Object) relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap); // get database related entity. Since loadRelationIds are used on databaseEntity\n        // related entity will contain only its relation ids\n\n        var databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity); // if relation ids are equal then we don't need to update anything\n\n        var areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);\n\n        if (areRelatedIdsEqual) {\n          return;\n        } else {\n          subject.diffRelations.push(relation);\n        }\n      } // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n      // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n\n\n      var valueSubject = allSubjects.find(function (subject) {\n        return subject.mustBeInserted && subject.entity === relatedEntity;\n      });\n      if (valueSubject) relatedEntity = valueSubject; // find if there is already a relation to be changed\n\n      var changeMap = subject.changeMaps.find(function (changeMap) {\n        return changeMap.relation === relation;\n      });\n\n      if (changeMap) {\n        // and update its value if it was found\n        changeMap.value = relatedEntity;\n      } else {\n        // if it wasn't found add a new relation for change\n        subject.changeMaps.push({\n          relation: relation,\n          value: relatedEntity\n        });\n      }\n    });\n  };\n\n  return SubjectChangedColumnsComputer;\n}();\n\nexport { SubjectChangedColumnsComputer };","map":{"version":3,"sources":["../browser/src/persistence/SubjectChangedColumnsComputer.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"./Subject\";\nimport {DateUtils} from \"../util/DateUtils\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {ApplyValueTransformers} from \"../util/ApplyValueTransformers\";\n\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds what columns are changed in the subject entities.\n     */\n    compute(subjects: Subject[]) {\n        subjects.forEach(subject => {\n            this.computeDiffColumns(subject);\n            this.computeDiffRelationalColumns(subjects, subject);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    protected computeDiffColumns(subject: Subject): void {\n\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity)\n            return;\n\n        subject.metadata.columns.forEach(column => {\n\n            // ignore special columns\n            if (column.isVirtual ||\n                column.isDiscriminator // ||\n                // column.isUpdateDate ||\n                // column.isVersion ||\n                // column.isCreateDate\n            )\n                return;\n\n            const changeMap = subject.changeMaps.find(changeMap => changeMap.column === column);\n            if (changeMap) {\n                subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);\n            }\n\n            // get user provided value - column value from the user provided persisted entity\n            const entityValue = column.getEntityValue(subject.entity!);\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (entityValue === undefined)\n                return;\n\n            // if there is no database entity then all columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // skip transform database value for json / jsonb for comparison later on\n                const shouldTransformDatabaseEntity = column.type !== \"json\" && column.type !== \"jsonb\";\n\n                // get database value of the column\n                let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);\n\n                // filter out \"relational columns\" only in the case if there is a relation object in entity\n                if (column.relationMetadata) {\n                    const value = column.relationMetadata.getEntityValue(subject.entity!);\n                    if (value !== null && value !== undefined)\n                        return;\n                }\n                let normalizedValue = entityValue;\n                // normalize special values to make proper comparision\n                if (entityValue !== null) {\n                    switch (column.type) {\n                        case \"date\":\n                            normalizedValue = DateUtils.mixedDateToDateString(entityValue);\n                            break;\n\n                        case \"time\":\n                        case \"time with time zone\":\n                        case \"time without time zone\":\n                        case \"timetz\":\n                            normalizedValue = DateUtils.mixedDateToTimeString(entityValue);\n                            break;\n\n                        case \"datetime\":\n                        case \"datetime2\":\n                        case Date:\n                        case \"timestamp\":\n                        case \"timestamp without time zone\":\n                        case \"timestamp with time zone\":\n                        case \"timestamp with local time zone\":\n                        case \"timestamptz\":\n                            normalizedValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);\n                            databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n                            break;\n\n                        case \"json\":\n                        case \"jsonb\":\n                            // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n                            // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n                            // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n                            if (OrmUtils.deepCompare(entityValue, databaseValue)) return;\n                            break;\n\n                        case \"simple-array\":\n                            normalizedValue = DateUtils.simpleArrayToString(entityValue);\n                            databaseValue = DateUtils.simpleArrayToString(databaseValue);\n                            break;\n                        case \"simple-enum\":\n                            normalizedValue = DateUtils.simpleEnumToString(entityValue);\n                            databaseValue = DateUtils.simpleEnumToString(databaseValue);\n                            break;\n                        case \"simple-json\":\n                            normalizedValue = DateUtils.simpleJsonToString(entityValue);\n                            databaseValue = DateUtils.simpleJsonToString(databaseValue);\n                            break;\n                    }\n\n                    if (column.transformer) {\n                        normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);\n                    }\n                }\n\n                // if value is not changed - then do nothing\n                if (normalizedValue === databaseValue)\n                    return;\n            }\n            subject.diffColumns.push(column);\n            subject.changeMaps.push({\n                column: column,\n                value: entityValue\n            });\n        });\n    }\n\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    protected computeDiffRelationalColumns(allSubjects: Subject[], subject: Subject): void {\n\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity)\n            return;\n\n        subject.metadata.relationsWithJoinColumns.forEach(relation => {\n\n            // get the related entity from the persisted entity\n            let relatedEntity = relation.getEntityValue(subject.entity!);\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (relatedEntity === undefined)\n                return;\n\n            // if there is no database entity then all relational columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n\n                // here we cover two scenarios:\n                // 1. related entity can be another entity which is natural way\n                // 2. related entity can be just an entity id\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we create an id map from it to make a proper comparision\n                let relatedEntityRelationIdMap: ObjectLiteral = relatedEntity;\n                if (relatedEntityRelationIdMap !== null && relatedEntityRelationIdMap instanceof Object)\n                    relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap)!;\n\n                // get database related entity. Since loadRelationIds are used on databaseEntity\n                // related entity will contain only its relation ids\n                const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);\n\n                // if relation ids are equal then we don't need to update anything\n                const areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);\n                if (areRelatedIdsEqual) {\n                    return;\n                } else {\n                    subject.diffRelations.push(relation);\n                }\n            }\n\n            // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n            // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n            const valueSubject = allSubjects.find(subject => subject.mustBeInserted && subject.entity === relatedEntity);\n            if (valueSubject)\n                relatedEntity = valueSubject;\n\n            // find if there is already a relation to be changed\n            const changeMap = subject.changeMaps.find(changeMap => changeMap.relation === relation);\n            if (changeMap) { // and update its value if it was found\n                changeMap.value = relatedEntity;\n\n            } else { // if it wasn't found add a new relation for change\n                subject.changeMaps.push({\n                    relation: relation,\n                    value: relatedEntity\n                });\n            }\n        });\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}