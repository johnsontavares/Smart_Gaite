{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\n\nvar SubjectTopoligicalSorter =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function SubjectTopoligicalSorter(subjects) {\n    this.subjects = __spreadArray([], __read(subjects)); // copy subjects to prevent changing of sent array\n\n    this.metadatas = this.getUniqueMetadatas(this.subjects);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Sorts (orders) subjects in their topological order.\n   */\n\n\n  SubjectTopoligicalSorter.prototype.sort = function (direction) {\n    var _this = this; // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n\n\n    if (!this.metadatas.length) return this.subjects;\n    var sortedSubjects = []; // first if we sort for deletion all junction subjects\n    // junction subjects are subjects without entity and database entity set\n\n    if (direction === \"delete\") {\n      var junctionSubjects = this.subjects.filter(function (subject) {\n        return !subject.entity && !subject.databaseEntity;\n      });\n      sortedSubjects.push.apply(sortedSubjects, __spreadArray([], __read(junctionSubjects)));\n      this.removeAlreadySorted(junctionSubjects);\n    } // next we always insert entities with non-nullable relations, sort them first\n\n\n    var nonNullableDependencies = this.getNonNullableDependencies();\n    var sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);\n    if (direction === \"insert\") sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse(); // so we have a sorted entity targets\n    // go thought each of them and find all subjects with sorted entity target\n    // add those sorted targets and remove them from original array of targets\n\n    sortedNonNullableEntityTargets.forEach(function (sortedEntityTarget) {\n      var entityTargetSubjects = _this.subjects.filter(function (subject) {\n        return subject.metadata.targetName === sortedEntityTarget;\n      });\n\n      sortedSubjects.push.apply(sortedSubjects, __spreadArray([], __read(entityTargetSubjects)));\n\n      _this.removeAlreadySorted(entityTargetSubjects);\n    }); // next sort all other entities\n    // same process as in above but with other entities\n\n    var otherDependencies = this.getDependencies();\n    var sortedOtherEntityTargets = this.toposort(otherDependencies);\n    if (direction === \"insert\") sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();\n    sortedOtherEntityTargets.forEach(function (sortedEntityTarget) {\n      var entityTargetSubjects = _this.subjects.filter(function (subject) {\n        return subject.metadata.targetName === sortedEntityTarget;\n      });\n\n      sortedSubjects.push.apply(sortedSubjects, __spreadArray([], __read(entityTargetSubjects)));\n\n      _this.removeAlreadySorted(entityTargetSubjects);\n    }); // if we have something left in the subjects add them as well\n\n    sortedSubjects.push.apply(sortedSubjects, __spreadArray([], __read(this.subjects)));\n    return sortedSubjects;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Removes already sorted subjects from this.subjects list of subjects.\n   */\n\n\n  SubjectTopoligicalSorter.prototype.removeAlreadySorted = function (subjects) {\n    var _this = this;\n\n    subjects.forEach(function (subject) {\n      _this.subjects.splice(_this.subjects.indexOf(subject), 1);\n    });\n  };\n  /**\n   * Extracts all unique metadatas from the given subjects.\n   */\n\n\n  SubjectTopoligicalSorter.prototype.getUniqueMetadatas = function (subjects) {\n    var metadatas = [];\n    subjects.forEach(function (subject) {\n      if (metadatas.indexOf(subject.metadata) === -1) metadatas.push(subject.metadata);\n    });\n    return metadatas;\n  };\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n\n\n  SubjectTopoligicalSorter.prototype.getNonNullableDependencies = function () {\n    return this.metadatas.reduce(function (dependencies, metadata) {\n      metadata.relationsWithJoinColumns.forEach(function (relation) {\n        if (relation.isNullable) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  };\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n\n\n  SubjectTopoligicalSorter.prototype.getDependencies = function () {\n    return this.metadatas.reduce(function (dependencies, metadata) {\n      metadata.relationsWithJoinColumns.forEach(function (relation) {\n        // if relation is self-referenced we skip it\n        if (relation.inverseEntityMetadata === metadata) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  };\n  /**\n   * Sorts given graph using topological sorting algorithm.\n   *\n   * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n   */\n\n\n  SubjectTopoligicalSorter.prototype.toposort = function (edges) {\n    function uniqueNodes(arr) {\n      var res = [];\n\n      for (var i_1 = 0, len = arr.length; i_1 < len; i_1++) {\n        var edge = arr[i_1];\n        if (res.indexOf(edge[0]) < 0) res.push(edge[0]);\n        if (res.indexOf(edge[1]) < 0) res.push(edge[1]);\n      }\n\n      return res;\n    }\n\n    var nodes = uniqueNodes(edges);\n    var cursor = nodes.length,\n        sorted = new Array(cursor),\n        visited = {},\n        i = cursor;\n\n    while (i--) {\n      if (!visited[i]) visit(nodes[i], i, []);\n    }\n\n    function visit(node, i, predecessors) {\n      if (predecessors.indexOf(node) >= 0) {\n        throw new Error(\"Cyclic dependency: \" + JSON.stringify(node)); // todo: better error\n      }\n\n      if (!~nodes.indexOf(node)) {\n        throw new Error(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" + JSON.stringify(node));\n      }\n\n      if (visited[i]) return;\n      visited[i] = true; // outgoing edges\n\n      var outgoing = edges.filter(function (edge) {\n        return edge[0] === node;\n      });\n\n      if (i = outgoing.length) {\n        var preds = predecessors.concat(node);\n\n        do {\n          var child = outgoing[--i][1];\n          visit(child, nodes.indexOf(child), preds);\n        } while (i);\n      }\n\n      sorted[--cursor] = node;\n    }\n\n    return sorted;\n  };\n\n  return SubjectTopoligicalSorter;\n}();\n\nexport { SubjectTopoligicalSorter };","map":{"version":3,"sources":["../browser/src/persistence/SubjectTopoligicalSorter.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"./Subject\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\n\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopoligicalSorter {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Insert subjects needs to be sorted.\n     */\n    subjects: Subject[];\n\n    /**\n     * Unique list of entity metadatas of this subject.\n     */\n    metadatas: EntityMetadata[];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(subjects: Subject[]) {\n        this.subjects = [...subjects]; // copy subjects to prevent changing of sent array\n        this.metadatas = this.getUniqueMetadatas(this.subjects);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sorts (orders) subjects in their topological order.\n     */\n    sort(direction: \"insert\"|\"delete\"): Subject[] {\n\n        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n        if (!this.metadatas.length)\n            return this.subjects;\n\n        const sortedSubjects: Subject[] = [];\n\n        // first if we sort for deletion all junction subjects\n        // junction subjects are subjects without entity and database entity set\n        if (direction === \"delete\") {\n            const junctionSubjects = this.subjects.filter(subject => !subject.entity && !subject.databaseEntity);\n            sortedSubjects.push(...junctionSubjects);\n            this.removeAlreadySorted(junctionSubjects);\n        }\n\n        // next we always insert entities with non-nullable relations, sort them first\n        const nonNullableDependencies = this.getNonNullableDependencies();\n        let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);\n        if (direction === \"insert\")\n            sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse();\n\n        // so we have a sorted entity targets\n        // go thought each of them and find all subjects with sorted entity target\n        // add those sorted targets and remove them from original array of targets\n        sortedNonNullableEntityTargets.forEach(sortedEntityTarget => {\n            const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget);\n            sortedSubjects.push(...entityTargetSubjects);\n            this.removeAlreadySorted(entityTargetSubjects);\n        });\n\n        // next sort all other entities\n        // same process as in above but with other entities\n        const otherDependencies: string[][] = this.getDependencies();\n        let sortedOtherEntityTargets = this.toposort(otherDependencies);\n        if (direction === \"insert\")\n            sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();\n\n        sortedOtherEntityTargets.forEach(sortedEntityTarget => {\n            const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget);\n            sortedSubjects.push(...entityTargetSubjects);\n            this.removeAlreadySorted(entityTargetSubjects);\n        });\n\n        // if we have something left in the subjects add them as well\n        sortedSubjects.push(...this.subjects);\n        return sortedSubjects;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes already sorted subjects from this.subjects list of subjects.\n     */\n    protected removeAlreadySorted(subjects: Subject[]) {\n        subjects.forEach(subject => {\n            this.subjects.splice(this.subjects.indexOf(subject), 1);\n        });\n    }\n\n    /**\n     * Extracts all unique metadatas from the given subjects.\n     */\n    protected getUniqueMetadatas(subjects: Subject[]) {\n        const metadatas: EntityMetadata[] = [];\n        subjects.forEach(subject => {\n            if (metadatas.indexOf(subject.metadata) === -1)\n                metadatas.push(subject.metadata);\n        });\n        return metadatas;\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getNonNullableDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach(relation => {\n                if (relation.isNullable)\n                    return;\n\n                dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n            });\n            return dependencies;\n        }, [] as string[][]);\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach(relation => {\n\n                // if relation is self-referenced we skip it\n                if (relation.inverseEntityMetadata === metadata)\n                    return;\n\n                dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n            });\n            return dependencies;\n        }, [] as string[][]);\n    }\n\n    /**\n     * Sorts given graph using topological sorting algorithm.\n     *\n     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n     */\n    protected toposort(edges: any[][]) {\n\n        function uniqueNodes(arr: any[]) {\n            let res = [];\n            for (let i = 0, len = arr.length; i < len; i++) {\n                let edge: any = arr[i];\n                if (res.indexOf(edge[0]) < 0) res.push(edge[0]);\n                if (res.indexOf(edge[1]) < 0) res.push(edge[1]);\n            }\n            return res;\n        }\n\n        const nodes = uniqueNodes(edges);\n        let cursor = nodes.length\n            , sorted = new Array(cursor)\n            , visited: any = {}\n            , i = cursor;\n\n        while (i--) {\n            if (!visited[i]) visit(nodes[i], i, []);\n        }\n\n        function visit(node: any, i: number, predecessors: any[]) {\n            if (predecessors.indexOf(node) >= 0) {\n                throw new Error(\"Cyclic dependency: \" + JSON.stringify(node)); // todo: better error\n            }\n\n            if (!~nodes.indexOf(node)) {\n                throw new Error(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" + JSON.stringify(node));\n            }\n\n            if (visited[i]) return;\n            visited[i] = true;\n\n            // outgoing edges\n            let outgoing = edges.filter(function(edge) {\n                return edge[0] === node;\n            });\n            if (i = outgoing.length) {\n                let preds = predecessors.concat(node);\n                do {\n                    let child = outgoing[--i][1];\n                    visit(child, nodes.indexOf(child), preds);\n                } while (i);\n            }\n\n            sorted[--cursor] = node;\n        }\n\n        return sorted;\n    }\n\n}"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}