{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\";\nimport { TreeRepository } from \"../repository/TreeRepository\";\nimport { Repository } from \"../repository/Repository\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport { CustomRepositoryNotFoundError } from \"../error/CustomRepositoryNotFoundError\";\nimport { EntitySchema, getMetadataArgsStorage } from \"../index\";\nimport { AbstractRepository } from \"../repository/AbstractRepository\";\nimport { CustomRepositoryCannotInheritRepositoryError } from \"../error/CustomRepositoryCannotInheritRepositoryError\";\nimport { MongoDriver } from \"../driver/mongodb/MongoDriver\";\nimport { RepositoryNotFoundError } from \"../error/RepositoryNotFoundError\";\nimport { RepositoryNotTreeError } from \"../error/RepositoryNotTreeError\";\nimport { RepositoryFactory } from \"../repository/RepositoryFactory\";\nimport { TreeRepositoryNotSupportedError } from \"../error/TreeRepositoryNotSupportedError\";\nimport { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\n\nvar EntityManager =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function EntityManager(connection, queryRunner) {\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Once created and then reused by en repositories.\n     */\n    this.repositories = [];\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n\n    this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n    this.connection = connection;\n\n    if (queryRunner) {\n      this.queryRunner = queryRunner; // dynamic: this.queryRunner = manager;\n\n      ObjectUtils.assign(this.queryRunner, {\n        manager: this\n      });\n    }\n  }\n  /**\n   * Wraps given function execution (and all operations made there) in a transaction.\n   * All database operations must be executed using provided entity manager.\n   */\n\n\n  EntityManager.prototype.transaction = function (isolationOrRunInTransaction, runInTransactionParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isolation, runInTransaction, queryRunner, result, err_1, rollbackError_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isolation = typeof isolationOrRunInTransaction === \"string\" ? isolationOrRunInTransaction : undefined;\n            runInTransaction = typeof isolationOrRunInTransaction === \"function\" ? isolationOrRunInTransaction : runInTransactionParam;\n\n            if (!runInTransaction) {\n              throw new Error(\"Transaction method requires callback in second paramter if isolation level is supplied.\");\n            }\n\n            if (this.connection.driver instanceof MongoDriver) throw new Error(\"Transactions aren't supported by MongoDB.\");\n            if (this.queryRunner && this.queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();\n            if (this.queryRunner && this.queryRunner.isTransactionActive) throw new Error(\"Cannot start transaction because its already started\");\n            queryRunner = this.queryRunner || this.connection.createQueryRunner();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 8, 13, 16]);\n\n            if (!isolation) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction(isolation)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 4:\n            _a.sent();\n\n            _a.label = 5;\n\n          case 5:\n            return [4\n            /*yield*/\n            , runInTransaction(queryRunner.manager)];\n\n          case 6:\n            result = _a.sent();\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 7:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , result];\n\n          case 8:\n            err_1 = _a.sent();\n            _a.label = 9;\n\n          case 9:\n            _a.trys.push([9, 11,, 12]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 10:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            rollbackError_1 = _a.sent();\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            throw err_1;\n\n          case 13:\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 15];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 14:\n            _a.sent();\n\n            _a.label = 15;\n\n          case 15:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes raw SQL query and returns raw database results.\n   */\n\n\n  EntityManager.prototype.query = function (query, parameters) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.connection.query(query, parameters, this.queryRunner)];\n      });\n    });\n  };\n  /**\n   * Creates a new query builder that can be used to build a sql query.\n   */\n\n\n  EntityManager.prototype.createQueryBuilder = function (entityClass, alias, queryRunner) {\n    if (alias) {\n      return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);\n    } else {\n      return this.connection.createQueryBuilder(entityClass || queryRunner || this.queryRunner);\n    }\n  };\n  /**\n   * Checks if entity has an id by its Function type or schema name.\n   */\n\n\n  EntityManager.prototype.hasId = function (targetOrEntity, maybeEntity) {\n    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n    var metadata = this.connection.getMetadata(target);\n    return metadata.hasId(entity);\n  };\n  /**\n   * Gets entity mixed id.\n   */\n\n\n  EntityManager.prototype.getId = function (targetOrEntity, maybeEntity) {\n    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n    var metadata = this.connection.getMetadata(target);\n    return metadata.getEntityIdMixedMap(entity);\n  };\n  /**\n   * Creates a new entity instance or instances.\n   * Can copy properties from the given object into new entities.\n   */\n\n\n  EntityManager.prototype.create = function (entityClass, plainObjectOrObjects) {\n    var _this = this;\n\n    var metadata = this.connection.getMetadata(entityClass);\n    if (!plainObjectOrObjects) return metadata.create(this.queryRunner);\n    if (Array.isArray(plainObjectOrObjects)) return plainObjectOrObjects.map(function (plainEntityLike) {\n      return _this.create(entityClass, plainEntityLike);\n    });\n    var mergeIntoEntity = metadata.create(this.queryRunner);\n    this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n    return mergeIntoEntity;\n  };\n  /**\n   * Merges two entities into one new entity.\n   */\n\n\n  EntityManager.prototype.merge = function (entityClass, mergeIntoEntity) {\n    var _this = this;\n\n    var entityLikes = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      entityLikes[_i - 2] = arguments[_i];\n    }\n\n    var metadata = this.connection.getMetadata(entityClass);\n    entityLikes.forEach(function (object) {\n      return _this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata);\n    });\n    return mergeIntoEntity;\n  };\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   */\n\n\n  EntityManager.prototype.preload = function (entityClass, entityLike) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, plainObjectToDatabaseEntityTransformer, transformedEntity;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.connection.getMetadata(entityClass);\n            plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);\n            return [4\n            /*yield*/\n            , plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata)];\n\n          case 1:\n            transformedEntity = _a.sent();\n            if (transformedEntity) return [2\n            /*return*/\n            , this.merge(entityClass, transformedEntity, entityLike)];\n            return [2\n            /*return*/\n            , undefined];\n        }\n      });\n    });\n  };\n  /**\n   * Saves a given entity in the database.\n   */\n\n\n  EntityManager.prototype.save = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    var target = arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    var entity = target ? maybeEntityOrOptions : targetOrEntity;\n    var options = target ? maybeOptions : maybeEntityOrOptions;\n    if (target instanceof EntitySchema) target = target.options.name; // if user passed empty array of entities then we don't need to do anything\n\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity); // execute save operation\n\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options).execute().then(function () {\n      return entity;\n    });\n  };\n  /**\n   * Removes a given entity from the database.\n   */\n\n\n  EntityManager.prototype.remove = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    var target = arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    var entity = target ? maybeEntityOrOptions : targetOrEntity;\n    var options = target ? maybeOptions : maybeEntityOrOptions; // if user passed empty array of entities then we don't need to do anything\n\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity); // execute save operation\n\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options).execute().then(function () {\n      return entity;\n    });\n  };\n  /**\n   * Records the delete date of one or many given entities.\n   */\n\n\n  EntityManager.prototype.softRemove = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    var target = arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    var entity = target ? maybeEntityOrOptions : targetOrEntity;\n    var options = target ? maybeOptions : maybeEntityOrOptions;\n    if (target instanceof EntitySchema) target = target.options.name; // if user passed empty array of entities then we don't need to do anything\n\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity); // execute soft-remove operation\n\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options).execute().then(function () {\n      return entity;\n    });\n  };\n  /**\n   * Recovers one or many given entities.\n   */\n\n\n  EntityManager.prototype.recover = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    var target = arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    var entity = target ? maybeEntityOrOptions : targetOrEntity;\n    var options = target ? maybeOptions : maybeEntityOrOptions;\n    if (target instanceof EntitySchema) target = target.options.name; // if user passed empty array of entities then we don't need to do anything\n\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity); // execute recover operation\n\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options).execute().then(function () {\n      return entity;\n    });\n  };\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   * You can execute bulk inserts using this method.\n   */\n\n\n  EntityManager.prototype.insert = function (target, entity) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.createQueryBuilder().insert().into(target).values(entity).execute()];\n      });\n    });\n  };\n  /**\n   * Updates entity partially. Entity can be found by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n\n\n  EntityManager.prototype.update = function (target, criteria, partialEntity) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new Error(\"Empty criteria(s) are not allowed for the update method.\"));\n    }\n\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().update(target).set(partialEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().update(target).set(partialEntity).where(criteria).execute();\n    }\n  };\n  /**\n   * Deletes entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n\n\n  EntityManager.prototype.delete = function (targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new Error(\"Empty criteria(s) are not allowed for the delete method.\"));\n    }\n\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().delete().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().delete().from(targetOrEntity).where(criteria).execute();\n    }\n  };\n  /**\n   * Records the delete date of entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n\n\n  EntityManager.prototype.softDelete = function (targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new Error(\"Empty criteria(s) are not allowed for the delete method.\"));\n    }\n\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().softDelete().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().softDelete().from(targetOrEntity).where(criteria).execute();\n    }\n  };\n  /**\n   * Restores entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n\n\n  EntityManager.prototype.restore = function (targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new Error(\"Empty criteria(s) are not allowed for the delete method.\"));\n    }\n\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().restore().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().restore().from(targetOrEntity).where(criteria).execute();\n    }\n  };\n  /**\n   * Counts entities that match given find options or conditions.\n   * Useful for pagination.\n   */\n\n\n  EntityManager.prototype.count = function (entityClass, optionsOrConditions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, qb;\n      return __generator(this, function (_a) {\n        metadata = this.connection.getMetadata(entityClass);\n        qb = this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        return [2\n        /*return*/\n        , FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getCount()];\n      });\n    });\n  };\n  /**\n   * Finds entities that match given find options or conditions.\n   */\n\n\n  EntityManager.prototype.find = function (entityClass, optionsOrConditions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, qb;\n      return __generator(this, function (_a) {\n        metadata = this.connection.getMetadata(entityClass);\n        qb = this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false) FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n        return [2\n        /*return*/\n        , FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getMany()];\n      });\n    });\n  };\n  /**\n   * Finds entities that match given find options and conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n\n\n  EntityManager.prototype.findAndCount = function (entityClass, optionsOrConditions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, qb;\n      return __generator(this, function (_a) {\n        metadata = this.connection.getMetadata(entityClass);\n        qb = this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false) FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n        return [2\n        /*return*/\n        , FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getManyAndCount()];\n      });\n    });\n  };\n  /**\n   * Finds entities with ids.\n   * Optionally find options or conditions can be applied.\n   */\n\n\n  EntityManager.prototype.findByIds = function (entityClass, ids, optionsOrConditions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, qb;\n      return __generator(this, function (_a) {\n        // if no ids passed, no need to execute a query - just return an empty array of values\n        if (!ids.length) return [2\n        /*return*/\n        , Promise.resolve([])];\n        metadata = this.connection.getMetadata(entityClass);\n        qb = this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false) FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n        return [2\n        /*return*/\n        , qb.andWhereInIds(ids).getMany()];\n      });\n    });\n  };\n  /**\n   * Finds first entity that matches given conditions.\n   */\n\n\n  EntityManager.prototype.findOne = function (entityClass, idOrOptionsOrConditions, maybeOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var findOptions, options, metadata, alias, qb, passedId;\n      return __generator(this, function (_a) {\n        findOptions = undefined;\n\n        if (FindOptionsUtils.isFindOneOptions(idOrOptionsOrConditions)) {\n          findOptions = idOrOptionsOrConditions;\n        } else if (maybeOptions && FindOptionsUtils.isFindOneOptions(maybeOptions)) {\n          findOptions = maybeOptions;\n        }\n\n        options = undefined;\n        if (idOrOptionsOrConditions instanceof Object && !FindOptionsUtils.isFindOneOptions(idOrOptionsOrConditions)) options = idOrOptionsOrConditions;\n        metadata = this.connection.getMetadata(entityClass);\n        alias = metadata.name;\n\n        if (findOptions && findOptions.join) {\n          alias = findOptions.join.alias;\n        } else if (maybeOptions && FindOptionsUtils.isFindOneOptions(maybeOptions) && maybeOptions.join) {\n          alias = maybeOptions.join.alias;\n        }\n\n        qb = this.createQueryBuilder(entityClass, alias);\n        if (!findOptions || findOptions.loadEagerRelations !== false) FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n        passedId = typeof idOrOptionsOrConditions === \"string\" || typeof idOrOptionsOrConditions === \"number\" || idOrOptionsOrConditions instanceof Date;\n\n        if (!passedId) {\n          findOptions = __assign(__assign({}, findOptions || {}), {\n            take: 1\n          });\n        }\n\n        FindOptionsUtils.applyOptionsToQueryBuilder(qb, findOptions);\n\n        if (options) {\n          qb.where(options);\n        } else if (passedId) {\n          qb.andWhereInIds(metadata.ensureEntityIdMap(idOrOptionsOrConditions));\n        }\n\n        return [2\n        /*return*/\n        , qb.getOne()];\n      });\n    });\n  };\n  /**\n   * Finds first entity that matches given conditions or rejects the returned promise on error.\n   */\n\n\n  EntityManager.prototype.findOneOrFail = function (entityClass, idOrOptionsOrConditions, maybeOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.findOne(entityClass, idOrOptionsOrConditions, maybeOptions).then(function (value) {\n          if (value === undefined) {\n            return Promise.reject(new EntityNotFoundError(entityClass, idOrOptionsOrConditions));\n          }\n\n          return Promise.resolve(value);\n        })];\n      });\n    });\n  };\n  /**\n   * Clears all the data from the given table (truncates/drops it).\n   *\n   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n   * @see https://stackoverflow.com/a/5972738/925151\n   */\n\n\n  EntityManager.prototype.clear = function (entityClass) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, queryRunner;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.connection.getMetadata(entityClass);\n            queryRunner = this.queryRunner || this.connection.createQueryRunner();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 3, 6]);\n\n            return [4\n            /*yield*/\n            , queryRunner.clearTable(metadata.tablePath)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n          // await is needed here because we are using finally\n\n          case 3:\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 4:\n            _a.sent();\n\n            _a.label = 5;\n\n          case 5:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Increments some column by provided value of the entities matched given conditions.\n   */\n\n\n  EntityManager.prototype.increment = function (entityClass, conditions, propertyPath, value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, column, values;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        metadata = this.connection.getMetadata(entityClass);\n        column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column) throw new Error(\"Column \" + propertyPath + \" was not found in \" + metadata.targetName + \" entity.\");\n        if (isNaN(Number(value))) throw new Error(\"Value \\\"\" + value + \"\\\" is not a number.\");\n        values = propertyPath.split(\".\").reduceRight(function (value, key) {\n          var _a;\n\n          return _a = {}, _a[key] = value, _a;\n        }, function () {\n          return _this.connection.driver.escape(column.databaseName) + \" + \" + value;\n        });\n        return [2\n        /*return*/\n        , this.createQueryBuilder(entityClass, \"entity\").update(entityClass).set(values).where(conditions).execute()];\n      });\n    });\n  };\n  /**\n   * Decrements some column by provided value of the entities matched given conditions.\n   */\n\n\n  EntityManager.prototype.decrement = function (entityClass, conditions, propertyPath, value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, column, values;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        metadata = this.connection.getMetadata(entityClass);\n        column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column) throw new Error(\"Column \" + propertyPath + \" was not found in \" + metadata.targetName + \" entity.\");\n        if (isNaN(Number(value))) throw new Error(\"Value \\\"\" + value + \"\\\" is not a number.\");\n        values = propertyPath.split(\".\").reduceRight(function (value, key) {\n          var _a;\n\n          return _a = {}, _a[key] = value, _a;\n        }, function () {\n          return _this.connection.driver.escape(column.databaseName) + \" - \" + value;\n        });\n        return [2\n        /*return*/\n        , this.createQueryBuilder(entityClass, \"entity\").update(entityClass).set(values).where(conditions).execute()];\n      });\n    });\n  };\n  /**\n   * Gets repository for the given entity class or name.\n   * If single database connection mode is used, then repository is obtained from the\n   * repository aggregator, where each repository is individually created for this entity manager.\n   * When single database connection is not used, repository is being obtained from the connection.\n   */\n\n\n  EntityManager.prototype.getRepository = function (target) {\n    // throw exception if there is no repository with this target registered\n    if (!this.connection.hasMetadata(target)) throw new RepositoryNotFoundError(this.connection.name, target); // find already created repository instance and return it if found\n\n    var metadata = this.connection.getMetadata(target);\n    var repository = this.repositories.find(function (repository) {\n      return repository.metadata === metadata;\n    });\n    if (repository) return repository; // if repository was not found then create it, store its instance and return it\n\n    var newRepository = new RepositoryFactory().create(this, metadata, this.queryRunner);\n    this.repositories.push(newRepository);\n    return newRepository;\n  };\n  /**\n   * Gets tree repository for the given entity class or name.\n   * If single database connection mode is used, then repository is obtained from the\n   * repository aggregator, where each repository is individually created for this entity manager.\n   * When single database connection is not used, repository is being obtained from the connection.\n   */\n\n\n  EntityManager.prototype.getTreeRepository = function (target) {\n    // tree tables aren't supported by some drivers (mongodb)\n    if (this.connection.driver.treeSupport === false) throw new TreeRepositoryNotSupportedError(this.connection.driver); // check if repository is real tree repository\n\n    var repository = this.getRepository(target);\n    if (!(repository instanceof TreeRepository)) throw new RepositoryNotTreeError(target);\n    return repository;\n  };\n  /**\n   * Gets mongodb repository for the given entity class.\n   */\n\n\n  EntityManager.prototype.getMongoRepository = function (target) {\n    return this.connection.getMongoRepository(target);\n  };\n  /**\n   * Gets custom entity repository marked with @EntityRepository decorator.\n   */\n\n\n  EntityManager.prototype.getCustomRepository = function (customRepository) {\n    var entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(function (repository) {\n      return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);\n    });\n    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);\n    var entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;\n    var entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata); // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n    // however we need these properties for internal work of the class\n\n    if (entityRepositoryInstance instanceof AbstractRepository) {\n      if (!entityRepositoryInstance[\"manager\"]) entityRepositoryInstance[\"manager\"] = this;\n    }\n\n    if (entityRepositoryInstance instanceof Repository) {\n      if (!entityMetadata) throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n      entityRepositoryInstance[\"manager\"] = this;\n      entityRepositoryInstance[\"metadata\"] = entityMetadata;\n    }\n\n    return entityRepositoryInstance;\n  };\n  /**\n   * Releases all resources used by entity manager.\n   * This is used when entity manager is created with a single query runner,\n   * and this single query runner needs to be released after job with entity manager is done.\n   */\n\n\n  EntityManager.prototype.release = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this.queryRunner) throw new NoNeedToReleaseEntityManagerError();\n        return [2\n        /*return*/\n        , this.queryRunner.release()];\n      });\n    });\n  };\n\n  return EntityManager;\n}();\n\nexport { EntityManager };","map":{"version":3,"sources":["../browser/src/entity-manager/EntityManager.ts"],"names":[],"mappings":"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","sourcesContent":["import {Connection} from \"../connection/Connection\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {EntityNotFoundError} from \"../error/EntityNotFoundError\";\nimport {QueryRunnerProviderAlreadyReleasedError} from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport {FindOneOptions} from \"../find-options/FindOneOptions\";\nimport {DeepPartial} from \"../common/DeepPartial\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {NoNeedToReleaseEntityManagerError} from \"../error/NoNeedToReleaseEntityManagerError\";\nimport {MongoRepository} from \"../repository/MongoRepository\";\nimport {TreeRepository} from \"../repository/TreeRepository\";\nimport {Repository} from \"../repository/Repository\";\nimport {FindOptionsUtils} from \"../find-options/FindOptionsUtils\";\nimport {PlainObjectToNewEntityTransformer} from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport {PlainObjectToDatabaseEntityTransformer} from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport {CustomRepositoryNotFoundError} from \"../error/CustomRepositoryNotFoundError\";\nimport {EntitySchema, getMetadataArgsStorage, ObjectLiteral} from \"../index\";\nimport {AbstractRepository} from \"../repository/AbstractRepository\";\nimport {CustomRepositoryCannotInheritRepositoryError} from \"../error/CustomRepositoryCannotInheritRepositoryError\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {RepositoryNotFoundError} from \"../error/RepositoryNotFoundError\";\nimport {RepositoryNotTreeError} from \"../error/RepositoryNotTreeError\";\nimport {RepositoryFactory} from \"../repository/RepositoryFactory\";\nimport {TreeRepositoryNotSupportedError} from \"../error/TreeRepositoryNotSupportedError\";\nimport {QueryDeepPartialEntity} from \"../query-builder/QueryPartialEntity\";\nimport {EntityPersistExecutor} from \"../persistence/EntityPersistExecutor\";\nimport {ObjectID} from \"../driver/mongodb/typings\";\nimport {InsertResult} from \"../query-builder/result/InsertResult\";\nimport {UpdateResult} from \"../query-builder/result/UpdateResult\";\nimport {DeleteResult} from \"../query-builder/result/DeleteResult\";\nimport {FindConditions} from \"../find-options/FindConditions\";\nimport {IsolationLevel} from \"../driver/types/IsolationLevel\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\n\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport class EntityManager {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by this entity manager.\n     */\n    readonly connection: Connection;\n\n    /**\n     * Custom query runner to be used for operations in this entity manager.\n     * Used only in non-global entity manager.\n     */\n    readonly queryRunner?: QueryRunner;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Once created and then reused by en repositories.\n     */\n    protected repositories: Repository<any>[] = [];\n\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n    protected plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: Connection, queryRunner?: QueryRunner) {\n        this.connection = connection;\n        if (queryRunner) {\n            this.queryRunner = queryRunner;\n            // dynamic: this.queryRunner = manager;\n            ObjectUtils.assign(this.queryRunner, { manager: this });\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(runInTransaction: (entityManager: EntityManager) => Promise<T>): Promise<T>;\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(isolationLevel: IsolationLevel, runInTransaction: (entityManager: EntityManager) => Promise<T>): Promise<T>;\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        isolationOrRunInTransaction: IsolationLevel | ((entityManager: EntityManager) => Promise<T>),\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>\n    ): Promise<T> {\n\n        const isolation = typeof isolationOrRunInTransaction === \"string\" ? isolationOrRunInTransaction : undefined;\n        const runInTransaction = typeof isolationOrRunInTransaction === \"function\" ? isolationOrRunInTransaction : runInTransactionParam;\n\n        if (!runInTransaction) {\n            throw new Error(`Transaction method requires callback in second paramter if isolation level is supplied.`);\n        }\n\n        if (this.connection.driver instanceof MongoDriver)\n            throw new Error(`Transactions aren't supported by MongoDB.`);\n\n        if (this.queryRunner && this.queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError();\n\n        if (this.queryRunner && this.queryRunner.isTransactionActive)\n            throw new Error(`Cannot start transaction because its already started`);\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n        try {\n            if (isolation) {\n                await queryRunner.startTransaction(isolation);\n              } else {\n                await queryRunner.startTransaction();\n              }\n            const result = await runInTransaction(queryRunner.manager);\n            await queryRunner.commitTransaction();\n            return result;\n\n        } catch (err) {\n            try { // we throw original error even if rollback thrown an error\n                await queryRunner.rollbackTransaction();\n            } catch (rollbackError) { }\n            throw err;\n\n        } finally {\n            if (!this.queryRunner) // if we used a new query runner provider then release it\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query(query: string, parameters?: any[]): Promise<any> {\n        return this.connection.query(query, parameters, this.queryRunner);\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    createQueryBuilder<Entity>(entityClass: EntityTarget<Entity>, alias: string, queryRunner?: QueryRunner): SelectQueryBuilder<Entity>;\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>;\n\n    /**\n     * Creates a new query builder that can be used to build a sql query.\n     */\n    createQueryBuilder<Entity>(entityClass?: EntityTarget<Entity>|QueryRunner, alias?: string, queryRunner?: QueryRunner): SelectQueryBuilder<Entity> {\n        if (alias) {\n            return this.connection.createQueryBuilder(entityClass as EntityTarget<Entity>, alias, queryRunner || this.queryRunner);\n\n        } else {\n            return this.connection.createQueryBuilder(entityClass as QueryRunner|undefined || queryRunner || this.queryRunner);\n        }\n    }\n\n    /**\n     * Checks if entity has an id.\n     */\n    hasId(entity: any): boolean;\n\n    /**\n     * Checks if entity of given schema name has an id.\n     */\n    hasId(target: Function|string, entity: any): boolean;\n\n    /**\n     * Checks if entity has an id by its Function type or schema name.\n     */\n    hasId(targetOrEntity: any|Function|string, maybeEntity?: any): boolean {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n        const metadata = this.connection.getMetadata(target);\n        return metadata.hasId(entity);\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(entity: any): any;\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(target: EntityTarget<any>, entity: any): any;\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(targetOrEntity: any|EntityTarget<any>, maybeEntity?: any): any {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n        const metadata = this.connection.getMetadata(target);\n        return metadata.getEntityIdMixedMap(entity);\n    }\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity>(entityClass: EntityTarget<Entity>, plainObject?: DeepPartial<Entity>): Entity;\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity>(entityClass: EntityTarget<Entity>, plainObjects?: DeepPartial<Entity>[]): Entity[];\n\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create<Entity>(entityClass: EntityTarget<Entity>, plainObjectOrObjects?: DeepPartial<Entity>|DeepPartial<Entity>[]): Entity|Entity[] {\n        const metadata = this.connection.getMetadata(entityClass);\n\n        if (!plainObjectOrObjects)\n            return metadata.create(this.queryRunner);\n\n        if (Array.isArray(plainObjectOrObjects))\n            return plainObjectOrObjects.map(plainEntityLike => this.create(entityClass as any, plainEntityLike));\n\n        const mergeIntoEntity = metadata.create(this.queryRunner);\n        this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n        return mergeIntoEntity;\n    }\n\n    /**\n     * Merges two entities into one new entity.\n     */\n    merge<Entity>(entityClass: EntityTarget<Entity>, mergeIntoEntity: Entity, ...entityLikes: DeepPartial<Entity>[]): Entity { // todo: throw exception if entity manager is released\n        const metadata = this.connection.getMetadata(entityClass);\n        entityLikes.forEach(object => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));\n        return mergeIntoEntity;\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     */\n    async preload<Entity>(entityClass: EntityTarget<Entity>, entityLike: DeepPartial<Entity>): Promise<Entity|undefined> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);\n        const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);\n        if (transformedEntity)\n            return this.merge(entityClass as any, transformedEntity as Entity, entityLike);\n\n        return undefined;\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options: SaveOptions & { reload: false }): Promise<T[]>;\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<(T & Entity)[]>;\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options: SaveOptions & { reload: false }): Promise<T>;\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T & Entity>;\n\n    /**\n     * Saves a given entity in the database.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T|T[])|EntityTarget<Entity>, maybeEntityOrOptions?: T|T[], maybeOptions?: SaveOptions): Promise<T|T[]> {\n\n        // normalize mixed parameters\n        let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: T|T[] = target ? maybeEntityOrOptions as T|T[] : targetOrEntity as T|T[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        if (target instanceof EntitySchema)\n            target = target.options.name;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute save operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(entity: Entity, options?: RemoveOptions): Promise<Entity>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(targetOrEntity: EntityTarget<Entity>, entity: Entity, options?: RemoveOptions): Promise<Entity>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(entity: Entity[], options?: RemoveOptions): Promise<Entity>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(targetOrEntity: EntityTarget<Entity>, entity: Entity[], options?: RemoveOptions): Promise<Entity[]>;\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(targetOrEntity: (Entity|Entity[])|EntityTarget<Entity>, maybeEntityOrOptions?: Entity|Entity[], maybeOptions?: RemoveOptions): Promise<Entity|Entity[]> {\n\n        // normalize mixed parameters\n        const target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: Entity|Entity[] = target ? maybeEntityOrOptions as Entity|Entity[] : targetOrEntity as Entity|Entity[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute save operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T|T[])|EntityTarget<Entity>, maybeEntityOrOptions?: T|T[], maybeOptions?: SaveOptions): Promise<T|T[]> {\n\n        // normalize mixed parameters\n        let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: T|T[] = target ? maybeEntityOrOptions as T|T[] : targetOrEntity as T|T[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        if (target instanceof EntitySchema)\n            target = target.options.name;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute soft-remove operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Recovers all given entities.\n     */\n    recover<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>;\n\n    /**\n     * Recovers a given entity.\n     */\n    recover<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>;\n\n    /**\n     * Recovers all given entities.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entities: T[], options?: SaveOptions): Promise<T[]>;\n\n    /**\n     * Recovers a given entity.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: EntityTarget<Entity>, entity: T, options?: SaveOptions): Promise<T>;\n\n    /**\n     * Recovers one or many given entities.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T|T[])|EntityTarget<Entity>, maybeEntityOrOptions?: T|T[], maybeOptions?: SaveOptions): Promise<T|T[]> {\n\n        // normalize mixed parameters\n        let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function|string : undefined;\n        const entity: T|T[] = target ? maybeEntityOrOptions as T|T[] : targetOrEntity as T|T[];\n        const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n        if (target instanceof EntitySchema)\n            target = target.options.name;\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n\n        // execute recover operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     * You can execute bulk inserts using this method.\n     */\n    async insert<Entity>(target: EntityTarget<Entity>, entity: QueryDeepPartialEntity<Entity>|(QueryDeepPartialEntity<Entity>[])): Promise<InsertResult> {\n        return this.createQueryBuilder()\n            .insert()\n            .into(target)\n            .values(entity)\n            .execute();\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    update<Entity>(target: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any, partialEntity: QueryDeepPartialEntity<Entity>): Promise<UpdateResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the update method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Deletes entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    delete<Entity>(targetOrEntity: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any): Promise<DeleteResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Records the delete date of entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    softDelete<Entity>(targetOrEntity: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any): Promise<UpdateResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Restores entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    restore<Entity>(targetOrEntity: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|any): Promise<UpdateResult> {\n\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n\n            return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n\n        } else {\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<number>;\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<number>;\n\n    /**\n     * Counts entities that match given conditions.\n     * Useful for pagination.\n     */\n    count<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<number>;\n\n    /**\n     * Counts entities that match given find options or conditions.\n     * Useful for pagination.\n     */\n    async count<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindConditions<Entity>|FindOneOptions<Entity>|FindManyOptions<Entity>): Promise<number> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        return FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getCount();\n    }\n\n    /**\n     * Finds entities that match given options.\n     */\n    find<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities that match given conditions.\n     */\n    find<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     */\n    async find<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindManyOptions<Entity>|FindConditions<Entity>): Promise<Entity[]> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n\n        return FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getMany();\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount<Entity>(entityClass: EntityTarget<Entity>, options?: FindManyOptions<Entity>): Promise<[Entity[], number]>;\n\n    /**\n     * Finds entities that match given conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>): Promise<[Entity[], number]>;\n\n    /**\n     * Finds entities that match given find options and conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    async findAndCount<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindConditions<Entity>|FindManyOptions<Entity>): Promise<[Entity[], number]> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n\n        return FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getManyAndCount();\n    }\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options can be applied.\n     */\n    findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], options?: FindManyOptions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities with ids.\n     * Optionally conditions can be applied.\n     */\n    findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], conditions?: FindConditions<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options or conditions can be applied.\n     */\n    async findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], optionsOrConditions?: FindConditions<Entity>|FindManyOptions<Entity>): Promise<Entity[]> {\n\n        // if no ids passed, no need to execute a query - just return an empty array of values\n        if (!ids.length)\n            return Promise.resolve([]);\n        const metadata = this.connection.getMetadata(entityClass);\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);\n        FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);\n\n        if (!FindOptionsUtils.isFindManyOptions(optionsOrConditions) || optionsOrConditions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, metadata);\n\n        return qb.andWhereInIds(ids).getMany();\n    }\n\n    /**\n     * Finds first entity that matches given find options.\n     */\n    findOne<Entity>(entityClass: EntityTarget<Entity>, id?: string|number|Date|ObjectID, options?: FindOneOptions<Entity>): Promise<Entity|undefined>;\n\n    /**\n     * Finds first entity that matches given find options.\n     */\n    findOne<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<Entity|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    findOne<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>, options?: FindOneOptions<Entity>): Promise<Entity|undefined>;\n\n    /**\n     * Finds first entity that matches given conditions.\n     */\n    async findOne<Entity>(entityClass: EntityTarget<Entity>, idOrOptionsOrConditions?: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOneOptions<Entity>|FindConditions<Entity>, maybeOptions?: FindOneOptions<Entity>): Promise<Entity|undefined> {\n\n        let findOptions: FindManyOptions<any>|FindOneOptions<any>|undefined = undefined;\n        if (FindOptionsUtils.isFindOneOptions(idOrOptionsOrConditions)) {\n            findOptions = idOrOptionsOrConditions;\n        } else if (maybeOptions && FindOptionsUtils.isFindOneOptions(maybeOptions)) {\n            findOptions = maybeOptions;\n        }\n\n        let options: ObjectLiteral|undefined = undefined;\n        if (idOrOptionsOrConditions instanceof Object && !FindOptionsUtils.isFindOneOptions(idOrOptionsOrConditions))\n            options = idOrOptionsOrConditions as ObjectLiteral;\n\n        const metadata = this.connection.getMetadata(entityClass);\n        let alias: string = metadata.name;\n        if (findOptions && findOptions.join) {\n            alias = findOptions.join.alias;\n\n        } else if (maybeOptions && FindOptionsUtils.isFindOneOptions(maybeOptions) && maybeOptions.join) {\n            alias = maybeOptions.join.alias;\n        }\n        const qb = this.createQueryBuilder<Entity>(entityClass as any, alias);\n\n        if (!findOptions || findOptions.loadEagerRelations !== false)\n            FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias!.metadata);\n\n        const passedId = typeof idOrOptionsOrConditions === \"string\" || typeof idOrOptionsOrConditions === \"number\" || (idOrOptionsOrConditions as any) instanceof Date;\n\n        if (!passedId) {\n            findOptions = {\n                ...(findOptions || {}),\n                take: 1,\n            };\n        }\n\n        FindOptionsUtils.applyOptionsToQueryBuilder(qb, findOptions);\n\n        if (options) {\n            qb.where(options);\n\n        } else if (passedId) {\n            qb.andWhereInIds(metadata.ensureEntityIdMap(idOrOptionsOrConditions));\n        }\n\n        return qb.getOne();\n    }\n\n    /**\n     * Finds first entity that matches given find options or rejects the returned promise on error.\n     */\n    findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, id?: string|number|Date|ObjectID, options?: FindOneOptions<Entity>): Promise<Entity>;\n\n    /**\n     * Finds first entity that matches given find options or rejects the returned promise on error.\n     */\n    findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, options?: FindOneOptions<Entity>): Promise<Entity>;\n\n    /**\n     * Finds first entity that matches given conditions or rejects the returned promise on error.\n     */\n    findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindConditions<Entity>, options?: FindOneOptions<Entity>): Promise<Entity>;\n\n    /**\n     * Finds first entity that matches given conditions or rejects the returned promise on error.\n     */\n    async findOneOrFail<Entity>(entityClass: EntityTarget<Entity>, idOrOptionsOrConditions?: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOneOptions<Entity>|FindConditions<Entity>, maybeOptions?: FindOneOptions<Entity>): Promise<Entity> {\n        return this.findOne<Entity>(entityClass as any, idOrOptionsOrConditions as any, maybeOptions).then((value) => {\n            if (value === undefined) {\n                return Promise.reject(new EntityNotFoundError(entityClass, idOrOptionsOrConditions));\n            }\n            return Promise.resolve(value);\n        });\n    }\n\n    /**\n     * Clears all the data from the given table (truncates/drops it).\n     *\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n     * @see https://stackoverflow.com/a/5972738/925151\n     */\n    async clear<Entity>(entityClass: EntityTarget<Entity>): Promise<void> {\n        const metadata = this.connection.getMetadata(entityClass);\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        try {\n            return await queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally\n\n        } finally {\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Increments some column by provided value of the entities matched given conditions.\n     */\n    async increment<Entity>(entityClass: EntityTarget<Entity>,\n                            conditions: any,\n                            propertyPath: string,\n                            value: number | string): Promise<UpdateResult> {\n\n        const metadata = this.connection.getMetadata(entityClass);\n        const column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column)\n            throw new Error(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n\n        if (isNaN(Number(value)))\n            throw new Error(`Value \"${value}\" is not a number.`);\n\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\n            .split(\".\")\n            .reduceRight(\n                (value, key) => ({ [key]: value }) as any,\n                () => this.connection.driver.escape(column.databaseName) + \" + \" + value\n            );\n\n        return this\n            .createQueryBuilder<Entity>(entityClass as any, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute();\n    }\n\n    /**\n     * Decrements some column by provided value of the entities matched given conditions.\n     */\n    async decrement<Entity>(entityClass: EntityTarget<Entity>,\n                            conditions: any,\n                            propertyPath: string,\n                            value: number | string): Promise<UpdateResult> {\n\n        const metadata = this.connection.getMetadata(entityClass);\n        const column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column)\n            throw new Error(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n\n        if (isNaN(Number(value)))\n            throw new Error(`Value \"${value}\" is not a number.`);\n\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\n            .split(\".\")\n            .reduceRight(\n                (value, key) => ({ [key]: value }) as any,\n                () => this.connection.driver.escape(column.databaseName) + \" - \" + value\n            );\n\n        return this\n            .createQueryBuilder<Entity>(entityClass as any, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute();\n    }\n\n    /**\n     * Gets repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository<Entity>(target: EntityTarget<Entity>): Repository<Entity> {\n\n        // throw exception if there is no repository with this target registered\n        if (!this.connection.hasMetadata(target))\n            throw new RepositoryNotFoundError(this.connection.name, target);\n\n        // find already created repository instance and return it if found\n        const metadata = this.connection.getMetadata(target);\n        const repository = this.repositories.find(repository => repository.metadata === metadata);\n        if (repository)\n            return repository;\n\n        // if repository was not found then create it, store its instance and return it\n        const newRepository = new RepositoryFactory().create(this, metadata, this.queryRunner);\n        this.repositories.push(newRepository);\n        return newRepository;\n    }\n\n    /**\n     * Gets tree repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository<Entity>(target: EntityTarget<Entity>): TreeRepository<Entity> {\n\n        // tree tables aren't supported by some drivers (mongodb)\n        if (this.connection.driver.treeSupport === false)\n            throw new TreeRepositoryNotSupportedError(this.connection.driver);\n\n        // check if repository is real tree repository\n        const repository = this.getRepository(target);\n        if (!(repository instanceof TreeRepository))\n            throw new RepositoryNotTreeError(target);\n\n        return repository;\n    }\n\n    /**\n     * Gets mongodb repository for the given entity class.\n     */\n    getMongoRepository<Entity>(target: EntityTarget<Entity>): MongoRepository<Entity> {\n        return this.connection.getMongoRepository<Entity>(target);\n    }\n\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     */\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\n        const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n            return repository.target === (customRepository instanceof Function ? customRepository : (customRepository as any).constructor);\n        });\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository);\n\n        const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;\n        const entityRepositoryInstance = new (entityRepositoryMetadataArgs.target as any)(this, entityMetadata);\n\n        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n        // however we need these properties for internal work of the class\n        if (entityRepositoryInstance instanceof AbstractRepository) {\n            if (!(entityRepositoryInstance as any)[\"manager\"])\n                (entityRepositoryInstance as any)[\"manager\"] = this;\n        }\n        if (entityRepositoryInstance instanceof Repository) {\n            if (!entityMetadata)\n                throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n\n            (entityRepositoryInstance as any)[\"manager\"] = this;\n            (entityRepositoryInstance as any)[\"metadata\"] = entityMetadata;\n        }\n\n        return entityRepositoryInstance;\n    }\n\n    /**\n     * Releases all resources used by entity manager.\n     * This is used when entity manager is created with a single query runner,\n     * and this single query runner needs to be released after job with entity manager is done.\n     */\n    async release(): Promise<void> {\n        if (!this.queryRunner)\n            throw new NoNeedToReleaseEntityManagerError();\n\n        return this.queryRunner.release();\n    }\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}