{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { MongoDriver } from \"../driver/mongodb/MongoDriver\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\n/**\n * This metadata contains all information about entity's column.\n */\n\nvar ColumnMetadata =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function ColumnMetadata(options) {\n    /**\n     * Type's length in the database.\n     */\n    this.length = \"\";\n    /**\n     * Indicates if this column is a primary key.\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n\n    this.isGenerated = false;\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n\n    this.isNullable = false;\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n\n    this.isSelect = true;\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n\n    this.isInsert = true;\n    /**\n     * Indicates if column allows updates or not.\n     */\n\n    this.isUpdate = true;\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n\n    this.zerofill = false;\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n\n    this.unsigned = false;\n    /**\n     * Indicates if this column is an array.\n     */\n\n    this.isArray = false;\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n\n    this.isVirtual = false;\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n\n    this.isDiscriminator = false;\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n\n    this.isTreeLevel = false;\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n\n    this.isCreateDate = false;\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n\n    this.isUpdateDate = false;\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n\n    this.isDeleteDate = false;\n    /**\n     * Indicates if this column contains an entity version.\n     */\n\n    this.isVersion = false;\n    /**\n     * Indicates if this column contains an object id.\n     */\n\n    this.isObjectId = false;\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n\n    this.isNestedSetLeft = false;\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n\n    this.isNestedSetRight = false;\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n\n    this.isMaterializedPath = false;\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    this.referencedColumn = options.referencedColumn;\n    if (options.args.target) this.target = options.args.target;\n    if (options.args.propertyName) this.propertyName = options.args.propertyName;\n    if (options.args.options.name) this.givenDatabaseName = options.args.options.name;\n    if (options.args.options.type) this.type = options.args.options.type;\n    if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n    if (options.args.options.width) this.width = options.args.options.width;\n    if (options.args.options.charset) this.charset = options.args.options.charset;\n    if (options.args.options.collation) this.collation = options.args.options.collation;\n    if (options.args.options.primary) this.isPrimary = options.args.options.primary;\n    if (options.args.options.default === null) // to make sure default: null is the same as nullable: true\n      this.isNullable = true;\n    if (options.args.options.nullable !== undefined) this.isNullable = options.args.options.nullable;\n    if (options.args.options.select !== undefined) this.isSelect = options.args.options.select;\n    if (options.args.options.insert !== undefined) this.isInsert = options.args.options.insert;\n    if (options.args.options.update !== undefined) this.isUpdate = options.args.options.update;\n    if (options.args.options.readonly !== undefined) this.isUpdate = !options.args.options.readonly;\n    if (options.args.options.comment) this.comment = options.args.options.comment;\n    if (options.args.options.default !== undefined) this.default = options.args.options.default;\n    if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;\n    if (options.args.options.scale !== null && options.args.options.scale !== undefined) this.scale = options.args.options.scale;\n\n    if (options.args.options.zerofill) {\n      this.zerofill = options.args.options.zerofill;\n      this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n    }\n\n    if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;\n    if (options.args.options.precision !== null) this.precision = options.args.options.precision;\n\n    if (options.args.options.enum) {\n      if (options.args.options.enum instanceof Object && !Array.isArray(options.args.options.enum)) {\n        this.enum = Object.keys(options.args.options.enum) // remove numeric keys - typescript numeric enum types generate them\n        // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n        // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n        // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n        // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n        // generated SQL statements contains string representation of that function which leads into syntax error\n        // at database side.\n        .filter(function (key) {\n          return isNaN(+key) && typeof options.args.options.enum[key] !== \"function\";\n        }).map(function (key) {\n          return options.args.options.enum[key];\n        });\n      } else {\n        this.enum = options.args.options.enum;\n      }\n    }\n\n    if (options.args.options.enumName) {\n      this.enumName = options.args.options.enumName;\n    }\n\n    if (options.args.options.asExpression) {\n      this.asExpression = options.args.options.asExpression;\n      this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : \"VIRTUAL\";\n    }\n\n    if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;\n    if (options.args.options.array) this.isArray = options.args.options.array;\n\n    if (options.args.mode) {\n      this.isVirtual = options.args.mode === \"virtual\";\n      this.isTreeLevel = options.args.mode === \"treeLevel\";\n      this.isCreateDate = options.args.mode === \"createDate\";\n      this.isUpdateDate = options.args.mode === \"updateDate\";\n      this.isDeleteDate = options.args.mode === \"deleteDate\";\n      this.isVersion = options.args.mode === \"version\";\n      this.isObjectId = options.args.mode === \"objectId\";\n    }\n\n    if (options.args.options.transformer) this.transformer = options.args.options.transformer;\n    if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;\n    if (options.args.options.srid !== undefined) this.srid = options.args.options.srid;\n    if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;\n\n    if (this.isCreateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;\n      if (!this.default) this.default = function () {\n        return options.connection.driver.mappedDataTypes.createDateDefault;\n      }; // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n    }\n\n    if (this.isUpdateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;\n      if (!this.default) this.default = function () {\n        return options.connection.driver.mappedDataTypes.updateDateDefault;\n      };\n      if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault; // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n    }\n\n    if (this.isDeleteDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;\n      if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable; // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;\n    }\n\n    if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;\n    if (options.closureType) this.closureType = options.closureType;\n    if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;\n    if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;\n    if (options.materializedPath) this.isMaterializedPath = options.materializedPath;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n\n\n  ColumnMetadata.prototype.createValueMap = function (value, useDatabaseName) {\n    var _a;\n\n    var _this = this;\n\n    if (useDatabaseName === void 0) {\n      useDatabaseName = false;\n    } // extract column value from embeds of entity if column is in embedded\n\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var propertyNames = __spreadArray([], __read(this.embeddedMetadata.parentPropertyNames)); // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n\n\n      var extractEmbeddedColumnValue_1 = function (propertyNames, map) {\n        var propertyName = propertyNames.shift();\n\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue_1(propertyNames, map[propertyName]);\n          return map;\n        } // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n\n\n        if ((_this.generationStrategy === \"increment\" || _this.generationStrategy === \"rowid\") && _this.type === \"bigint\" && value !== null) value = String(value);\n        map[useDatabaseName ? _this.databaseName : _this.propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue_1(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n      if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n      return _a = {}, _a[useDatabaseName ? this.databaseName : this.propertyName] = value, _a;\n    }\n  };\n  /**\n   * Extracts column value and returns its column name with this value in a literal object.\n   * If column is in embedded (or recursive embedded) it returns complex literal object.\n   *\n   * Examples what this method can return depend if this column is in embeds.\n   * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n   */\n\n\n  ColumnMetadata.prototype.getEntityValueMap = function (entity, options) {\n    var _a, _b;\n\n    var _this = this;\n\n    var returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n    // extract column value from embeds of entity if column is in embedded\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var propertyNames = __spreadArray([], __read(this.embeddedMetadata.parentPropertyNames)); // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n\n\n      var extractEmbeddedColumnValue_2 = function (propertyNames, value, map) {\n        var propertyName = propertyNames.shift();\n        if (value === undefined) return map;\n\n        if (propertyName) {\n          var submap = {};\n          extractEmbeddedColumnValue_2(propertyNames, value[propertyName], submap);\n\n          if (Object.keys(submap).length > 0) {\n            map[propertyName] = submap;\n          }\n\n          return map;\n        }\n\n        if (value[_this.propertyName] !== undefined && (returnNulls === false || value[_this.propertyName] !== null)) map[_this.propertyName] = value[_this.propertyName];\n        return map;\n      };\n\n      var map = {};\n      extractEmbeddedColumnValue_2(propertyNames, entity, map);\n      return Object.keys(map).length > 0 ? map : undefined;\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      if (this.relationMetadata && entity[this.relationMetadata.propertyName] && entity[this.relationMetadata.propertyName] instanceof Object) {\n        var map = this.relationMetadata.joinColumns.reduce(function (map, joinColumn) {\n          var value = joinColumn.referencedColumn.getEntityValueMap(entity[_this.relationMetadata.propertyName]);\n          if (value === undefined) return map;\n          return OrmUtils.mergeDeep(map, value);\n        }, {});\n        if (Object.keys(map).length > 0) return _a = {}, _a[this.propertyName] = map, _a;\n        return undefined;\n      } else {\n        if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null)) return _b = {}, _b[this.propertyName] = entity[this.propertyName], _b;\n        return undefined;\n      }\n    }\n  };\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n\n\n  ColumnMetadata.prototype.getEntityValue = function (entity, transform) {\n    if (transform === void 0) {\n      transform = false;\n    }\n\n    if (entity === undefined || entity === null) return undefined; // extract column value from embeddeds of entity if column is in embedded\n\n    var value = undefined;\n\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var propertyNames = __spreadArray([], __read(this.embeddedMetadata.parentPropertyNames)); // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n\n\n      var extractEmbeddedColumnValue_3 = function (propertyNames, value) {\n        var propertyName = propertyNames.shift();\n        return propertyName && value ? extractEmbeddedColumnValue_3(propertyNames, value[propertyName]) : value;\n      }; // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n\n\n      var embeddedObject = extractEmbeddedColumnValue_3(propertyNames, entity);\n\n      if (embeddedObject) {\n        if (this.relationMetadata && this.referencedColumn) {\n          var relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n\n          if (relatedEntity && relatedEntity instanceof Object && !(relatedEntity instanceof FindOperator)) {\n            value = this.referencedColumn.getEntityValue(relatedEntity);\n          } else if (embeddedObject[this.propertyName] && embeddedObject[this.propertyName] instanceof Object && !(embeddedObject[this.propertyName] instanceof FindOperator)) {\n            value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n          } else {\n            value = embeddedObject[this.propertyName];\n          }\n        } else if (this.referencedColumn) {\n          value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n        } else {\n          value = embeddedObject[this.propertyName];\n        }\n      }\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.relationMetadata && this.referencedColumn) {\n        var relatedEntity = this.relationMetadata.getEntityValue(entity);\n\n        if (relatedEntity && relatedEntity instanceof Object && !(relatedEntity instanceof FindOperator) && !(relatedEntity instanceof Function)) {\n          value = this.referencedColumn.getEntityValue(relatedEntity);\n        } else if (entity[this.propertyName] && entity[this.propertyName] instanceof Object && !(entity[this.propertyName] instanceof FindOperator) && !(entity[this.propertyName] instanceof Function)) {\n          value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n        } else {\n          value = entity[this.propertyName];\n        }\n      } else if (this.referencedColumn) {\n        value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n      } else {\n        value = entity[this.propertyName];\n      }\n    }\n\n    if (transform && this.transformer) value = ApplyValueTransformers.transformTo(this.transformer, value);\n    return value;\n  };\n  /**\n   * Sets given entity's column value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   */\n\n\n  ColumnMetadata.prototype.setEntityValue = function (entity, value) {\n    var _this = this;\n\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      var extractEmbeddedColumnValue_4 = function (embeddedMetadatas, map) {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        var embeddedMetadata = embeddedMetadatas.shift();\n\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue_4(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n\n        map[_this.propertyName] = value;\n        return map;\n      };\n\n      return extractEmbeddedColumnValue_4(__spreadArray([], __read(this.embeddedMetadata.embeddedMetadataTree)), entity);\n    } else {\n      // we write a deep object in this entity only if the column is virtual\n      // because if its not virtual it means the user defined a real column for this relation\n      // also we don't do it if column is inside a junction table\n      if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {\n        if (!(this.propertyName in entity)) {\n          entity[this.propertyName] = {};\n        }\n\n        entity[this.propertyName][this.referencedColumn.propertyName] = value;\n      } else {\n        entity[this.propertyName] = value;\n      }\n    }\n  }; // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n\n\n  ColumnMetadata.prototype.build = function (connection) {\n    this.propertyPath = this.buildPropertyPath();\n    this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n    this.databaseName = this.buildDatabaseName(connection);\n    this.databasePath = this.buildDatabasePath();\n    this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n    return this;\n  };\n\n  ColumnMetadata.prototype.buildPropertyPath = function () {\n    var path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.propertyName; // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += \".\" + this.referencedColumn.propertyName;\n    return path;\n  };\n\n  ColumnMetadata.prototype.buildDatabasePath = function () {\n    var path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.databaseName; // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += \".\" + this.referencedColumn.databaseName;\n    return path;\n  };\n\n  ColumnMetadata.prototype.buildDatabaseName = function (connection) {\n    var propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n    if (connection.driver instanceof MongoDriver) // we don't need to include embedded name for the mongodb column names\n      propertyNames = [];\n    return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n  };\n\n  return ColumnMetadata;\n}();\n\nexport { ColumnMetadata };","map":{"version":3,"sources":["../browser/src/metadata/ColumnMetadata.ts"],"names":[],"mappings":"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","sourcesContent":["import {ColumnType} from \"../driver/types/ColumnTypes\";\nimport {EntityMetadata} from \"./EntityMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\nimport {RelationMetadata} from \"./RelationMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {ColumnMetadataArgs} from \"../metadata-args/ColumnMetadataArgs\";\nimport {Connection} from \"../connection/Connection\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {ValueTransformer} from \"../decorator/options/ValueTransformer\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {FindOperator} from \"../find-options/FindOperator\";\nimport {ApplyValueTransformers} from \"../util/ApplyValueTransformers\";\n\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class where column decorator is used.\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\n     */\n    target: Function|string;\n\n    /**\n     * Entity metadata where this column metadata is.\n     *\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata;\n\n    /**\n     * Embedded metadata where this column metadata is.\n     * If this column is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata;\n\n    /**\n     * If column is a foreign key of some relation then this relation's metadata will be there.\n     * If this column does not have a foreign key then this property value is undefined.\n     */\n    relationMetadata?: RelationMetadata;\n\n    /**\n     * Class's property name on which this column is applied.\n     */\n    propertyName: string;\n\n    /**\n     * The database type of the column.\n     */\n    type: ColumnType;\n\n    /**\n     * Type's length in the database.\n     */\n    length: string = \"\";\n\n    /**\n     * Type's display width in the database.\n     */\n    width?: number;\n\n    /**\n     * Defines column character set.\n     */\n    charset?: string;\n\n    /**\n     * Defines column collation.\n     */\n    collation?: string;\n\n    /**\n     * Indicates if this column is a primary key.\n     */\n    isPrimary: boolean = false;\n\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    isGenerated: boolean = false;\n\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    isNullable: boolean = false;\n\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    isSelect: boolean = true;\n\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    isInsert: boolean = true;\n\n    /**\n     * Indicates if column allows updates or not.\n     */\n    isUpdate: boolean = true;\n\n    /**\n     * Specifies generation strategy if this column will use auto increment.\n     */\n    generationStrategy?: \"uuid\"|\"increment\"|\"rowid\";\n\n    /**\n     * Column comment.\n     * This feature is not supported by all databases.\n     */\n    comment?: string;\n\n    /**\n     * Default database value.\n     */\n    default?: any;\n\n    /**\n     * ON UPDATE trigger. Works only for MySQL.\n     */\n    onUpdate?: string;\n\n    /**\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\n     * which is the maximum number of digits that are stored for the values.\n     */\n    precision?: number|null;\n\n    /**\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\n     */\n    scale?: number;\n\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    zerofill: boolean = false;\n\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    unsigned: boolean = false;\n\n    /**\n     * Array of possible enumerated values.\n     *\n     * `postgres` and `mysql` store enum values as strings but we want to keep support\n     * for numeric and heterogeneous based typescript enums, so we need (string|number)[]\n     */\n    enum?: (string|number)[];\n\n    /**\n     * Exact name of enum\n     */\n    enumName?: string;\n\n    /**\n     * Generated column expression. Supports only in MySQL.\n     */\n    asExpression?: string;\n\n    /**\n     * Generated column type. Supports only in MySQL.\n     */\n    generatedType?: \"VIRTUAL\"|\"STORED\";\n\n    /**\n     * Return type of HSTORE column.\n     * Returns value as string or as object.\n     */\n    hstoreType?: \"object\"|\"string\";\n\n    /**\n     * Indicates if this column is an array.\n     */\n    isArray: boolean = false;\n\n    /**\n     * Gets full path to this column property (including column property name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string;\n\n    /**\n     * Same as property path, but dots are replaced with '_'.\n     * Used in query builder statements.\n     */\n    propertyAliasName: string;\n\n    /**\n     * Gets full path to this column database name (including column database name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just database name of the column.\n     */\n    databasePath: string;\n\n    /**\n     * Complete column name in the database including its embedded prefixes.\n     */\n    databaseName: string;\n\n    /**\n     * Database name in the database without embedded prefixes applied.\n     */\n    databaseNameWithoutPrefixes: string;\n\n    /**\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\n     */\n    givenDatabaseName?: string;\n\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    isVirtual: boolean = false;\n\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    isDiscriminator: boolean = false;\n\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    isTreeLevel: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    isCreateDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    isUpdateDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    isDeleteDate: boolean = false;\n\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    isVersion: boolean = false;\n\n    /**\n     * Indicates if this column contains an object id.\n     */\n    isObjectId: boolean = false;\n\n    /**\n     * If this column is foreign key then it references some other column,\n     * and this property will contain reference to this column.\n     */\n    referencedColumn: ColumnMetadata|undefined;\n\n    /**\n     * Specifies a value transformer that is to be used to (un)marshal\n     * this column when reading or writing to the database.\n     */\n    transformer?: ValueTransformer|ValueTransformer[];\n\n    /**\n     * Column type in the case if this column is in the closure table.\n     * Column can be ancestor or descendant in the closure tables.\n     */\n    closureType?: \"ancestor\"|\"descendant\";\n\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetLeft: boolean = false;\n\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetRight: boolean = false;\n\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    isMaterializedPath: boolean = false;\n\n    /**\n     * Spatial Feature Type (Geometry, Point, Polygon, etc.)\n     */\n    spatialFeatureType?: string;\n\n    /**\n     * SRID (Spatial Reference ID (EPSG code))\n     */\n    srid?: number;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: Connection,\n        entityMetadata: EntityMetadata,\n        embeddedMetadata?: EmbeddedMetadata,\n        referencedColumn?: ColumnMetadata,\n        args: ColumnMetadataArgs,\n        closureType?: \"ancestor\"|\"descendant\",\n        nestedSetLeft?: boolean,\n        nestedSetRight?: boolean,\n        materializedPath?: boolean,\n    }) {\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata!;\n        this.referencedColumn = options.referencedColumn;\n        if (options.args.target)\n            this.target = options.args.target;\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName;\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name;\n        if (options.args.options.type)\n            this.type = options.args.options.type;\n        if (options.args.options.length)\n            this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n        if (options.args.options.width)\n            this.width = options.args.options.width;\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset;\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation;\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary;\n        if (options.args.options.default === null) // to make sure default: null is the same as nullable: true\n            this.isNullable = true;\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable;\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select;\n        if (options.args.options.insert !== undefined)\n            this.isInsert = options.args.options.insert;\n        if (options.args.options.update !== undefined)\n            this.isUpdate = options.args.options.update;\n        if (options.args.options.readonly !== undefined)\n            this.isUpdate = !options.args.options.readonly;\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment;\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default;\n        if (options.args.options.onUpdate)\n            this.onUpdate = options.args.options.onUpdate;\n        if (options.args.options.scale !== null && options.args.options.scale !== undefined)\n            this.scale = options.args.options.scale;\n        if (options.args.options.zerofill) {\n            this.zerofill = options.args.options.zerofill;\n            this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n        }\n        if (options.args.options.unsigned)\n            this.unsigned = options.args.options.unsigned;\n        if (options.args.options.precision !== null)\n            this.precision = options.args.options.precision;\n        if (options.args.options.enum) {\n            if (options.args.options.enum instanceof Object && !Array.isArray(options.args.options.enum)) {\n                this.enum = Object.keys(options.args.options.enum)\n                    // remove numeric keys - typescript numeric enum types generate them\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n                    // generated SQL statements contains string representation of that function which leads into syntax error\n                    // at database side.\n                    .filter(key => isNaN(+key) && typeof (options.args.options.enum as ObjectLiteral)[key] !== \"function\")\n                    .map(key => (options.args.options.enum as ObjectLiteral)[key]);\n\n            } else {\n                this.enum = options.args.options.enum;\n            }\n        }\n        if (options.args.options.enumName) {\n            this.enumName = options.args.options.enumName;\n        }\n        if (options.args.options.asExpression) {\n            this.asExpression = options.args.options.asExpression;\n            this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : \"VIRTUAL\";\n        }\n        if (options.args.options.hstoreType)\n            this.hstoreType = options.args.options.hstoreType;\n        if (options.args.options.array)\n            this.isArray = options.args.options.array;\n        if (options.args.mode) {\n            this.isVirtual = options.args.mode === \"virtual\";\n            this.isTreeLevel = options.args.mode === \"treeLevel\";\n            this.isCreateDate = options.args.mode === \"createDate\";\n            this.isUpdateDate = options.args.mode === \"updateDate\";\n            this.isDeleteDate = options.args.mode === \"deleteDate\";\n            this.isVersion = options.args.mode === \"version\";\n            this.isObjectId = options.args.mode === \"objectId\";\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer;\n        if (options.args.options.spatialFeatureType)\n            this.spatialFeatureType = options.args.options.spatialFeatureType;\n        if (options.args.options.srid !== undefined)\n            this.srid = options.args.options.srid;\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel;\n        if (this.isCreateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.createDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n        }\n        if (this.isUpdateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.updateDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n            if (!this.onUpdate)\n                this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n        }\n        if (this.isDeleteDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.deleteDate;\n            if (!this.isNullable)\n                this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision)\n                this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version;\n        if (options.closureType)\n            this.closureType = options.closureType;\n        if (options.nestedSetLeft)\n            this.isNestedSetLeft = options.nestedSetLeft;\n        if (options.nestedSetRight)\n            this.isNestedSetRight = options.nestedSetRight;\n        if (options.materializedPath)\n            this.isMaterializedPath = options.materializedPath;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any, useDatabaseName = false) {\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n                    return map;\n                }\n\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null)\n                    value = String(value);\n\n                map[useDatabaseName ? this.databaseName : this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, {});\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null)\n                value = String(value);\n\n            return { [useDatabaseName ? this.databaseName : this.propertyName]: value };\n        }\n    }\n\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(entity: ObjectLiteral, options?: { skipNulls?: boolean }): ObjectLiteral|undefined {\n        const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral, map: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                if (value === undefined)\n                    return map;\n\n                if (propertyName) {\n                    const submap: ObjectLiteral = {};\n                    extractEmbeddedColumnValue(propertyNames, value[propertyName], submap);\n                    if (Object.keys(submap).length > 0) {\n                        map[propertyName] = submap;\n                    }\n                    return map;\n                }\n                if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null))\n                    map[this.propertyName] = value[this.propertyName];\n                return map;\n            };\n            const map: ObjectLiteral = {};\n            extractEmbeddedColumnValue(propertyNames, entity, map);\n            return Object.keys(map).length > 0 ? map : undefined;\n\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\n            if (this.relationMetadata && entity[this.relationMetadata.propertyName] && entity[this.relationMetadata.propertyName] instanceof Object) {\n                const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n                    const value = joinColumn.referencedColumn!.getEntityValueMap(entity[this.relationMetadata!.propertyName]);\n                    if (value === undefined) return map;\n                    return OrmUtils.mergeDeep(map, value);\n                }, {});\n                if (Object.keys(map).length > 0)\n                    return { [this.propertyName]: map };\n\n                return undefined;\n            } else {\n                if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null))\n                    return { [this.propertyName]: entity[this.propertyName] };\n\n                return undefined;\n            }\n        }\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(entity: ObjectLiteral, transform: boolean = false): any|undefined {\n        if (entity === undefined || entity === null) return undefined;\n\n        // extract column value from embeddeds of entity if column is in embedded\n        let value: any = undefined;\n        if (this.embeddedMetadata) {\n\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral): any => {\n                const propertyName = propertyNames.shift();\n                return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\n            };\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn) {\n                    const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n                    if (relatedEntity && relatedEntity instanceof Object && !(relatedEntity instanceof FindOperator)) {\n                        value = this.referencedColumn.getEntityValue(relatedEntity);\n\n                    } else if (embeddedObject[this.propertyName] && embeddedObject[this.propertyName] instanceof Object && !(embeddedObject[this.propertyName] instanceof FindOperator)) {\n                        value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n\n                    } else {\n                        value = embeddedObject[this.propertyName];\n\n                    }\n\n                } else if (this.referencedColumn) {\n                    value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n\n                } else {\n                    value = embeddedObject[this.propertyName];\n                }\n            }\n\n        } else { // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn) {\n                const relatedEntity = this.relationMetadata.getEntityValue(entity);\n                if (relatedEntity && relatedEntity instanceof Object && !(relatedEntity instanceof FindOperator) && !(relatedEntity instanceof Function)) {\n                    value = this.referencedColumn.getEntityValue(relatedEntity);\n\n                } else if (entity[this.propertyName] && entity[this.propertyName] instanceof Object && !(entity[this.propertyName] instanceof FindOperator) && !(entity[this.propertyName] instanceof Function)) {\n                    value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n\n                } else {\n                    value = entity[this.propertyName];\n                }\n\n            } else if (this.referencedColumn) {\n                value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n\n            } else {\n                value = entity[this.propertyName];\n            }\n        }\n\n        if (transform && this.transformer)\n            value = ApplyValueTransformers.transformTo(this.transformer, value);\n\n        return value;\n    }\n\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        if (this.embeddedMetadata) {\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (embeddedMetadatas: EmbeddedMetadata[], map: ObjectLiteral): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift();\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n\n        } else {\n            // we write a deep object in this entity only if the column is virtual\n            // because if its not virtual it means the user defined a real column for this relation\n            // also we don't do it if column is inside a junction table\n            if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {\n                if (!(this.propertyName in entity)) {\n                    entity[this.propertyName] = {};\n                }\n\n                entity[this.propertyName][this.referencedColumn.propertyName] = value;\n            } else {\n                entity[this.propertyName] = value;\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: Connection): this {\n        this.propertyPath = this.buildPropertyPath();\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n        this.databaseName = this.buildDatabaseName(connection);\n        this.databasePath = this.buildDatabasePath();\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n        return this;\n    }\n\n    protected buildPropertyPath(): string {\n        let path = \"\";\n        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n\n        path += this.propertyName;\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)\n            path += \".\" + this.referencedColumn.propertyName;\n\n        return path;\n    }\n\n    protected buildDatabasePath(): string {\n        let path = \"\";\n        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n\n        path += this.databaseName;\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName)\n            path += \".\" + this.referencedColumn.databaseName;\n\n        return path;\n    }\n\n    protected buildDatabaseName(connection: Connection): string {\n        let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n        if (connection.driver instanceof MongoDriver) // we don't need to include embedded name for the mongodb column names\n            propertyNames = [];\n        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}