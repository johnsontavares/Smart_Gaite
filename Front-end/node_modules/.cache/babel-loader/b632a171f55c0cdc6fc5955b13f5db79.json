{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../\";\n/**\n * Marks a entity property as a children of the tree.\n * \"Tree children\" will contain all children (bind) of this entity.\n */\n\nexport function TreeChildren(options) {\n  return function (object, propertyName) {\n    if (!options) options = {}; // now try to determine it its lazy relation\n\n    var reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    var isLazy = reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\" || false; // add one-to-many relation for this\n\n    getMetadataArgsStorage().relations.push({\n      isTreeChildren: true,\n      target: object.constructor,\n      propertyName: propertyName,\n      isLazy: isLazy,\n      relationType: \"one-to-many\",\n      type: function () {\n        return object.constructor;\n      },\n      options: options\n    });\n  };\n}","map":{"version":3,"sources":["../browser/src/decorator/tree/TreeChildren.ts"],"names":[],"mappings":"AAAA,SAAQ,sBAAR,QAAsD,QAAtD;AAGA;;;AAGG;;AACH,OAAM,SAAU,YAAV,CAAuB,OAAvB,EAA6G;AAC/G,SAAO,UAAU,MAAV,EAA0B,YAA1B,EAA8C;AACjD,QAAI,CAAC,OAAL,EAAc,OAAO,GAAG,EAAV,CADmC,CAGjD;;AACA,QAAM,aAAa,GAAG,OAAO,IAAK,OAAe,CAAC,WAA5B,GAA0C,OAAO,CAAC,WAAR,CAAoB,aAApB,EAAmC,MAAnC,EAA2C,YAA3C,CAA1C,GAAqG,SAA3H;AACA,QAAM,MAAM,GAAI,aAAa,IAAI,OAAO,aAAa,CAAC,IAArB,KAA8B,QAA/C,IAA2D,aAAa,CAAC,IAAd,CAAmB,WAAnB,OAAqC,SAAjG,IAA+G,KAA9H,CALiD,CAOjD;;AACA,IAAA,sBAAsB,GAAG,SAAzB,CAAmC,IAAnC,CAAwC;AACpC,MAAA,cAAc,EAAE,IADoB;AAEpC,MAAA,MAAM,EAAE,MAAM,CAAC,WAFqB;AAGpC,MAAA,YAAY,EAAE,YAHsB;AAIpC,MAAA,MAAM,EAAE,MAJ4B;AAKpC,MAAA,YAAY,EAAE,aALsB;AAMpC,MAAA,IAAI,EAAE,YAAA;AAAM,eAAA,MAAM,CAAN,WAAA;AAAkB,OANM;AAOpC,MAAA,OAAO,EAAE;AAP2B,KAAxC;AASH,GAjBD;AAkBH","sourcesContent":["import {getMetadataArgsStorage, RelationOptions} from \"../../\";\nimport {RelationMetadataArgs} from \"../../metadata-args/RelationMetadataArgs\";\n\n/**\n * Marks a entity property as a children of the tree.\n * \"Tree children\" will contain all children (bind) of this entity.\n */\nexport function TreeChildren(options?: { cascade?: boolean|(\"insert\"|\"update\"|\"remove\"|\"soft-remove\"|\"recover\")[] }): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions;\n\n        // now try to determine it its lazy relation\n        const reflectedType = Reflect && (Reflect as any).getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n        const isLazy = (reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\") || false;\n\n        // add one-to-many relation for this\n        getMetadataArgsStorage().relations.push({\n            isTreeChildren: true,\n            target: object.constructor,\n            propertyName: propertyName,\n            isLazy: isLazy,\n            relationType: \"one-to-many\",\n            type: () => object.constructor,\n            options: options\n        } as RelationMetadataArgs);\n    };\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}