{"ast":null,"code":"/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nvar defaultContainer = new (\n/** @class */\nfunction () {\n  function class_1() {\n    this.instances = [];\n  }\n\n  class_1.prototype.get = function (someClass) {\n    var instance = this.instances.find(function (i) {\n      return i.type === someClass;\n    });\n\n    if (!instance) {\n      instance = {\n        type: someClass,\n        object: new someClass()\n      };\n      this.instances.push(instance);\n    }\n\n    return instance.object;\n  };\n\n  return class_1;\n}())();\nvar userContainer;\nvar userContainerOptions;\n/**\n * Sets container to be used by this library.\n */\n\nexport function useContainer(iocContainer, options) {\n  userContainer = iocContainer;\n  userContainerOptions = options;\n}\n/**\n * Gets the IOC container used by this library.\n */\n\nexport function getFromContainer(someClass) {\n  if (userContainer) {\n    try {\n      var instance = userContainer.get(someClass);\n      if (instance) return instance;\n      if (!userContainerOptions || !userContainerOptions.fallback) return instance;\n    } catch (error) {\n      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;\n    }\n  }\n\n  return defaultContainer.get(someClass);\n}","map":{"version":3,"sources":["../browser/src/container.ts"],"names":[],"mappings":"AAuBA;;;AAGG;AACH,IAAM,gBAAgB,GAAuB;AAAI;AAAA,YAAA;AAAC,WAAA,OAAA,GAAA;AACtC,SAAA,SAAA,GAA+C,EAA/C;AAWX;;AATG,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAO,SAAP,EAAkC;AAC9B,QAAI,QAAQ,GAAG,KAAK,SAAL,CAAe,IAAf,CAAoB,UAAA,CAAA,EAAC;AAAI,aAAA,CAAC,CAAC,IAAF,KAAA,SAAA;AAAoB,KAA7C,CAAf;;AACA,QAAI,CAAC,QAAL,EAAe;AACX,MAAA,QAAQ,GAAG;AAAE,QAAA,IAAI,EAAE,SAAR;AAAmB,QAAA,MAAM,EAAE,IAAK,SAAL;AAA3B,OAAX;AACA,WAAK,SAAL,CAAe,IAAf,CAAoB,QAApB;AACH;;AAED,WAAO,QAAQ,CAAC,MAAhB;AACH,GARD;;AASJ,SAAA,OAAA;AAAC,CAZgD,EAAJ,GAA7C;AAcA,IAAI,aAAJ;AACA,IAAI,oBAAJ;AAEA;;AAEG;;AACH,OAAM,SAAU,YAAV,CAAuB,YAAvB,EAAyD,OAAzD,EAAsF;AACxF,EAAA,aAAa,GAAG,YAAhB;AACA,EAAA,oBAAoB,GAAG,OAAvB;AACH;AAED;;AAEG;;AACH,OAAM,SAAU,gBAAV,CAA8B,SAA9B,EAAyD;AAC3D,MAAI,aAAJ,EAAmB;AACf,QAAI;AACA,UAAM,QAAQ,GAAG,aAAa,CAAC,GAAd,CAAkB,SAAlB,CAAjB;AACA,UAAI,QAAJ,EACI,OAAO,QAAP;AAEJ,UAAI,CAAC,oBAAD,IAAyB,CAAC,oBAAoB,CAAC,QAAnD,EACI,OAAO,QAAP;AAEP,KARD,CAQE,OAAO,KAAP,EAAc;AACZ,UAAI,CAAC,oBAAD,IAAyB,CAAC,oBAAoB,CAAC,gBAAnD,EACI,MAAM,KAAN;AACP;AACJ;;AACD,SAAO,gBAAgB,CAAC,GAAjB,CAAwB,SAAxB,CAAP;AACH","sourcesContent":["/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\nexport type ContainedType<T> = { new (...args: any[]): T } | Function;\n\nexport interface ContainerInterface {\n    get<T>(someClass: ContainedType<T>): T;\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: ContainerInterface = new (class implements ContainerInterface {\n    private instances: { type: Function, object: any }[] = [];\n\n    get<T>(someClass: ContainedType<T>): T {\n        let instance = this.instances.find(i => i.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new (someClass as new() => T)()};\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: ContainerInterface;\nlet userContainerOptions: UseContainerOptions|undefined;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: ContainerInterface, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: ContainedType<T>): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}"],"sourceRoot":"."},"metadata":{},"sourceType":"module"}