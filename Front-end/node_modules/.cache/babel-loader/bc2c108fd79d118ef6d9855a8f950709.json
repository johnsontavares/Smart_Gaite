{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\n/**\n * Runs queries on a single sqlite database connection.\n */\n\nvar CordovaQueryRunner =\n/** @class */\nfunction (_super) {\n  __extends(CordovaQueryRunner, _super); // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n\n  function CordovaQueryRunner(driver) {\n    var _this = _super.call(this) || this;\n\n    _this.driver = driver;\n    _this.connection = driver.connection;\n    _this.broadcaster = new Broadcaster(_this);\n    return _this;\n  }\n  /**\n   * Executes a given SQL query.\n   */\n\n\n  CordovaQueryRunner.prototype.query = function (query, parameters) {\n    var _this = this;\n\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(function (ok, fail) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var databaseConnection, queryStartTime;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.connect()];\n\n            case 1:\n              databaseConnection = _a.sent();\n              this.driver.connection.logger.logQuery(query, parameters, this);\n              queryStartTime = +new Date();\n              databaseConnection.executeSql(query, parameters, function (result) {\n                // log slow queries if maxQueryExecution time is set\n                var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;\n                var queryEndTime = +new Date();\n                var queryExecutionTime = queryEndTime - queryStartTime;\n                if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);\n\n                if (query.substr(0, 11) === \"INSERT INTO\") {\n                  ok(result.insertId);\n                } else {\n                  var resultSet = [];\n\n                  for (var i = 0; i < result.rows.length; i++) {\n                    resultSet.push(result.rows.item(i));\n                  }\n\n                  ok(resultSet);\n                }\n              }, function (err) {\n                _this.driver.connection.logger.logQueryError(err, query, parameters, _this);\n\n                fail(new QueryFailedError(query, parameters, err));\n              });\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Insert a new row with given values into the given table.\n   * Returns value of the generated column if given and generate column exist in the table.\n   // todo: implement new syntax\n  async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n      const keys = Object.keys(keyValues);\n      const columns = keys.map(key => `\"${key}\"`).join(\", \");\n      const values = keys.map(key => \"?\").join(\",\");\n      const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n      const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n      const parameters = keys.map(key => keyValues[key]);\n       return new Promise<InsertResult>(async (ok, fail) => {\n          this.driver.connection.logger.logQuery(sql, parameters, this);\n          const __this = this;\n          const databaseConnection = await this.connect();\n          databaseConnection.executeSql(sql, parameters, (resultSet: any) => {\n              const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                  const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];\n                  if (!value) return map;\n                  return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n              }, {} as ObjectLiteral);\n               ok({\n                  result: undefined,\n                  generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n              });\n          }, (err: any) => {\n              __this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n              fail(err);\n          });\n      });\n  }*/\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Parametrizes given object of values. Used to create column=value queries.\n   */\n\n\n  CordovaQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n\n    return Object.keys(objectLiteral).map(function (key, index) {\n      return \"\\\"\" + key + \"\\\"\" + \"=?\";\n    });\n  };\n\n  return CordovaQueryRunner;\n}(AbstractSqliteQueryRunner);\n\nexport { CordovaQueryRunner };","map":{"version":3,"sources":["../browser/src/driver/cordova/CordovaQueryRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\nimport {AbstractSqliteQueryRunner} from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport {CordovaDriver} from \"./CordovaDriver\";\nimport {Broadcaster} from \"../../subscriber/Broadcaster\";\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class CordovaQueryRunner extends AbstractSqliteQueryRunner {\n    \n    /**\n     * Database driver used by connection.\n     */\n    driver: CordovaDriver;\n    \n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: CordovaDriver) {\n        super();\n        this.driver = driver;\n        this.connection = driver.connection;\n        this.broadcaster = new Broadcaster(this);\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        return new Promise<any[]>(async (ok, fail) => {\n            const databaseConnection = await this.connect();\n            this.driver.connection.logger.logQuery(query, parameters, this);\n            const queryStartTime = +new Date();\n            databaseConnection.executeSql(query, parameters, (result: any) => {\n\n                // log slow queries if maxQueryExecution time is set\n                const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\n                const queryEndTime = +new Date();\n                const queryExecutionTime = queryEndTime - queryStartTime;\n                if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)\n                    this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n\n                if (query.substr(0, 11) === \"INSERT INTO\") {\n                    ok(result.insertId);\n                }\n                else {\n                    let resultSet = [];\n                    for (let i = 0; i < result.rows.length; i++) {\n                        resultSet.push(result.rows.item(i));\n                    }\n                    \n                    ok(resultSet);\n                }\n            }, (err: any) => {\n                this.driver.connection.logger.logQueryError(err, query, parameters, this);\n                fail(new QueryFailedError(query, parameters, err));\n            });\n        });\n    }\n\n    /**\n     * Insert a new row with given values into the given table.\n     * Returns value of the generated column if given and generate column exist in the table.\n     // todo: implement new syntax\n    async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n        const keys = Object.keys(keyValues);\n        const columns = keys.map(key => `\"${key}\"`).join(\", \");\n        const values = keys.map(key => \"?\").join(\",\");\n        const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n        const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n        const parameters = keys.map(key => keyValues[key]);\n\n        return new Promise<InsertResult>(async (ok, fail) => {\n            this.driver.connection.logger.logQuery(sql, parameters, this);\n            const __this = this;\n            const databaseConnection = await this.connect();\n            databaseConnection.executeSql(sql, parameters, (resultSet: any) => {\n                const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                    const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];\n                    if (!value) return map;\n                    return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n                }, {} as ObjectLiteral);\n\n                ok({\n                    result: undefined,\n                    generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n                });\n            }, (err: any) => {\n                __this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n                fail(err);\n            });\n        });\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Parametrizes given object of values. Used to create column=value queries.\n     */\n    protected parametrize(objectLiteral: ObjectLiteral, startIndex: number = 0): string[] {\n        return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\");\n    }\n}"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}