{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\n/**\n * Loads relation ids for the given entities.\n */\n\nvar RelationIdLoader =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationIdLoader(connection) {\n    this.connection = connection;\n  }\n  /**\n   * Loads relation ids of the given entity or entities.\n   */\n\n\n  RelationIdLoader.prototype.load = function (relationOrTarget, relationNameOrEntities, entitiesOrRelatedEntities, maybeRelatedEntities) {\n    return __awaiter(this, void 0, void 0, function () {\n      var relation, entities, relatedEntities, entityMetadata;\n      return __generator(this, function (_a) {\n        if (relationOrTarget instanceof RelationMetadata) {\n          relation = relationOrTarget;\n          entities = Array.isArray(relationNameOrEntities) ? relationNameOrEntities : [relationNameOrEntities];\n          relatedEntities = Array.isArray(entitiesOrRelatedEntities) ? entitiesOrRelatedEntities : entitiesOrRelatedEntities ? [entitiesOrRelatedEntities] : undefined;\n        } else {\n          entityMetadata = this.connection.getMetadata(relationOrTarget);\n          relation = entityMetadata.findRelationWithPropertyPath(relationNameOrEntities);\n          if (!relation) throw new Error(\"Relation \\\"\" + relation + \"\\\" was not found in \\\"\" + entityMetadata.name + \"\\\".\");\n          entities = Array.isArray(entitiesOrRelatedEntities) ? entitiesOrRelatedEntities : [entitiesOrRelatedEntities];\n          relatedEntities = Array.isArray(maybeRelatedEntities) ? maybeRelatedEntities : maybeRelatedEntities ? [maybeRelatedEntities] : undefined;\n        } // load relation ids depend of relation type\n\n\n        if (relation.isManyToMany) {\n          return [2\n          /*return*/\n          , this.loadForManyToMany(relation, entities, relatedEntities)];\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n          return [2\n          /*return*/\n          , this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities)];\n        } else {\n          // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n          return [2\n          /*return*/\n          , this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Loads relation ids of the given entities and groups them into the object with parent and children.\n   *\n   * todo: extract this method?\n   */\n\n\n  RelationIdLoader.prototype.loadManyToManyRelationIdsAndGroup = function (relation, entitiesOrEntities, relatedEntityOrEntities) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isMany, entities, relationIds, relatedEntities, columns, inverseColumns;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isMany = relation.isManyToMany || relation.isOneToMany;\n            entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];\n            if (!!relatedEntityOrEntities) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.connection.relationLoader.load(relation, entitiesOrEntities)];\n\n          case 1:\n            relatedEntityOrEntities = _a.sent();\n            if (!relatedEntityOrEntities.length) return [2\n            /*return*/\n            , entities.map(function (entity) {\n              return {\n                entity: entity,\n                related: isMany ? [] : undefined\n              };\n            })];\n            _a.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.load(relation, entitiesOrEntities, relatedEntityOrEntities)];\n\n          case 3:\n            relationIds = _a.sent();\n            relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities];\n\n            if (relation.isManyToManyOwner) {\n              columns = relation.junctionEntityMetadata.inverseColumns.map(function (column) {\n                return column.referencedColumn;\n              });\n              inverseColumns = relation.junctionEntityMetadata.ownerColumns.map(function (column) {\n                return column.referencedColumn;\n              });\n            } else if (relation.isManyToManyNotOwner) {\n              columns = relation.junctionEntityMetadata.ownerColumns.map(function (column) {\n                return column.referencedColumn;\n              });\n              inverseColumns = relation.junctionEntityMetadata.inverseColumns.map(function (column) {\n                return column.referencedColumn;\n              });\n            } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n              columns = relation.joinColumns.map(function (column) {\n                return column.referencedColumn;\n              });\n              inverseColumns = relation.entityMetadata.primaryColumns;\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n              columns = relation.inverseRelation.entityMetadata.primaryColumns;\n              inverseColumns = relation.inverseRelation.joinColumns.map(function (column) {\n                return column.referencedColumn;\n              });\n            } else {}\n\n            return [2\n            /*return*/\n            , entities.map(function (entity) {\n              var group = {\n                entity: entity,\n                related: isMany ? [] : undefined\n              };\n              relationIds.forEach(function (relationId) {\n                var entityMatched = inverseColumns.every(function (column) {\n                  return column.getEntityValue(entity) === relationId[column.entityMetadata.name + \"_\" + column.propertyPath.replace(\".\", \"_\")];\n                });\n\n                if (entityMatched) {\n                  relatedEntities.forEach(function (relatedEntity) {\n                    var relatedEntityMatched = columns.every(function (column) {\n                      return column.getEntityValue(relatedEntity) === relationId[column.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.propertyPath.replace(\".\", \"_\")];\n                    });\n\n                    if (relatedEntityMatched) {\n                      if (isMany) {\n                        group.related.push(relatedEntity);\n                      } else {\n                        group.related = relatedEntity;\n                      }\n                    }\n                  });\n                }\n              });\n              return group;\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Loads relation ids of the given entities and maps them into the given entity property.\n   async loadManyToManyRelationIdsAndMap(\n      relation: RelationMetadata,\n      entityOrEntities: ObjectLiteral|ObjectLiteral[],\n      mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n      propertyName: string\n  ): Promise<void> {\n       const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n      const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n      const junctionMetadata = relation.junctionEntityMetadata!;\n      const mainAlias = junctionMetadata.name;\n      const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n      const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n       mapToEntities.forEach(mapToEntity => {\n          mapToEntity[propertyName] = [];\n          relationIds.forEach(relationId => {\n              const match = inverseColumns.every(column => {\n                  return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n              });\n              if (match) {\n                  if (columns.length === 1) {\n                      mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                   } else {\n                      const value = {};\n                      columns.forEach(column => {\n                          column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                      });\n                      mapToEntity[propertyName].push(value);\n                  }\n              }\n          });\n      });\n  }*/\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Loads relation ids for the many-to-many relation.\n   */\n\n\n  RelationIdLoader.prototype.loadForManyToMany = function (relation, entities, relatedEntities) {\n    var junctionMetadata = relation.junctionEntityMetadata;\n    var mainAlias = junctionMetadata.name;\n    var columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n    var inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n    var qb = this.connection.createQueryBuilder(); // select all columns from junction table\n\n    junctionMetadata.ownerColumns.forEach(function (column) {\n      var columnName = column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\");\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    junctionMetadata.inverseColumns.forEach(function (column) {\n      var columnName = column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\");\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    }); // add conditions for the given entities\n\n    var condition1 = \"\";\n\n    if (columns.length === 1) {\n      qb.setParameter(\"values1\", entities.map(function (entity) {\n        return columns[0].referencedColumn.getEntityValue(entity);\n      }));\n      condition1 = mainAlias + \".\" + columns[0].propertyPath + \" IN (:...values1)\"; // todo: use ANY for postgres\n    } else {\n      condition1 = \"(\" + entities.map(function (entity, entityIndex) {\n        return columns.map(function (column) {\n          var paramName = \"entity1_\" + entityIndex + \"_\" + column.propertyName;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(function (condition) {\n        return \"(\" + condition + \")\";\n      }).join(\" OR \") + \")\";\n    } // add conditions for the given inverse entities\n\n\n    var condition2 = \"\";\n\n    if (relatedEntities) {\n      if (inverseColumns.length === 1) {\n        qb.setParameter(\"values2\", relatedEntities.map(function (entity) {\n          return inverseColumns[0].referencedColumn.getEntityValue(entity);\n        }));\n        condition2 = mainAlias + \".\" + inverseColumns[0].propertyPath + \" IN (:...values2)\"; // todo: use ANY for postgres\n      } else {\n        condition2 = \"(\" + relatedEntities.map(function (entity, entityIndex) {\n          return inverseColumns.map(function (column) {\n            var paramName = \"entity2_\" + entityIndex + \"_\" + column.propertyName;\n            qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n            return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n          }).join(\" AND \");\n        }).map(function (condition) {\n          return \"(\" + condition + \")\";\n        }).join(\" OR \") + \")\";\n      }\n    } // execute query\n\n\n    return qb.from(junctionMetadata.target, mainAlias).where(condition1 + (condition2 ? \" AND \" + condition2 : \"\")).getRawMany();\n  };\n  /**\n   * Loads relation ids for the many-to-one and one-to-one owner relations.\n   */\n\n\n  RelationIdLoader.prototype.loadForManyToOneAndOneToOneOwner = function (relation, entities, relatedEntities) {\n    var mainAlias = relation.entityMetadata.targetName; // select all columns we need\n\n    var qb = this.connection.createQueryBuilder();\n    relation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {\n      var columnName = primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(function (column) {\n      var columnName = column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\");\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    }); // add condition for entities\n\n    var condition = \"\";\n\n    if (relation.entityMetadata.primaryColumns.length === 1) {\n      qb.setParameter(\"values\", entities.map(function (entity) {\n        return relation.entityMetadata.primaryColumns[0].getEntityValue(entity);\n      }));\n      condition = mainAlias + \".\" + relation.entityMetadata.primaryColumns[0].propertyPath + \" IN (:...values)\";\n    } else {\n      condition = entities.map(function (entity, entityIndex) {\n        return relation.entityMetadata.primaryColumns.map(function (column, columnIndex) {\n          var paramName = \"entity\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(function (condition) {\n        return \"(\" + condition + \")\";\n      }).join(\" OR \");\n    } // execute query\n\n\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  };\n  /**\n   * Loads relation ids for the one-to-many and one-to-one not owner relations.\n   */\n\n\n  RelationIdLoader.prototype.loadForOneToManyAndOneToOneNotOwner = function (relation, entities, relatedEntities) {\n    relation = relation.inverseRelation;\n    var mainAlias = relation.entityMetadata.targetName; // select all columns we need\n\n    var qb = this.connection.createQueryBuilder();\n    relation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {\n      var columnName = primaryColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(function (column) {\n      var columnName = column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\");\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    }); // add condition for entities\n\n    var condition = \"\";\n\n    if (relation.joinColumns.length === 1) {\n      qb.setParameter(\"values\", entities.map(function (entity) {\n        return relation.joinColumns[0].referencedColumn.getEntityValue(entity);\n      }));\n      condition = mainAlias + \".\" + relation.joinColumns[0].propertyPath + \" IN (:...values)\";\n    } else {\n      condition = entities.map(function (entity, entityIndex) {\n        return relation.joinColumns.map(function (joinColumn, joinColumnIndex) {\n          var paramName = \"entity\" + entityIndex + \"_\" + joinColumnIndex;\n          qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + joinColumn.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(function (condition) {\n        return \"(\" + condition + \")\";\n      }).join(\" OR \");\n    } // execute query\n\n\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  };\n\n  return RelationIdLoader;\n}();\n\nexport { RelationIdLoader };","map":{"version":3,"sources":["../browser/src/query-builder/RelationIdLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import {Connection, ObjectLiteral} from \"../\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\n\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    async load(target: Function|string, relation: string, entities: ObjectLiteral|ObjectLiteral[], relatedEntities?: ObjectLiteral|ObjectLiteral[]): Promise<any[]>;\n\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    async load(relation: RelationMetadata, entities: ObjectLiteral|ObjectLiteral[], relatedEntities?: ObjectLiteral|ObjectLiteral[]): Promise<any[]>;\n\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    async load(relationOrTarget: RelationMetadata|Function|string, relationNameOrEntities: string|ObjectLiteral|ObjectLiteral[], entitiesOrRelatedEntities?: ObjectLiteral|ObjectLiteral[], maybeRelatedEntities?: ObjectLiteral|ObjectLiteral[]): Promise<any[]> {\n\n        // normalize arguments\n        let relation: RelationMetadata|undefined, entities: ObjectLiteral[], relatedEntities: ObjectLiteral[]|undefined;\n        if (relationOrTarget instanceof RelationMetadata) {\n            relation = relationOrTarget;\n            entities = Array.isArray(relationNameOrEntities) ? relationNameOrEntities as ObjectLiteral[] : [relationNameOrEntities as ObjectLiteral];\n            relatedEntities = Array.isArray(entitiesOrRelatedEntities) ? entitiesOrRelatedEntities as ObjectLiteral[] : (entitiesOrRelatedEntities ? [entitiesOrRelatedEntities as ObjectLiteral] : undefined);\n\n        } else {\n            const entityMetadata = this.connection.getMetadata(relationOrTarget);\n            relation = entityMetadata.findRelationWithPropertyPath(relationNameOrEntities as string);\n            if (!relation)\n                throw new Error(`Relation \"${relation}\" was not found in \"${entityMetadata.name}\".`);\n\n            entities = Array.isArray(entitiesOrRelatedEntities) ? entitiesOrRelatedEntities as ObjectLiteral[] : [entitiesOrRelatedEntities as ObjectLiteral];\n            relatedEntities = Array.isArray(maybeRelatedEntities) ? maybeRelatedEntities as ObjectLiteral[] : (maybeRelatedEntities ? [maybeRelatedEntities as ObjectLiteral] : undefined);\n        }\n\n        // load relation ids depend of relation type\n        if (relation.isManyToMany) {\n            return this.loadForManyToMany(relation, entities, relatedEntities);\n\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);\n\n        } else { // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);\n        }\n    }\n\n    /**\n     * Loads relation ids of the given entities and groups them into the object with parent and children.\n     *\n     * todo: extract this method?\n     */\n    async loadManyToManyRelationIdsAndGroup<E1, E2>(\n        relation: RelationMetadata,\n        entitiesOrEntities: E1|E1[],\n        relatedEntityOrEntities?: E2|E2[]\n    ): Promise<{ entity: E1, related?: E2|E2[] }[]> {\n\n        // console.log(\"relation:\", relation.propertyName);\n        // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n        const isMany = relation.isManyToMany || relation.isOneToMany;\n        const entities: E1[] = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];\n\n        if (!relatedEntityOrEntities) {\n            relatedEntityOrEntities = await this.connection.relationLoader.load(relation, entitiesOrEntities);\n            if (!relatedEntityOrEntities.length)\n                return entities.map(entity => ({ entity: entity, related: isMany ? [] : undefined }));\n        }\n        // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n        const relationIds = await this.load(relation, entitiesOrEntities, relatedEntityOrEntities);\n        // console.log(\"relationIds\", relationIds);\n\n        const relatedEntities: E2[] = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities!];\n\n        let columns: ColumnMetadata[], inverseColumns: ColumnMetadata[];\n        if (relation.isManyToManyOwner) {\n            columns = relation.junctionEntityMetadata!.inverseColumns.map(column => column.referencedColumn!);\n            inverseColumns = relation.junctionEntityMetadata!.ownerColumns.map(column => column.referencedColumn!);\n\n        } else if (relation.isManyToManyNotOwner) {\n            columns = relation.junctionEntityMetadata!.ownerColumns.map(column => column.referencedColumn!);\n            inverseColumns = relation.junctionEntityMetadata!.inverseColumns.map(column => column.referencedColumn!);\n\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.joinColumns.map(column => column.referencedColumn!);\n            inverseColumns = relation.entityMetadata.primaryColumns;\n\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.entityMetadata.primaryColumns;\n            inverseColumns = relation.inverseRelation!.joinColumns.map(column => column.referencedColumn!);\n\n        } else {\n\n        }\n\n        return entities.map(entity => {\n            const group: { entity: E1, related?: E2|E2[] } = { entity: entity, related: isMany ? [] : undefined };\n            relationIds.forEach(relationId => {\n                const entityMatched = inverseColumns.every(column => {\n                    return column.getEntityValue(entity) === relationId[column.entityMetadata.name + \"_\" + column.propertyPath.replace(\".\", \"_\")];\n                });\n                if (entityMatched) {\n                    relatedEntities.forEach(relatedEntity => {\n                        const relatedEntityMatched = columns.every(column => {\n                            return column.getEntityValue(relatedEntity) === relationId[column.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.propertyPath.replace(\".\", \"_\")];\n                        });\n                        if (relatedEntityMatched) {\n                            if (isMany) {\n                                (group.related as E2[]).push(relatedEntity);\n                            } else {\n                                group.related = relatedEntity;\n                            }\n                        }\n                    });\n                }\n            });\n            return group;\n        });\n    }\n\n    /**\n     * Loads relation ids of the given entities and maps them into the given entity property.\n\n    async loadManyToManyRelationIdsAndMap(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral|ObjectLiteral[],\n        mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n        propertyName: string\n    ): Promise<void> {\n\n        const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n        const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n        const junctionMetadata = relation.junctionEntityMetadata!;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n        const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n\n        mapToEntities.forEach(mapToEntity => {\n            mapToEntity[propertyName] = [];\n            relationIds.forEach(relationId => {\n                const match = inverseColumns.every(column => {\n                    return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n                });\n                if (match) {\n                    if (columns.length === 1) {\n                        mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n\n                    } else {\n                        const value = {};\n                        columns.forEach(column => {\n                            column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                        });\n                        mapToEntity[propertyName].push(value);\n                    }\n                }\n            });\n        });\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids for the many-to-many relation.\n     */\n    protected loadForManyToMany(relation: RelationMetadata, entities: ObjectLiteral[], relatedEntities?: ObjectLiteral[]) {\n\n        const junctionMetadata = relation.junctionEntityMetadata!;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n        const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n        const qb = this.connection.createQueryBuilder();\n\n        // select all columns from junction table\n        junctionMetadata.ownerColumns.forEach(column => {\n            const columnName = column.referencedColumn!.entityMetadata.name + \"_\" + column.referencedColumn!.propertyPath.replace(\".\", \"_\");\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n        junctionMetadata.inverseColumns.forEach(column => {\n            const columnName = column.referencedColumn!.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn!.propertyPath.replace(\".\", \"_\");\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n\n        // add conditions for the given entities\n        let condition1 = \"\";\n        if (columns.length === 1) {\n            qb.setParameter(\"values1\", entities.map(entity => columns[0].referencedColumn!.getEntityValue(entity)));\n            condition1 = mainAlias + \".\" + columns[0].propertyPath + \" IN (:...values1)\"; // todo: use ANY for postgres\n\n        } else {\n            condition1 = \"(\" + entities.map((entity, entityIndex) => {\n                return columns.map(column => {\n                    const paramName = \"entity1_\" + entityIndex + \"_\" + column.propertyName;\n                    qb.setParameter(paramName, column.referencedColumn!.getEntityValue(entity));\n                    return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n                }).join(\" AND \");\n            }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n        }\n\n        // add conditions for the given inverse entities\n        let condition2 = \"\";\n        if (relatedEntities) {\n            if (inverseColumns.length === 1) {\n                qb.setParameter(\"values2\", relatedEntities.map(entity => inverseColumns[0].referencedColumn!.getEntityValue(entity)));\n                condition2 = mainAlias + \".\" + inverseColumns[0].propertyPath + \" IN (:...values2)\"; // todo: use ANY for postgres\n\n            } else {\n                condition2 = \"(\" + relatedEntities.map((entity, entityIndex) => {\n                    return inverseColumns.map(column => {\n                        const paramName = \"entity2_\" + entityIndex + \"_\" + column.propertyName;\n                        qb.setParameter(paramName, column.referencedColumn!.getEntityValue(entity));\n                        return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n                    }).join(\" AND \");\n                }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n            }\n        }\n\n        // execute query\n        return qb\n            .from(junctionMetadata.target, mainAlias)\n            .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"))\n            .getRawMany();\n    }\n\n    /**\n     * Loads relation ids for the many-to-one and one-to-one owner relations.\n     */\n    protected loadForManyToOneAndOneToOneOwner(relation: RelationMetadata, entities: ObjectLiteral[], relatedEntities?: ObjectLiteral[]) {\n        const mainAlias = relation.entityMetadata.targetName;\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder();\n        relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n            const columnName = primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n            qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n        });\n        relation.joinColumns.forEach(column => {\n            const columnName = column.referencedColumn!.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn!.propertyPath.replace(\".\", \"_\");\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n\n        // add condition for entities\n        let condition: string = \"\";\n        if (relation.entityMetadata.primaryColumns.length === 1) {\n            qb.setParameter(\"values\", entities.map(entity => relation.entityMetadata.primaryColumns[0].getEntityValue(entity)));\n            condition = mainAlias + \".\" + relation.entityMetadata.primaryColumns[0].propertyPath + \" IN (:...values)\";\n\n        } else {\n            condition = entities.map((entity, entityIndex) => {\n                return relation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n                    const paramName = \"entity\" + entityIndex + \"_\" + columnIndex;\n                    qb.setParameter(paramName, column.getEntityValue(entity));\n                    return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n                }).join(\" AND \");\n            }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n        }\n\n        // execute query\n        return qb.from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany();\n    }\n\n    /**\n     * Loads relation ids for the one-to-many and one-to-one not owner relations.\n     */\n    protected loadForOneToManyAndOneToOneNotOwner(relation: RelationMetadata, entities: ObjectLiteral[], relatedEntities?: ObjectLiteral[]) {\n        relation = relation.inverseRelation!;\n        const mainAlias = relation.entityMetadata.targetName;\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder();\n        relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n            const columnName = primaryColumn.entityMetadata.name + \"_\" + relation.inverseRelation!.propertyPath.replace(\".\", \"_\") + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n            qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n        });\n        relation.joinColumns.forEach(column => {\n            const columnName = column.referencedColumn!.entityMetadata.name + \"_\" + column.referencedColumn!.propertyPath.replace(\".\", \"_\");\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n\n        // add condition for entities\n        let condition: string = \"\";\n        if (relation.joinColumns.length === 1) {\n            qb.setParameter(\"values\", entities.map(entity => relation.joinColumns[0].referencedColumn!.getEntityValue(entity)));\n            condition = mainAlias + \".\" + relation.joinColumns[0].propertyPath + \" IN (:...values)\";\n\n        } else {\n            condition = entities.map((entity, entityIndex) => {\n                return relation.joinColumns.map((joinColumn, joinColumnIndex) => {\n                    const paramName = \"entity\" + entityIndex + \"_\" + joinColumnIndex;\n                    qb.setParameter(paramName, joinColumn.referencedColumn!.getEntityValue(entity));\n                    return mainAlias + \".\" + joinColumn.propertyPath + \" = :\" + paramName;\n                }).join(\" AND \");\n            }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n        }\n\n        // execute query\n        return qb.from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany();\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}