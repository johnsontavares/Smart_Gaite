{"ast":null,"code":"import { RelationIdAttribute } from \"./RelationIdAttribute\";\n\nvar RelationIdMetadataToAttributeTransformer =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RelationIdMetadataToAttributeTransformer(expressionMap) {\n    this.expressionMap = expressionMap;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  RelationIdMetadataToAttributeTransformer.prototype.transform = function () {\n    // by example:\n    // post has relation id:\n    // @RelationId(post => post.categories) categoryIds\n    // category has relation id\n    // @RelationId(category => category.images) imageIds\n    // we load post and join category\n    // we expect post.categoryIds and post.category.imageIds to have relation ids\n    var _this = this; // first create relation id attributes for all relation id metadatas of the main selected object (post from example)\n\n\n    if (this.expressionMap.mainAlias) {\n      this.expressionMap.mainAlias.metadata.relationIds.forEach(function (relationId) {\n        var attribute = _this.metadataToAttribute(_this.expressionMap.mainAlias.name, relationId);\n\n        _this.expressionMap.relationIdAttributes.push(attribute);\n      });\n    } // second create relation id attributes for all relation id metadatas of all joined objects (category from example)\n\n\n    this.expressionMap.joinAttributes.forEach(function (join) {\n      // ensure this join has a metadata, because relation id can only work for real orm entities\n      if (!join.metadata || join.metadata.isJunction) return;\n      join.metadata.relationIds.forEach(function (relationId) {\n        var attribute = _this.metadataToAttribute(join.alias.name, relationId);\n\n        _this.expressionMap.relationIdAttributes.push(attribute);\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n\n  RelationIdMetadataToAttributeTransformer.prototype.metadataToAttribute = function (parentAliasName, relationId) {\n    return new RelationIdAttribute(this.expressionMap, {\n      relationName: parentAliasName + \".\" + relationId.relation.propertyName,\n      mapToProperty: parentAliasName + \".\" + relationId.propertyName,\n      alias: relationId.alias,\n      queryBuilderFactory: relationId.queryBuilderFactory\n    });\n  };\n\n  return RelationIdMetadataToAttributeTransformer;\n}();\n\nexport { RelationIdMetadataToAttributeTransformer };","map":{"version":3,"sources":["../browser/src/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.ts"],"names":[],"mappings":"AAAA,SAAQ,mBAAR,QAAkC,uBAAlC;;AAIA,IAAA,wCAAA;AAAA;AAAA,YAAA;AAEI;AACA;AACA;AAEA,WAAA,wCAAA,CAAsB,aAAtB,EAAuD;AAAjC,SAAA,aAAA,GAAA,aAAA;AACrB,GAPL,CASI;AACA;AACA;;;AAEA,EAAA,wCAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AAEI;AACA;AACA;AACA;AACA;AACA;AACA;AARJ,QAAA,KAAA,GAAA,IAAA,CAAA,CAUI;;;AACA,QAAI,KAAK,aAAL,CAAmB,SAAvB,EAAkC;AAC9B,WAAK,aAAL,CAAmB,SAAnB,CAA6B,QAA7B,CAAsC,WAAtC,CAAkD,OAAlD,CAA0D,UAAA,UAAA,EAAU;AAChE,YAAM,SAAS,GAAG,KAAI,CAAC,mBAAL,CAAyB,KAAI,CAAC,aAAL,CAAmB,SAAnB,CAA8B,IAAvD,EAA6D,UAA7D,CAAlB;;AACA,QAAA,KAAI,CAAC,aAAL,CAAmB,oBAAnB,CAAwC,IAAxC,CAA6C,SAA7C;AACH,OAHD;AAIH,KAhBL,CAkBI;;;AACA,SAAK,aAAL,CAAmB,cAAnB,CAAkC,OAAlC,CAA0C,UAAA,IAAA,EAAI;AAE1C;AACA,UAAI,CAAC,IAAI,CAAC,QAAN,IAAkB,IAAI,CAAC,QAAL,CAAc,UAApC,EACI;AAEJ,MAAA,IAAI,CAAC,QAAL,CAAc,WAAd,CAA0B,OAA1B,CAAkC,UAAA,UAAA,EAAU;AACxC,YAAM,SAAS,GAAG,KAAI,CAAC,mBAAL,CAAyB,IAAI,CAAC,KAAL,CAAW,IAApC,EAA0C,UAA1C,CAAlB;;AACA,QAAA,KAAI,CAAC,aAAL,CAAmB,oBAAnB,CAAwC,IAAxC,CAA6C,SAA7C;AACH,OAHD;AAIH,KAVD;AAWH,GA9BD,CAbJ,CA6CI;AACA;AACA;;;AAEQ,EAAA,wCAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,eAA5B,EAAqD,UAArD,EAAmF;AAC/E,WAAO,IAAI,mBAAJ,CAAwB,KAAK,aAA7B,EAA4C;AAC/C,MAAA,YAAY,EAAE,eAAe,GAAG,GAAlB,GAAwB,UAAU,CAAC,QAAX,CAAoB,YADX;AAE/C,MAAA,aAAa,EAAE,eAAe,GAAG,GAAlB,GAAwB,UAAU,CAAC,YAFH;AAG/C,MAAA,KAAK,EAAE,UAAU,CAAC,KAH6B;AAI/C,MAAA,mBAAmB,EAAE,UAAU,CAAC;AAJe,KAA5C,CAAP;AAMH,GAPO;;AASZ,SAAA,wCAAA;AAAC,CA1DD,EAAA","sourcesContent":["import {RelationIdAttribute} from \"./RelationIdAttribute\";\nimport {QueryExpressionMap} from \"../QueryExpressionMap\";\nimport {RelationIdMetadata} from \"../../metadata/RelationIdMetadata\";\n\nexport class RelationIdMetadataToAttributeTransformer {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected expressionMap: QueryExpressionMap) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform() {\n\n        // by example:\n        // post has relation id:\n        // @RelationId(post => post.categories) categoryIds\n        // category has relation id\n        // @RelationId(category => category.images) imageIds\n        // we load post and join category\n        // we expect post.categoryIds and post.category.imageIds to have relation ids\n\n        // first create relation id attributes for all relation id metadatas of the main selected object (post from example)\n        if (this.expressionMap.mainAlias) {\n            this.expressionMap.mainAlias.metadata.relationIds.forEach(relationId => {\n                const attribute = this.metadataToAttribute(this.expressionMap.mainAlias!.name, relationId);\n                this.expressionMap.relationIdAttributes.push(attribute);\n            });\n        }\n\n        // second create relation id attributes for all relation id metadatas of all joined objects (category from example)\n        this.expressionMap.joinAttributes.forEach(join => {\n\n            // ensure this join has a metadata, because relation id can only work for real orm entities\n            if (!join.metadata || join.metadata.isJunction)\n                return;\n\n            join.metadata.relationIds.forEach(relationId => {\n                const attribute = this.metadataToAttribute(join.alias.name, relationId);\n                this.expressionMap.relationIdAttributes.push(attribute);\n            });\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private metadataToAttribute(parentAliasName: string, relationId: RelationIdMetadata): RelationIdAttribute {\n        return new RelationIdAttribute(this.expressionMap, {\n            relationName: parentAliasName + \".\" + relationId.relation.propertyName, // category.images\n            mapToProperty: parentAliasName + \".\" + relationId.propertyName, // category.imageIds\n            alias: relationId.alias,\n            queryBuilderFactory: relationId.queryBuilderFactory\n        });\n    }\n\n}"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}