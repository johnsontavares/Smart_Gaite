{"ast":null,"code":"import { __read } from \"tslib\";\nimport { Subject } from \"../Subject\";\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\n\nvar CascadesSubjectBuilder =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function CascadesSubjectBuilder(allSubjects) {\n    this.allSubjects = allSubjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n   */\n\n\n  CascadesSubjectBuilder.prototype.build = function (subject, operationType) {\n    var _this = this;\n\n    subject.metadata.extractRelationValuesFromEntity(subject.entity, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\n    .forEach(function (_a) {\n      var _b = __read(_a, 3),\n          relation = _b[0],\n          relationEntity = _b[1],\n          relationEntityMetadata = _b[2]; // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n\n\n      if (relationEntity === undefined || relationEntity === null || !relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover) return; // if relation entity is just a relation id set (for example post.tag = 1)\n      // then we don't really need to check cascades since there is no object to insert or update\n\n      if (!(relationEntity instanceof Object)) return; // if we already has this entity in list of operated subjects then skip it to avoid recursion\n\n      var alreadyExistRelationEntitySubject = _this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\n\n      if (alreadyExistRelationEntitySubject) {\n        if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet\n          alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === \"save\";\n        if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet\n          alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === \"save\";\n        if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false) // if its not marked for removal yet\n          alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === \"soft-remove\";\n        if (alreadyExistRelationEntitySubject.canBeRecovered === false) // if its not marked for recovery yet\n          alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === \"recover\";\n        return;\n      } // mark subject with what we can do with it\n      // and add to the array of subjects to load only if there is no same entity there already\n\n\n      var relationEntitySubject = new Subject({\n        metadata: relationEntityMetadata,\n        parentSubject: subject,\n        entity: relationEntity,\n        canBeInserted: relation.isCascadeInsert === true && operationType === \"save\",\n        canBeUpdated: relation.isCascadeUpdate === true && operationType === \"save\",\n        canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === \"soft-remove\",\n        canBeRecovered: relation.isCascadeRecover === true && operationType === \"recover\"\n      });\n\n      _this.allSubjects.push(relationEntitySubject); // go recursively and find other entities we need to insert/update\n\n\n      _this.build(relationEntitySubject, operationType);\n    });\n  }; // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Finds subject where entity like given subject's entity.\n   * Comparision made by entity id.\n   */\n\n\n  CascadesSubjectBuilder.prototype.findByPersistEntityLike = function (entityTarget, entity) {\n    return this.allSubjects.find(function (subject) {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  };\n\n  return CascadesSubjectBuilder;\n}();\n\nexport { CascadesSubjectBuilder };","map":{"version":3,"sources":["../browser/src/persistence/subject-builder/CascadesSubjectBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"../Subject\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\n\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\nexport class CascadesSubjectBuilder {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected allSubjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n     */\n    build(subject: Subject, operationType: \"save\"|\"remove\"|\"soft-remove\"|\"recover\") {\n\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity!, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n\n                // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n                if (relationEntity === undefined ||\n                    relationEntity === null ||\n                    (!relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover))\n                    return;\n\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we don't really need to check cascades since there is no object to insert or update\n                if (!(relationEntity instanceof Object))\n                    return;\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\n                if (alreadyExistRelationEntitySubject) {\n                    if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet\n                        alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === \"save\";\n                    if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet\n                        alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === \"save\";\n                    if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false) // if its not marked for removal yet\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === \"soft-remove\";\n                    if (alreadyExistRelationEntitySubject.canBeRecovered === false) // if its not marked for recovery yet\n                        alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === \"recover\";\n                    return;\n                }\n\n                // mark subject with what we can do with it\n                // and add to the array of subjects to load only if there is no same entity there already\n                const relationEntitySubject = new Subject({\n                    metadata: relationEntityMetadata,\n                    parentSubject: subject,\n                    entity: relationEntity,\n                    canBeInserted: relation.isCascadeInsert === true && operationType === \"save\",\n                    canBeUpdated: relation.isCascadeUpdate === true && operationType === \"save\",\n                    canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === \"soft-remove\",\n                    canBeRecovered: relation.isCascadeRecover === true && operationType === \"recover\"\n                });\n                this.allSubjects.push(relationEntitySubject);\n\n                // go recursively and find other entities we need to insert/update\n                this.build(relationEntitySubject, operationType);\n            });\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparision made by entity id.\n     */\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.allSubjects.find(subject => {\n            if (!subject.entity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds!, entity);\n        });\n    }\n\n}"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}