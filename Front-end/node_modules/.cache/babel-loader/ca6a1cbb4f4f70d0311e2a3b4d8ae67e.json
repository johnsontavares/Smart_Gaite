{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray, __values } from \"tslib\";\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\n\nvar SubjectDatabaseEntityLoader =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function SubjectDatabaseEntityLoader(queryRunner, subjects) {\n    this.queryRunner = queryRunner;\n    this.subjects = subjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Loads database entities for all subjects.\n   *\n   * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n   * This option is used for deletion.\n   */\n\n\n  SubjectDatabaseEntityLoader.prototype.load = function (operationType) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promises;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            promises = this.groupByEntityTargets().map(function (subjectGroup) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var allIds, allSubjects, loadRelationPropertyPaths, findOptions, entities, allSubjects_1, allSubjects_1_1, subject;\n\n                var e_1, _a;\n\n                var _this = this;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      allIds = [];\n                      allSubjects = [];\n                      subjectGroup.subjects.forEach(function (subject) {\n                        // we don't load if subject already has a database entity loaded\n                        if (subject.databaseEntity || !subject.identifier) return;\n                        allIds.push(subject.identifier);\n                        allSubjects.push(subject);\n                      }); // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n\n                      if (!allIds.length) return [2\n                      /*return*/\n                      ];\n                      loadRelationPropertyPaths = []; // for the save, soft-remove and recover operation\n                      // extract all property paths of the relations we need to load relation ids for\n                      // this is for optimization purpose - this way we don't load relation ids for entities\n                      // whose relations are undefined, and since they are undefined its really pointless to\n                      // load something for them, since undefined properties are skipped by the orm\n\n                      if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n                        subjectGroup.subjects.forEach(function (subject) {\n                          // gets all relation property paths that exist in the persisted entity.\n                          subject.metadata.relations.forEach(function (relation) {\n                            var value = relation.getEntityValue(subject.entityWithFulfilledIds);\n                            if (value === undefined) return;\n                            if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1) loadRelationPropertyPaths.push(relation.propertyPath);\n                          });\n                        });\n                      } else {\n                        // remove\n                        // for remove operation\n                        // we only need to load junction relation ids since only they are removed by cascades\n                        loadRelationPropertyPaths.push.apply( // remove\n                        loadRelationPropertyPaths, __spreadArray([], __read(subjectGroup.subjects[0].metadata.manyToManyRelations.map(function (relation) {\n                          return relation.propertyPath;\n                        }))));\n                      }\n\n                      findOptions = {\n                        loadEagerRelations: false,\n                        loadRelationIds: {\n                          relations: loadRelationPropertyPaths,\n                          disableMixedMap: true\n                        },\n                        // the soft-deleted entities should be included in the loaded entities for recover operation\n                        withDeleted: true\n                      };\n                      return [4\n                      /*yield*/\n                      , this.queryRunner.manager.getRepository(subjectGroup.target).findByIds(allIds, findOptions)];\n\n                    case 1:\n                      entities = _b.sent(); // now when we have entities we need to find subject of each entity\n                      // and insert that entity into database entity of the found subjects\n\n                      entities.forEach(function (entity) {\n                        var subjects = _this.findByPersistEntityLike(subjectGroup.target, entity);\n\n                        subjects.forEach(function (subject) {\n                          subject.databaseEntity = entity;\n                          if (!subject.identifier) subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n                        });\n                      });\n\n                      try {\n                        // this way we tell what subjects we tried to load database entities of\n                        for (allSubjects_1 = __values(allSubjects), allSubjects_1_1 = allSubjects_1.next(); !allSubjects_1_1.done; allSubjects_1_1 = allSubjects_1.next()) {\n                          subject = allSubjects_1_1.value;\n                          subject.databaseEntityLoaded = true;\n                        }\n                      } catch (e_1_1) {\n                        e_1 = {\n                          error: e_1_1\n                        };\n                      } finally {\n                        try {\n                          if (allSubjects_1_1 && !allSubjects_1_1.done && (_a = allSubjects_1.return)) _a.call(allSubjects_1);\n                        } finally {\n                          if (e_1) throw e_1.error;\n                        }\n                      }\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            });\n            return [4\n            /*yield*/\n            , Promise.all(promises)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Finds subjects where entity like given subject's entity.\n   * Comparision made by entity id.\n   * Multiple subjects may be returned if duplicates are present in the subject array.\n   * This will likely result in the same row being updated multiple times during a transaction.\n   */\n\n\n  SubjectDatabaseEntityLoader.prototype.findByPersistEntityLike = function (entityTarget, entity) {\n    return this.subjects.filter(function (subject) {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  };\n  /**\n   * Groups given Subject objects into groups separated by entity targets.\n   */\n\n\n  SubjectDatabaseEntityLoader.prototype.groupByEntityTargets = function () {\n    return this.subjects.reduce(function (groups, operatedEntity) {\n      var group = groups.find(function (group) {\n        return group.target === operatedEntity.metadata.target;\n      });\n\n      if (!group) {\n        group = {\n          target: operatedEntity.metadata.target,\n          subjects: []\n        };\n        groups.push(group);\n      }\n\n      group.subjects.push(operatedEntity);\n      return groups;\n    }, []);\n  };\n\n  return SubjectDatabaseEntityLoader;\n}();\n\nexport { SubjectDatabaseEntityLoader };","map":{"version":3,"sources":["../browser/src/persistence/SubjectDatabaseEntityLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"./Subject\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {FindManyOptions} from \"../find-options/FindManyOptions\";\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner,\n                protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(operationType: \"save\"|\"remove\"|\"soft-remove\"|\"recover\"): Promise<void> {\n\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\n\n            // prepare entity ids of the subjects we need to load\n            const allIds: ObjectLiteral[] = [];\n            const allSubjects: Subject[] = [];\n            subjectGroup.subjects.forEach(subject => {\n\n                // we don't load if subject already has a database entity loaded\n                if (subject.databaseEntity || !subject.identifier)\n                    return;\n\n                allIds.push(subject.identifier);\n                allSubjects.push(subject);\n            });\n\n            // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n            if (!allIds.length)\n                return;\n\n            const loadRelationPropertyPaths: string[] = [];\n\n            // for the save, soft-remove and recover operation\n            // extract all property paths of the relations we need to load relation ids for\n            // this is for optimization purpose - this way we don't load relation ids for entities\n            // whose relations are undefined, and since they are undefined its really pointless to\n            // load something for them, since undefined properties are skipped by the orm\n            if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n                subjectGroup.subjects.forEach(subject => {\n\n                    // gets all relation property paths that exist in the persisted entity.\n                    subject.metadata.relations.forEach(relation => {\n                        const value = relation.getEntityValue(subject.entityWithFulfilledIds!);\n                        if (value === undefined)\n                            return;\n\n                        if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1)\n                            loadRelationPropertyPaths.push(relation.propertyPath);\n                    });\n                });\n            } else { // remove\n\n                // for remove operation\n                // we only need to load junction relation ids since only they are removed by cascades\n                loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n            }\n\n            const findOptions: FindManyOptions<any> = {\n                loadEagerRelations: false,\n                loadRelationIds: {\n                    relations: loadRelationPropertyPaths,\n                    disableMixedMap: true\n                },\n                // the soft-deleted entities should be included in the loaded entities for recover operation\n                withDeleted: true\n            };\n\n            // load database entities for all given ids\n            const entities = await this.queryRunner.manager\n                .getRepository<ObjectLiteral>(subjectGroup.target)\n                .findByIds(allIds, findOptions);\n\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subjects\n            entities.forEach(entity => {\n                const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);\n                subjects.forEach(subject => {\n                  subject.databaseEntity = entity;\n                  if (!subject.identifier)\n                      subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n                });\n            });\n\n            // this way we tell what subjects we tried to load database entities of\n            for (let subject of allSubjects) {\n                subject.databaseEntityLoaded = true;\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subjects where entity like given subject's entity.\n     * Comparision made by entity id.\n     * Multiple subjects may be returned if duplicates are present in the subject array.\n     * This will likely result in the same row being updated multiple times during a transaction.\n     */\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject[] {\n        return this.subjects.filter(subject => {\n            if (!subject.entity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds!, entity);\n        });\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(group => group.target === operatedEntity.metadata.target);\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}