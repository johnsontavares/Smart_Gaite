{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\n\nvar Subject =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function Subject(options) {\n    var _a;\n    /**\n     * Subject identifier.\n     * This identifier is not limited to table entity primary columns.\n     * This can be entity id or ids as well as some unique entity properties, like name or title.\n     * Insert / Update / Remove operation will be executed by a given identifier.\n     */\n\n\n    this.identifier = undefined;\n    /**\n     * Copy of entity but with relational ids fulfilled.\n     */\n\n    this.entityWithFulfilledIds = undefined;\n    /**\n     * Indicates if database entity was loaded.\n     * No matter if it was found or not, it indicates the fact of loading.\n     */\n\n    this.databaseEntityLoaded = false;\n    /**\n     * Changes needs to be applied in the database for the given subject.\n     */\n\n    this.changeMaps = [];\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n\n    this.canBeInserted = false;\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n\n    this.canBeUpdated = false;\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n\n    this.mustBeRemoved = false;\n    /**\n     * Indicates if this subject can be soft-removed from the database.\n     * This means that this subject either was soft-removed, either was soft-removed by cascades.\n     */\n\n    this.canBeSoftRemoved = false;\n    /**\n     * Indicates if this subject can be recovered from the database.\n     * This means that this subject either was recovered, either was recovered by cascades.\n     */\n\n    this.canBeRecovered = false;\n    /**\n     * Relations updated by the change maps.\n     */\n\n    this.updatedRelationMaps = [];\n    /**\n     * List of updated columns\n     */\n\n    this.diffColumns = [];\n    /**\n     * List of updated relations\n     */\n\n    this.diffRelations = [];\n    this.metadata = options.metadata;\n    this.entity = options.entity;\n    this.parentSubject = options.parentSubject;\n    if (options.canBeInserted !== undefined) this.canBeInserted = options.canBeInserted;\n    if (options.canBeUpdated !== undefined) this.canBeUpdated = options.canBeUpdated;\n    if (options.mustBeRemoved !== undefined) this.mustBeRemoved = options.mustBeRemoved;\n    if (options.canBeSoftRemoved !== undefined) this.canBeSoftRemoved = options.canBeSoftRemoved;\n    if (options.canBeRecovered !== undefined) this.canBeRecovered = options.canBeRecovered;\n    if (options.identifier !== undefined) this.identifier = options.identifier;\n    if (options.changeMaps !== undefined) (_a = this.changeMaps).push.apply(_a, __spreadArray([], __read(options.changeMaps)));\n    this.recompute();\n  }\n\n  Object.defineProperty(Subject.prototype, \"mustBeInserted\", {\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if this subject must be inserted into the database.\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n     * and if it does not have database entity set.\n     */\n    get: function () {\n      return this.canBeInserted && !this.databaseEntity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Subject.prototype, \"mustBeUpdated\", {\n    /**\n     * Checks if this subject must be updated into the database.\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get: function () {\n      return this.canBeUpdated && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity) && // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&\n      this.changeMaps.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Subject.prototype, \"mustBeSoftRemoved\", {\n    /**\n     * Checks if this subject must be soft-removed into the database.\n     * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get: function () {\n      return this.canBeSoftRemoved && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Subject.prototype, \"mustBeRecovered\", {\n    /**\n     * Checks if this subject must be recovered into the database.\n     * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get: function () {\n      return this.canBeRecovered && this.identifier && (this.databaseEntityLoaded === false || this.databaseEntityLoaded && this.databaseEntity);\n    },\n    enumerable: false,\n    configurable: true\n  }); // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a value set needs to be inserted / updated in the database.\n   * Value set is based on the entity and change maps of the subject.\n   * Important note: this method pops data from this subject's change maps.\n   */\n\n  Subject.prototype.createValueSetAndPopChangeMap = function () {\n    var _this = this;\n\n    var changeMapsWithoutValues = [];\n    var changeSet = this.changeMaps.reduce(function (updateMap, changeMap) {\n      var value = changeMap.value;\n\n      if (value instanceof Subject) {\n        // referenced columns can refer on values both which were just inserted and which were present in the model\n        // if entity was just inserted valueSets must contain all values from the entity and values just inserted in the database\n        // so, here we check if we have a value set then we simply use it as value to get our reference column values\n        // otherwise simply use an entity which cannot be just inserted at the moment and have all necessary data\n        value = value.insertedValueSet ? value.insertedValueSet : value.entity;\n      } // value = changeMap.valueFactory ? changeMap.valueFactory(value) : changeMap.column.createValueMap(value);\n\n\n      var valueMap;\n\n      if (_this.metadata.isJunction && changeMap.column) {\n        valueMap = changeMap.column.createValueMap(changeMap.column.referencedColumn.getEntityValue(value));\n      } else if (changeMap.column) {\n        valueMap = changeMap.column.createValueMap(value);\n      } else if (changeMap.relation) {\n        // value can be a related object, for example: post.question = { id: 1 }\n        // or value can be a null or direct relation id, e.g. post.question = 1\n        // if its a direction relation id then we just set it to the valueMap,\n        // however if its an object then we need to extract its relation id map and set it to the valueMap\n        if (value instanceof Object) {\n          // get relation id, e.g. referenced column name and its value,\n          // for example: { id: 1 } which then will be set to relation, e.g. post.category = { id: 1 }\n          var relationId = changeMap.relation.getRelationIdMap(value); // but relation id can be empty, for example in the case when you insert a new post with category\n          // and both post and category are newly inserted objects (by cascades) and in this case category will not have id\n          // this means we need to insert post without question id and update post's questionId once question be inserted\n          // that's why we create a new changeMap operation for future updation of the post entity\n\n          if (relationId === undefined) {\n            changeMapsWithoutValues.push(changeMap);\n            _this.canBeUpdated = true;\n            return updateMap;\n          }\n\n          valueMap = changeMap.relation.createValueMap(relationId);\n\n          _this.updatedRelationMaps.push({\n            relation: changeMap.relation,\n            value: relationId\n          });\n        } else {\n          // value can be \"null\" or direct relation id here\n          valueMap = changeMap.relation.createValueMap(value);\n\n          _this.updatedRelationMaps.push({\n            relation: changeMap.relation,\n            value: value\n          });\n        }\n      }\n\n      OrmUtils.mergeDeep(updateMap, valueMap);\n      return updateMap;\n    }, {});\n    this.changeMaps = changeMapsWithoutValues;\n    return changeSet;\n  };\n  /**\n   * Recomputes entityWithFulfilledIds and identifier when entity changes.\n   */\n\n\n  Subject.prototype.recompute = function () {\n    var _this = this;\n\n    if (this.entity) {\n      this.entityWithFulfilledIds = Object.assign({}, this.entity);\n\n      if (this.parentSubject) {\n        this.metadata.primaryColumns.forEach(function (primaryColumn) {\n          if (primaryColumn.relationMetadata && primaryColumn.relationMetadata.inverseEntityMetadata === _this.parentSubject.metadata) {\n            var value = primaryColumn.referencedColumn.getEntityValue(_this.parentSubject.entity);\n            primaryColumn.setEntityValue(_this.entityWithFulfilledIds, value);\n          }\n        });\n      }\n\n      this.identifier = this.metadata.getEntityIdMap(this.entityWithFulfilledIds);\n    } else if (this.databaseEntity) {\n      this.identifier = this.metadata.getEntityIdMap(this.databaseEntity);\n    }\n  };\n\n  return Subject;\n}();\n\nexport { Subject };","map":{"version":3,"sources":["../browser/src/persistence/Subject.ts"],"names":[],"mappings":"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","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {SubjectChangeMap} from \"./SubjectChangeMap\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\n\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\nexport class Subject {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the subject entity.\n     */\n    metadata: EntityMetadata;\n\n    /**\n     * Subject identifier.\n     * This identifier is not limited to table entity primary columns.\n     * This can be entity id or ids as well as some unique entity properties, like name or title.\n     * Insert / Update / Remove operation will be executed by a given identifier.\n     */\n    identifier: ObjectLiteral|undefined = undefined;\n\n    /**\n     * Copy of entity but with relational ids fulfilled.\n     */\n    entityWithFulfilledIds: ObjectLiteral|undefined = undefined;\n\n    /**\n     * If subject was created by cascades this property will contain subject\n     * from where this subject was created.\n     */\n    parentSubject?: Subject;\n\n    /**\n     * Gets entity sent to the persistence (e.g. changed entity).\n     * If entity is not set then this subject is created only for the entity loaded from the database,\n     * or this subject is used for the junction operation (junction operations are relying only on identifier).\n     */\n    entity?: ObjectLiteral;\n\n    /**\n     * Database entity.\n     * THIS IS NOT RAW ENTITY DATA, its a real entity.\n     */\n    databaseEntity?: ObjectLiteral;\n\n    /**\n     * Indicates if database entity was loaded.\n     * No matter if it was found or not, it indicates the fact of loading.\n     */\n    databaseEntityLoaded: boolean = false;\n\n    /**\n     * Changes needs to be applied in the database for the given subject.\n     */\n    changeMaps: SubjectChangeMap[] = [];\n\n    /**\n     * Generated values returned by a database (for example generated id or default values).\n     * Used in insert and update operations.\n     * Has entity-like structure (not just column database name and values).\n     */\n    generatedMap?: ObjectLiteral;\n\n    /**\n     * Inserted values with updated values of special and default columns.\n     * Has entity-like structure (not just column database name and values).\n     */\n    insertedValueSet?: ObjectLiteral;\n\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n    canBeInserted: boolean = false;\n\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n    canBeUpdated: boolean = false;\n\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n    mustBeRemoved: boolean = false;\n\n    /**\n     * Indicates if this subject can be soft-removed from the database.\n     * This means that this subject either was soft-removed, either was soft-removed by cascades.\n     */\n    canBeSoftRemoved: boolean = false;\n\n    /**\n     * Indicates if this subject can be recovered from the database.\n     * This means that this subject either was recovered, either was recovered by cascades.\n     */\n    canBeRecovered: boolean = false;\n\n    /**\n     * Relations updated by the change maps.\n     */\n    updatedRelationMaps: { relation: RelationMetadata, value: ObjectLiteral }[] = [];\n\n    /**\n     * List of updated columns\n     */\n    diffColumns: ColumnMetadata[] = [];\n\n    /**\n     * List of updated relations\n     */\n    diffRelations: RelationMetadata[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: {\n        metadata: EntityMetadata,\n        parentSubject?: Subject,\n        entity?: ObjectLiteral,\n        canBeInserted?: boolean,\n        canBeUpdated?: boolean,\n        mustBeRemoved?: boolean,\n        canBeSoftRemoved?: boolean,\n        canBeRecovered?: boolean,\n        identifier?: ObjectLiteral,\n        changeMaps?: SubjectChangeMap[]\n    }) {\n        this.metadata = options.metadata;\n        this.entity = options.entity;\n        this.parentSubject = options.parentSubject;\n        if (options.canBeInserted !== undefined)\n            this.canBeInserted = options.canBeInserted;\n        if (options.canBeUpdated !== undefined)\n            this.canBeUpdated = options.canBeUpdated;\n        if (options.mustBeRemoved !== undefined)\n            this.mustBeRemoved = options.mustBeRemoved;\n        if (options.canBeSoftRemoved !== undefined)\n            this.canBeSoftRemoved = options.canBeSoftRemoved;\n        if (options.canBeRecovered !== undefined)\n            this.canBeRecovered = options.canBeRecovered;\n        if (options.identifier !== undefined)\n            this.identifier = options.identifier;\n        if (options.changeMaps !== undefined)\n            this.changeMaps.push(...options.changeMaps);\n\n        this.recompute();\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if this subject must be inserted into the database.\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n     * and if it does not have database entity set.\n     */\n    get mustBeInserted() {\n        return this.canBeInserted && !this.databaseEntity;\n    }\n\n    /**\n     * Checks if this subject must be updated into the database.\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeUpdated() {\n        return this.canBeUpdated &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false || (this.databaseEntityLoaded && this.databaseEntity)) &&\n            // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&\n            this.changeMaps.length > 0;\n    }\n\n    /**\n     * Checks if this subject must be soft-removed into the database.\n     * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeSoftRemoved() {\n        return this.canBeSoftRemoved &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false || (this.databaseEntityLoaded && this.databaseEntity));\n    }\n\n    /**\n     * Checks if this subject must be recovered into the database.\n     * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeRecovered() {\n        return this.canBeRecovered &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false || (this.databaseEntityLoaded && this.databaseEntity));\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a value set needs to be inserted / updated in the database.\n     * Value set is based on the entity and change maps of the subject.\n     * Important note: this method pops data from this subject's change maps.\n     */\n    createValueSetAndPopChangeMap(): ObjectLiteral {\n        const changeMapsWithoutValues: SubjectChangeMap[] = [];\n        const changeSet = this.changeMaps.reduce((updateMap, changeMap) => {\n            let value = changeMap.value;\n            if (value instanceof Subject) {\n\n                // referenced columns can refer on values both which were just inserted and which were present in the model\n                // if entity was just inserted valueSets must contain all values from the entity and values just inserted in the database\n                // so, here we check if we have a value set then we simply use it as value to get our reference column values\n                // otherwise simply use an entity which cannot be just inserted at the moment and have all necessary data\n                value = value.insertedValueSet ? value.insertedValueSet : value.entity;\n            }\n            // value = changeMap.valueFactory ? changeMap.valueFactory(value) : changeMap.column.createValueMap(value);\n\n            let valueMap: ObjectLiteral|undefined;\n            if (this.metadata.isJunction && changeMap.column) {\n                valueMap = changeMap.column.createValueMap(changeMap.column.referencedColumn!.getEntityValue(value));\n\n            } else if (changeMap.column) {\n                valueMap = changeMap.column.createValueMap(value);\n\n            } else if (changeMap.relation) {\n\n                // value can be a related object, for example: post.question = { id: 1 }\n                // or value can be a null or direct relation id, e.g. post.question = 1\n                // if its a direction relation id then we just set it to the valueMap,\n                // however if its an object then we need to extract its relation id map and set it to the valueMap\n                if (value instanceof Object) {\n\n                    // get relation id, e.g. referenced column name and its value,\n                    // for example: { id: 1 } which then will be set to relation, e.g. post.category = { id: 1 }\n                    const relationId = changeMap.relation!.getRelationIdMap(value);\n\n                    // but relation id can be empty, for example in the case when you insert a new post with category\n                    // and both post and category are newly inserted objects (by cascades) and in this case category will not have id\n                    // this means we need to insert post without question id and update post's questionId once question be inserted\n                    // that's why we create a new changeMap operation for future updation of the post entity\n                    if (relationId === undefined) {\n                        changeMapsWithoutValues.push(changeMap);\n                        this.canBeUpdated = true;\n                        return updateMap;\n                    }\n                    valueMap = changeMap.relation!.createValueMap(relationId);\n                    this.updatedRelationMaps.push({ relation: changeMap.relation, value: relationId });\n\n                } else { // value can be \"null\" or direct relation id here\n                    valueMap = changeMap.relation!.createValueMap(value);\n                    this.updatedRelationMaps.push({ relation: changeMap.relation, value: value });\n                }\n            }\n\n            OrmUtils.mergeDeep(updateMap, valueMap);\n            return updateMap;\n        }, {} as ObjectLiteral);\n        this.changeMaps = changeMapsWithoutValues;\n        return changeSet;\n    }\n\n    /**\n     * Recomputes entityWithFulfilledIds and identifier when entity changes.\n     */\n    recompute(): void {\n\n        if (this.entity) {\n            this.entityWithFulfilledIds = Object.assign({}, this.entity);\n            if (this.parentSubject) {\n                this.metadata.primaryColumns.forEach(primaryColumn => {\n                    if (primaryColumn.relationMetadata && primaryColumn.relationMetadata.inverseEntityMetadata === this.parentSubject!.metadata) {\n                        const value = primaryColumn.referencedColumn!.getEntityValue(this.parentSubject!.entity!);\n                        primaryColumn.setEntityValue(this.entityWithFulfilledIds!, value);\n                    }\n                });\n            }\n            this.identifier = this.metadata.getEntityIdMap(this.entityWithFulfilledIds);\n\n        } else if (this.databaseEntity) {\n            this.identifier = this.metadata.getEntityIdMap(this.databaseEntity);\n        }\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}