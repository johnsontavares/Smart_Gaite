{"ast":null,"code":"import { __awaiter, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { SqlServerDriver } from \"../../driver/sqlserver/SqlServerDriver\";\n/**\n * Executes subject operations for closure entities.\n */\n\nvar ClosureSubjectExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function ClosureSubjectExecutor(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes operations when subject is being inserted.\n   */\n\n\n  ClosureSubjectExecutor.prototype.insert = function (subject) {\n    return __awaiter(this, void 0, void 0, function () {\n      var closureJunctionInsertMap, parent, escape_1, tableName, queryParams_1, ancestorColumnNames, descendantColumnNames, childEntityIds1, whereCondition;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            closureJunctionInsertMap = {};\n            subject.metadata.closureJunctionTable.ancestorColumns.forEach(function (column) {\n              closureJunctionInsertMap[column.databaseName] = subject.identifier;\n            });\n            subject.metadata.closureJunctionTable.descendantColumns.forEach(function (column) {\n              closureJunctionInsertMap[column.databaseName] = subject.identifier;\n            }); // insert values into the closure junction table\n\n            return [4\n            /*yield*/\n            , this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute()];\n\n          case 1:\n            // insert values into the closure junction table\n            _a.sent();\n\n            parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);\n            if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n              parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n            if (!parent) return [3\n            /*break*/\n            , 3];\n\n            escape_1 = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n            queryParams_1 = [];\n            ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(function (column) {\n              return escape_1(column.databaseName);\n            });\n            descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map(function (column) {\n              return escape_1(column.databaseName);\n            });\n            childEntityIds1 = subject.metadata.primaryColumns.map(function (column) {\n              queryParams_1.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));\n              return _this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams_1.length - 1);\n            });\n            whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(function (column) {\n              var columnName = escape_1(column.databaseName);\n              var parentId = column.referencedColumn.getEntityValue(parent);\n              if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n              queryParams_1.push(parentId);\n\n              var parameterName = _this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams_1.length - 1);\n\n              return columnName + \" = \" + parameterName;\n            });\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"INSERT INTO \" + tableName + \" (\" + __spreadArray(__spreadArray([], __read(ancestorColumnNames)), __read(descendantColumnNames)).join(\", \") + \") \" + (\"SELECT \" + ancestorColumnNames.join(\", \") + \", \" + childEntityIds1.join(\", \") + \" FROM \" + tableName + \" WHERE \" + whereCondition.join(\" AND \")), queryParams_1)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Executes operations when subject is being updated.\n   */\n\n\n  ClosureSubjectExecutor.prototype.update = function (subject) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parent, entity, oldParent, oldParentId, parentId, escape, closureTable, ancestorColumnNames, descendantColumnNames, createSubQuery, parameters, _a, _b, column, queryParams_2, tableName, superAlias_1, subAlias_1, select, entityWhereCondition, parentWhereCondition;\n\n      var e_1, _c;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity);\n            if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n              parent = subject.parentSubject.entity;\n            entity = subject.databaseEntity;\n            if (!entity && parent) // if entity was attached via children\n              entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(function (child) {\n                return Object.entries(subject.identifier).every(function (_a) {\n                  var _b = __read(_a, 2),\n                      key = _b[0],\n                      value = _b[1];\n\n                  return child[key] === value;\n                });\n              }); // Exit if the parent or the entity where never set\n\n            if (entity === undefined || parent === undefined) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n            oldParentId = subject.metadata.getEntityIdMap(oldParent);\n            parentId = subject.metadata.getEntityIdMap(parent); // Exit if the new and old parents are the same\n\n            if (OrmUtils.compareIds(oldParentId, parentId)) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            escape = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            closureTable = subject.metadata.closureJunctionTable;\n            ancestorColumnNames = closureTable.ancestorColumns.map(function (column) {\n              return escape(column.databaseName);\n            });\n            descendantColumnNames = closureTable.descendantColumns.map(function (column) {\n              return escape(column.databaseName);\n            });\n\n            createSubQuery = function (qb, alias) {\n              var e_2, _a;\n\n              var subAlias = \"sub\" + alias;\n              var subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(closureTable.tablePath, subAlias);\n\n              try {\n                // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n                for (var _b = __values(closureTable.ancestorColumns), _c = _b.next(); !_c.done; _c = _b.next()) {\n                  var column = _c.value;\n                  subSelect.andWhere(escape(subAlias) + \".\" + escape(column.databaseName) + \" = :value_\" + column.referencedColumn.databaseName);\n                }\n              } catch (e_2_1) {\n                e_2 = {\n                  error: e_2_1\n                };\n              } finally {\n                try {\n                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                } finally {\n                  if (e_2) throw e_2.error;\n                }\n              }\n\n              return qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(\"(\" + subSelect.getQuery() + \")\", alias).setParameters(subSelect.getParameters()).getQuery();\n            };\n\n            parameters = {};\n\n            try {\n              for (_a = __values(subject.metadata.primaryColumns), _b = _a.next(); !_b.done; _b = _a.next()) {\n                column = _b.value;\n                parameters[\"value_\" + column.databaseName] = entity[column.databaseName];\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(function (qb) {\n              return \"(\" + descendantColumnNames.join(\", \") + \") IN (\" + createSubQuery(qb, \"descendant\") + \")\";\n            }).andWhere(function (qb) {\n              return \"(\" + ancestorColumnNames.join(\", \") + \") NOT IN (\" + createSubQuery(qb, \"ancestor\") + \")\";\n            }).setParameters(parameters).execute()];\n\n          case 1:\n            _d.sent();\n\n            if (!parent) return [3\n            /*break*/\n            , 3];\n            queryParams_2 = [];\n            tableName = this.getTableName(closureTable.tablePath);\n            superAlias_1 = escape(\"supertree\");\n            subAlias_1 = escape(\"subtree\");\n            select = __spreadArray(__spreadArray([], __read(ancestorColumnNames.map(function (columnName) {\n              return superAlias_1 + \".\" + columnName;\n            }))), __read(descendantColumnNames.map(function (columnName) {\n              return subAlias_1 + \".\" + columnName;\n            })));\n            entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map(function (column) {\n              var columnName = escape(column.databaseName);\n              var entityId = column.referencedColumn.getEntityValue(entity);\n              queryParams_2.push(entityId);\n\n              var parameterName = _this.queryRunner.connection.driver.createParameter(\"entity_\" + column.referencedColumn.databaseName, queryParams_2.length - 1);\n\n              return subAlias_1 + \".\" + columnName + \" = \" + parameterName;\n            });\n            parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(function (column) {\n              var columnName = escape(column.databaseName);\n              var parentId = column.referencedColumn.getEntityValue(parent);\n              if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n              queryParams_2.push(parentId);\n\n              var parameterName = _this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams_2.length - 1);\n\n              return superAlias_1 + \".\" + columnName + \" = \" + parameterName;\n            });\n            return [4\n            /*yield*/\n            , this.queryRunner.query(\"INSERT INTO \" + tableName + \" (\" + __spreadArray(__spreadArray([], __read(ancestorColumnNames)), __read(descendantColumnNames)).join(\", \") + \") \" + (\"SELECT \" + select.join(\", \") + \" \") + (\"FROM \" + tableName + \" AS \" + superAlias_1 + \", \" + tableName + \" AS \" + subAlias_1 + \" \") + (\"WHERE \" + __spreadArray(__spreadArray([], __read(entityWhereCondition)), __read(parentWhereCondition)).join(\" AND \")), queryParams_2)];\n\n          case 2:\n            _d.sent();\n\n            _d.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n  * Executes operations when subject is being removed.\n  */\n\n\n  ClosureSubjectExecutor.prototype.remove = function (subjects) {\n    return __awaiter(this, void 0, void 0, function () {\n      var escape, identifiers, closureTable, generateWheres, ancestorWhere, descendantWhere;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n            if (!(this.queryRunner.connection.driver instanceof SqlServerDriver)) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!Array.isArray(subjects)) subjects = [subjects];\n\n            escape = function (alias) {\n              return _this.queryRunner.connection.driver.escape(alias);\n            };\n\n            identifiers = subjects.map(function (subject) {\n              return subject.identifier;\n            });\n            closureTable = subjects[0].metadata.closureJunctionTable;\n\n            generateWheres = function (columns) {\n              return columns.map(function (column) {\n                var data = identifiers.map(function (identifier) {\n                  return identifier[column.referencedColumn.databaseName];\n                });\n                return escape(column.databaseName) + \" IN (\" + data.join(\", \") + \")\";\n              }).join(\" AND \");\n            };\n\n            ancestorWhere = generateWheres(closureTable.ancestorColumns);\n            descendantWhere = generateWheres(closureTable.descendantColumns);\n            return [4\n            /*yield*/\n            , this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n\n\n  ClosureSubjectExecutor.prototype.getTableName = function (tablePath) {\n    var _this = this;\n\n    return tablePath.split(\".\").map(function (i) {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : _this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  };\n\n  return ClosureSubjectExecutor;\n}();\n\nexport { ClosureSubjectExecutor };","map":{"version":3,"sources":["../browser/src/persistence/tree/ClosureSubjectExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import {Subject} from \"../Subject\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {CannotAttachTreeChildrenEntityError} from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport {DeleteQueryBuilder} from \"../../query-builder/DeleteQueryBuilder\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {SqlServerDriver} from \"../../driver/sqlserver/SqlServerDriver\";\nimport {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\n\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n\n        // create values to be inserted into the closure junction\n        const closureJunctionInsertMap: ObjectLiteral = {};\n        subject.metadata.closureJunctionTable.ancestorColumns.forEach(column => {\n            closureJunctionInsertMap[column.databaseName] = subject.identifier;\n        });\n        subject.metadata.closureJunctionTable.descendantColumns.forEach(column => {\n            closureJunctionInsertMap[column.databaseName] = subject.identifier;\n        });\n\n        // insert values into the closure junction table\n        await this.queryRunner\n            .manager\n            .createQueryBuilder()\n            .insert()\n            .into(subject.metadata.closureJunctionTable.tablePath)\n            .values(closureJunctionInsertMap)\n            .updateEntity(false)\n            .callListeners(false)\n            .execute();\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n\n        if (parent) {\n            const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n            const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n            const queryParams: any[] = [];\n\n            const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n                return escape(column.databaseName);\n            });\n            const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n                return escape(column.databaseName);\n            });\n            const childEntityIds1 = subject.metadata.primaryColumns.map(column => {\n                queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity!));\n                return this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams.length - 1);\n            });\n\n            const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n                const columnName = escape(column.databaseName);\n                const parentId = column.referencedColumn!.getEntityValue(parent);\n\n                if (!parentId)\n                    throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n\n                queryParams.push(parentId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn!.databaseName, queryParams.length - 1);\n                return `${columnName} = ${parameterName}`;\n            });\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` +\n                `SELECT ${ancestorColumnNames.join(\", \")}, ${childEntityIds1.join(\", \")} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`,\n                queryParams\n            );\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\n            parent = subject.parentSubject.entity;\n\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && parent) // if entity was attached via children\n            entity = subject.metadata.treeChildrenRelation!.getEntityValue(parent).find((child: any) => {\n                return Object.entries(subject.identifier!).every(([key, value]) => child[key] === value);\n            });\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return;\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(entity!);\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n        const parentId = subject.metadata.getEntityIdMap(parent);\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return;\n        }\n\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const closureTable = subject.metadata.closureJunctionTable;\n\n        const ancestorColumnNames = closureTable.ancestorColumns.map(column => {\n            return escape(column.databaseName);\n        });\n\n        const descendantColumnNames = closureTable.descendantColumns.map(column => {\n            return escape(column.databaseName);\n        });\n\n        // Delete logic\n        const createSubQuery = (qb: DeleteQueryBuilder<any>, alias: string) => {\n            const subAlias = `sub${alias}`;\n\n            const subSelect = qb.createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(closureTable.tablePath, subAlias);\n\n            // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n            for (const column of closureTable.ancestorColumns) {\n                subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn!.databaseName}`);\n            }\n\n            return qb.createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(`(${subSelect.getQuery()})`, alias)\n                .setParameters(subSelect.getParameters())\n                .getQuery();\n        };\n\n        const parameters: ObjectLiteral = {};\n        for (const column of subject.metadata.primaryColumns) {\n            parameters[`value_${column.databaseName}`] = entity![column.databaseName];\n        }\n\n        await this.queryRunner\n            .manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(qb => `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(qb, \"descendant\")})`)\n            .andWhere(qb => `(${ancestorColumnNames.join(\", \")}) NOT IN (${createSubQuery(qb, \"ancestor\")})`)\n            .setParameters(parameters)\n            .execute();\n\n        /**\n         * Only insert new parent if it exits\n         * \n         * This only happens if the entity doesn't become a root entity\n         */\n        if (parent) {\n            // Insert logic\n            const queryParams: any[] = [];\n\n            const tableName = this.getTableName(closureTable.tablePath);\n            const superAlias = escape(\"supertree\");\n            const subAlias = escape(\"subtree\");\n\n            const select = [\n                ...ancestorColumnNames.map(columnName => `${superAlias}.${columnName}`),\n                ...descendantColumnNames.map(columnName => `${subAlias}.${columnName}`)\n            ];\n\n            const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n                const columnName = escape(column.databaseName);\n                const entityId = column.referencedColumn!.getEntityValue(entity!);\n\n                queryParams.push(entityId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.referencedColumn!.databaseName, queryParams.length - 1);\n                return `${subAlias}.${columnName} = ${parameterName}`;\n            });\n\n            const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n                const columnName = escape(column.databaseName);\n                const parentId = column.referencedColumn!.getEntityValue(parent);\n\n                if (!parentId)\n                    throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n\n                queryParams.push(parentId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn!.databaseName, queryParams.length - 1);\n                return `${superAlias}.${columnName} = ${parameterName}`;\n            });\n\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` +\n                `SELECT ${select.join(\", \")} ` +\n                `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` +\n                `WHERE ${[...entityWhereCondition, ...parentWhereCondition].join(\" AND \")}`,\n                queryParams\n            );\n        }\n    }\n\n    /**\n    * Executes operations when subject is being removed.\n    */\n    async remove(subjects: Subject|Subject[]): Promise<void> {\n        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n        if (!(this.queryRunner.connection.driver instanceof SqlServerDriver)) {\n            return;\n        }\n\n        if (!Array.isArray(subjects))\n            subjects = [subjects];\n\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\n        const identifiers = subjects.map(subject => subject.identifier);\n        const closureTable = subjects[0].metadata.closureJunctionTable;\n\n        const generateWheres = (columns: ColumnMetadata[]) => {\n            return columns.map(column => {\n                const data = identifiers.map(identifier => identifier![column.referencedColumn!.databaseName]);\n                return `${escape(column.databaseName)} IN (${data.join(\", \")})`;\n            }).join(\" AND \");\n        };\n\n        const ancestorWhere = generateWheres(closureTable.ancestorColumns);\n        const descendantWhere = generateWheres(closureTable.descendantColumns);\n\n        await this.queryRunner\n            .manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(ancestorWhere)\n            .orWhere(descendantWhere)\n            .execute();\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath.split(\".\")\n            .map(i => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n            }).join(\".\");\n    }\n}"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}