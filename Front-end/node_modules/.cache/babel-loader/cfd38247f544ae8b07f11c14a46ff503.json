{"ast":null,"code":"/**\n * Metadata args utility functions.\n */\nvar MetadataUtils =\n/** @class */\nfunction () {\n  function MetadataUtils() {}\n  /**\n   * Gets given's entity all inherited classes.\n   * Gives in order from parents to children.\n   * For example Post extends ContentModel which extends Unit it will give\n   * [Unit, ContentModel, Post]\n   */\n\n\n  MetadataUtils.getInheritanceTree = function (entity) {\n    var tree = [entity];\n\n    var getPrototypeOf = function (object) {\n      var proto = Object.getPrototypeOf(object);\n\n      if (proto && proto.name) {\n        tree.push(proto);\n        getPrototypeOf(proto);\n      }\n    };\n\n    getPrototypeOf(entity);\n    return tree;\n  };\n  /**\n   * Checks if this table is inherited from another table.\n   */\n\n\n  MetadataUtils.isInherited = function (target1, target2) {\n    return target1.prototype instanceof target2;\n  };\n  /**\n   * Filters given array of targets by a given classes.\n   * If classes are not given, then it returns array itself.\n   */\n\n\n  MetadataUtils.filterByTarget = function (array, classes) {\n    if (!classes) return array;\n    return array.filter(function (item) {\n      return item.target && classes.indexOf(item.target) !== -1;\n    });\n  };\n\n  return MetadataUtils;\n}();\n\nexport { MetadataUtils };","map":{"version":3,"sources":["../browser/src/metadata-builder/MetadataUtils.ts"],"names":[],"mappings":"AAAA;;AAEG;AACH,IAAA,aAAA;AAAA;AAAA,YAAA;AAAA,WAAA,aAAA,GAAA,CAqCC;AAnCG;;;;;AAKG;;;AACI,EAAA,aAAA,CAAA,kBAAA,GAAP,UAA0B,MAA1B,EAA0C;AACtC,QAAM,IAAI,GAAe,CAAC,MAAD,CAAzB;;AACA,QAAM,cAAc,GAAG,UAAC,MAAD,EAAiB;AACpC,UAAM,KAAK,GAAG,MAAM,CAAC,cAAP,CAAsB,MAAtB,CAAd;;AACA,UAAI,KAAK,IAAI,KAAK,CAAC,IAAnB,EAAyB;AACrB,QAAA,IAAI,CAAC,IAAL,CAAU,KAAV;AACA,QAAA,cAAc,CAAC,KAAD,CAAd;AACH;AACJ,KAND;;AAOA,IAAA,cAAc,CAAC,MAAD,CAAd;AACA,WAAO,IAAP;AACH,GAXM;AAaP;;AAEG;;;AACI,EAAA,aAAA,CAAA,WAAA,GAAP,UAAmB,OAAnB,EAAsC,OAAtC,EAAuD;AACnD,WAAO,OAAO,CAAC,SAAR,YAA6B,OAApC;AACH,GAFM;AAIP;;;AAGG;;;AACI,EAAA,aAAA,CAAA,cAAA,GAAP,UAAkD,KAAlD,EAA8D,OAA9D,EAA6E;AACzE,QAAI,CAAC,OAAL,EAAc,OAAO,KAAP;AACd,WAAO,KAAK,CAAC,MAAN,CAAa,UAAA,IAAA,EAAI;AAAI,aAAA,IAAI,CAAC,MAAL,IAAe,OAAO,CAAC,OAAR,CAAgB,IAAI,CAAC,MAArB,MAAiC,CAAhD,CAAA;AAAkD,KAAvE,CAAP;AACH,GAHM;;AAKX,SAAA,aAAA;AAAC,CArCD,EAAA","sourcesContent":["/**\n * Metadata args utility functions.\n */\nexport class MetadataUtils {\n\n    /**\n     * Gets given's entity all inherited classes.\n     * Gives in order from parents to children.\n     * For example Post extends ContentModel which extends Unit it will give\n     * [Unit, ContentModel, Post]\n     */\n    static getInheritanceTree(entity: Function): Function[] {\n        const tree: Function[] = [entity];\n        const getPrototypeOf = (object: Function): void => {\n            const proto = Object.getPrototypeOf(object);\n            if (proto && proto.name) {\n                tree.push(proto);\n                getPrototypeOf(proto);\n            }\n        };\n        getPrototypeOf(entity);\n        return tree;\n    }\n\n    /**\n     * Checks if this table is inherited from another table.\n     */\n    static isInherited(target1: Function, target2: Function) {\n        return target1.prototype instanceof target2;\n    }\n\n    /**\n     * Filters given array of targets by a given classes.\n     * If classes are not given, then it returns array itself.\n     */\n    static filterByTarget<T extends { target?: any }>(array: T[], classes?: any[]): T[] {\n        if (!classes) return array;\n        return array.filter(item => item.target && classes.indexOf(item.target) !== -1);\n    }\n\n}"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}