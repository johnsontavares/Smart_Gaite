{"ast":null,"code":"import { __awaiter, __extends, __generator, __read } from \"tslib\";\nimport { CockroachDriver } from \"../driver/cockroachdb/CockroachDriver\";\nimport { SapDriver } from \"../driver/sap/SapDriver\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { RandomGenerator } from \"../util/RandomGenerator\";\nimport { InsertResult } from \"./result/InsertResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { InsertValuesMissingError } from \"../error/InsertValuesMissingError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { AbstractSqliteDriver } from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport { SqljsDriver } from \"../driver/sqljs/SqljsDriver\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { EntitySchema } from \"../entity-schema/EntitySchema\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\n\nvar InsertQueryBuilder =\n/** @class */\nfunction (_super) {\n  __extends(InsertQueryBuilder, _super);\n\n  function InsertQueryBuilder() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Gets generated sql query without parameters being replaced.\n   */\n\n\n  InsertQueryBuilder.prototype.getQuery = function () {\n    var sql = this.createComment();\n    sql += this.createInsertExpression();\n    return sql.trim();\n  };\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n\n\n  InsertQueryBuilder.prototype.execute = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var valueSets, queryRunner, transactionStartedByUs, broadcastResult_1, declareSql, selectOutputSql, returningResultsEntityUpdator, _a, insertSql, parameters, insertResult, statements, _b, broadcastResult_2, error_1, rollbackError_1;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            valueSets = this.getValueSets(); // console.timeEnd(\".value sets\");\n            // If user passed empty array of entities then we don't need to do\n            // anything.\n            //\n            // Fixes GitHub issues #3111 and #5734. If we were to let this through\n            // we would run into problems downstream, like subscribers getting\n            // invoked with the empty array where they expect an entity, and SQL\n            // queries with an empty VALUES clause.\n\n            if (valueSets.length === 0) return [2\n            /*return*/\n            , new InsertResult()];\n            queryRunner = this.obtainQueryRunner();\n            transactionStartedByUs = false;\n            _c.label = 1;\n\n          case 1:\n            _c.trys.push([1, 13, 18, 23]);\n\n            if (!(this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 2:\n            _c.sent();\n\n            transactionStartedByUs = true;\n            _c.label = 3;\n\n          case 3:\n            if (!(this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata)) return [3\n            /*break*/\n            , 5];\n            broadcastResult_1 = new BroadcasterResult();\n            valueSets.forEach(function (valueSet) {\n              queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult_1, _this.expressionMap.mainAlias.metadata, valueSet);\n            });\n            if (!(broadcastResult_1.promises.length > 0)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , Promise.all(broadcastResult_1.promises)];\n\n          case 4:\n            _c.sent();\n\n            _c.label = 5;\n\n          case 5:\n            declareSql = null;\n            selectOutputSql = null;\n            returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n\n            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata) {\n              if (!(valueSets.length > 1 && this.connection.driver instanceof OracleDriver)) {\n                this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getInsertionReturningColumns();\n              }\n\n              if (this.expressionMap.extraReturningColumns.length > 0 && this.connection.driver instanceof SqlServerDriver) {\n                declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", this.expressionMap.extraReturningColumns);\n                selectOutputSql = \"SELECT * FROM @OutputTable\";\n              }\n            }\n\n            _a = __read(this.getQueryAndParameters(), 2), insertSql = _a[0], parameters = _a[1];\n            insertResult = new InsertResult();\n            statements = [declareSql, insertSql, selectOutputSql];\n            _b = insertResult;\n            return [4\n            /*yield*/\n            , queryRunner.query(statements.filter(function (sql) {\n              return sql != null;\n            }).join(\";\\n\\n\"), parameters)];\n\n          case 6:\n            _b.raw = _c.sent();\n            if (!(this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata)) return [3\n            /*break*/\n            , 8]; // console.time(\".updating entity\");\n\n            return [4\n            /*yield*/\n            , returningResultsEntityUpdator.insert(insertResult, valueSets)];\n\n          case 7:\n            // console.time(\".updating entity\");\n            _c.sent();\n\n            _c.label = 8;\n\n          case 8:\n            if (!(this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata)) return [3\n            /*break*/\n            , 10];\n            broadcastResult_2 = new BroadcasterResult();\n            valueSets.forEach(function (valueSet) {\n              queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult_2, _this.expressionMap.mainAlias.metadata, valueSet);\n            });\n            if (!(broadcastResult_2.promises.length > 0)) return [3\n            /*break*/\n            , 10];\n            return [4\n            /*yield*/\n            , Promise.all(broadcastResult_2.promises)];\n\n          case 9:\n            _c.sent();\n\n            _c.label = 10;\n\n          case 10:\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 12];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 11:\n            _c.sent();\n\n            _c.label = 12;\n\n          case 12:\n            // console.timeEnd(\".commit\");\n            return [2\n            /*return*/\n            , insertResult];\n\n          case 13:\n            error_1 = _c.sent();\n            if (!transactionStartedByUs) return [3\n            /*break*/\n            , 17];\n            _c.label = 14;\n\n          case 14:\n            _c.trys.push([14, 16,, 17]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 15:\n            _c.sent();\n\n            return [3\n            /*break*/\n            , 17];\n\n          case 16:\n            rollbackError_1 = _c.sent();\n            return [3\n            /*break*/\n            , 17];\n\n          case 17:\n            throw error_1;\n\n          case 18:\n            if (!(queryRunner !== this.queryRunner)) return [3\n            /*break*/\n            , 20];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 19:\n            _c.sent();\n\n            _c.label = 20;\n\n          case 20:\n            if (!(this.connection.driver instanceof SqljsDriver && !queryRunner.isTransactionActive)) return [3\n            /*break*/\n            , 22];\n            return [4\n            /*yield*/\n            , this.connection.driver.autoSave()];\n\n          case 21:\n            _c.sent();\n\n            _c.label = 22;\n\n          case 22:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 23:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Specifies INTO which entity's table insertion will be executed.\n   */\n\n\n  InsertQueryBuilder.prototype.into = function (entityTarget, columns) {\n    entityTarget = entityTarget instanceof EntitySchema ? entityTarget.options.name : entityTarget;\n    var mainAlias = this.createFromAlias(entityTarget);\n    this.expressionMap.setMainAlias(mainAlias);\n    this.expressionMap.insertColumns = columns || [];\n    return this;\n  };\n  /**\n   * Values needs to be inserted into table.\n   */\n\n\n  InsertQueryBuilder.prototype.values = function (values) {\n    this.expressionMap.valuesSet = values;\n    return this;\n  };\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  InsertQueryBuilder.prototype.output = function (output) {\n    return this.returning(output);\n  };\n  /**\n   * Optional returning/output clause.\n   */\n\n\n  InsertQueryBuilder.prototype.returning = function (returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported()) throw new ReturningStatementNotSupportedError();\n    this.expressionMap.returning = returning;\n    return this;\n  };\n  /**\n   * Indicates if entity must be updated after insertion operations.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n\n\n  InsertQueryBuilder.prototype.updateEntity = function (enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  };\n  /**\n   * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n   */\n\n\n  InsertQueryBuilder.prototype.onConflict = function (statement) {\n    this.expressionMap.onConflict = statement;\n    return this;\n  };\n  /**\n   * Adds additional ignore statement supported in databases.\n   */\n\n\n  InsertQueryBuilder.prototype.orIgnore = function (statement) {\n    if (statement === void 0) {\n      statement = true;\n    }\n\n    this.expressionMap.onIgnore = statement;\n    return this;\n  };\n  /**\n   * Adds additional update statement supported in databases.\n   */\n\n\n  InsertQueryBuilder.prototype.orUpdate = function (statement) {\n    var _this = this;\n\n    this.expressionMap.onUpdate = {};\n    if (statement && Array.isArray(statement.conflict_target)) this.expressionMap.onUpdate.conflict = \" ( \" + statement.conflict_target.map(function (columnName) {\n      return _this.escape(columnName);\n    }).join(\", \") + \" ) \";\n    if (statement && typeof statement.conflict_target === \"string\") this.expressionMap.onUpdate.conflict = \" ON CONSTRAINT \" + this.escape(statement.conflict_target) + \" \";\n    if (statement && Array.isArray(statement.columns)) this.expressionMap.onUpdate.columns = statement.columns.map(function (column) {\n      return _this.escape(column) + \" = :\" + column;\n    }).join(\", \");\n\n    if (statement && Array.isArray(statement.overwrite)) {\n      if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n        this.expressionMap.onUpdate.overwrite = statement.overwrite.map(function (column) {\n          return column + \" = VALUES(\" + column + \")\";\n        }).join(\", \");\n      } else if (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof AbstractSqliteDriver || this.connection.driver instanceof CockroachDriver) {\n        this.expressionMap.onUpdate.overwrite = statement.overwrite.map(function (column) {\n          return _this.escape(column) + \" = EXCLUDED.\" + _this.escape(column);\n        }).join(\", \");\n      }\n    }\n\n    return this;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates INSERT express used to perform insert query.\n   */\n\n\n  InsertQueryBuilder.prototype.createInsertExpression = function () {\n    var _this = this;\n\n    var tableName = this.getTableName(this.getMainTableName());\n    var valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n\n    var returningExpression = this.connection.driver instanceof OracleDriver && this.getValueSets().length > 1 ? null : this.createReturningExpression(); // oracle doesnt support returning with multi-row insert\n\n    var columnsExpression = this.createColumnNamesExpression();\n    var query = \"INSERT \";\n\n    if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n      query += \"\" + (this.expressionMap.onIgnore ? \" IGNORE \" : \"\");\n    }\n\n    query += \"INTO \" + tableName; // add columns expression\n\n    if (columnsExpression) {\n      query += \"(\" + columnsExpression + \")\";\n    } else {\n      if (!valuesExpression && (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver)) // special syntax for mysql DEFAULT VALUES insertion\n        query += \"()\";\n    } // add OUTPUT expression\n\n\n    if (returningExpression && this.connection.driver instanceof SqlServerDriver) {\n      query += \" OUTPUT \" + returningExpression;\n    } // add VALUES expression\n\n\n    if (valuesExpression) {\n      if (this.connection.driver instanceof OracleDriver && this.getValueSets().length > 1) {\n        query += \" \" + valuesExpression;\n      } else {\n        query += \" VALUES \" + valuesExpression;\n      }\n    } else {\n      if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n        // special syntax for mysql DEFAULT VALUES insertion\n        query += \" VALUES ()\";\n      } else {\n        query += \" DEFAULT VALUES\";\n      }\n    }\n\n    if (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof AbstractSqliteDriver || this.connection.driver instanceof CockroachDriver) {\n      query += \"\" + (this.expressionMap.onIgnore ? \" ON CONFLICT DO NOTHING \" : \"\");\n      query += \"\" + (this.expressionMap.onConflict ? \" ON CONFLICT \" + this.expressionMap.onConflict : \"\");\n\n      if (this.expressionMap.onUpdate) {\n        var _a = this.expressionMap.onUpdate,\n            overwrite = _a.overwrite,\n            columns = _a.columns,\n            conflict = _a.conflict;\n        query += \"\" + (columns ? \" ON CONFLICT \" + conflict + \" DO UPDATE SET \" + columns : \"\");\n        query += \"\" + (overwrite ? \" ON CONFLICT \" + conflict + \" DO UPDATE SET \" + overwrite : \"\");\n      }\n    } else if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n      if (this.expressionMap.onUpdate) {\n        var _b = this.expressionMap.onUpdate,\n            overwrite = _b.overwrite,\n            columns = _b.columns;\n        query += \"\" + (columns ? \" ON DUPLICATE KEY UPDATE \" + columns : \"\");\n        query += \"\" + (overwrite ? \" ON DUPLICATE KEY UPDATE \" + overwrite : \"\");\n      }\n    } // add RETURNING expression\n\n\n    if (returningExpression && (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof OracleDriver || this.connection.driver instanceof CockroachDriver)) {\n      query += \" RETURNING \" + returningExpression;\n    } // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n    // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n\n\n    if (this.connection.driver instanceof SqlServerDriver && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.mainAlias.metadata.columns.filter(function (column) {\n      return _this.expressionMap.insertColumns.length > 0 ? _this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert;\n    }).some(function (column) {\n      return _this.isOverridingAutoIncrementBehavior(column);\n    })) {\n      query = \"SET IDENTITY_INSERT \" + tableName + \" ON; \" + query + \"; SET IDENTITY_INSERT \" + tableName + \" OFF\";\n    }\n\n    return query;\n  };\n  /**\n   * Gets list of columns where values must be inserted to.\n   */\n\n\n  InsertQueryBuilder.prototype.getInsertedColumns = function () {\n    var _this = this;\n\n    if (!this.expressionMap.mainAlias.hasMetadata) return [];\n    return this.expressionMap.mainAlias.metadata.columns.filter(function (column) {\n      // if user specified list of columns he wants to insert to, then we filter only them\n      if (_this.expressionMap.insertColumns.length) return _this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1; // skip columns the user doesn't want included by default\n\n      if (!column.isInsert) {\n        return false;\n      } // if user did not specified such list then return all columns except auto-increment one\n      // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n\n\n      if (column.isGenerated && column.generationStrategy === \"increment\" && !(_this.connection.driver instanceof OracleDriver) && !(_this.connection.driver instanceof AbstractSqliteDriver) && !(_this.connection.driver instanceof MysqlDriver) && !(_this.connection.driver instanceof AuroraDataApiDriver) && !(_this.connection.driver instanceof SqlServerDriver && _this.isOverridingAutoIncrementBehavior(column))) return false;\n      return true;\n    });\n  };\n  /**\n   * Creates a columns string where values must be inserted to for INSERT INTO expression.\n   */\n\n\n  InsertQueryBuilder.prototype.createColumnNamesExpression = function () {\n    var _this = this;\n\n    var columns = this.getInsertedColumns();\n    if (columns.length > 0) return columns.map(function (column) {\n      return _this.escape(column.databaseName);\n    }).join(\", \"); // in the case if there are no insert columns specified and table without metadata used\n    // we get columns from the inserted value map, in the case if only one inserted map is specified\n\n    if (!this.expressionMap.mainAlias.hasMetadata && !this.expressionMap.insertColumns.length) {\n      var valueSets = this.getValueSets();\n      if (valueSets.length === 1) return Object.keys(valueSets[0]).map(function (columnName) {\n        return _this.escape(columnName);\n      }).join(\", \");\n    } // get a table name and all column database names\n\n\n    return this.expressionMap.insertColumns.map(function (columnName) {\n      return _this.escape(columnName);\n    }).join(\", \");\n  };\n  /**\n   * Creates list of values needs to be inserted in the VALUES expression.\n   */\n\n\n  InsertQueryBuilder.prototype.createValuesExpression = function () {\n    var _this = this;\n\n    var valueSets = this.getValueSets();\n    var columns = this.getInsertedColumns(); // if column metadatas are given then apply all necessary operations with values\n\n    if (columns.length > 0) {\n      var expression_1 = \"\";\n      var parametersCount_1 = Object.keys(this.expressionMap.nativeParameters).length;\n      valueSets.forEach(function (valueSet, valueSetIndex) {\n        columns.forEach(function (column, columnIndex) {\n          if (columnIndex === 0) {\n            if (_this.connection.driver instanceof OracleDriver && valueSets.length > 1) {\n              expression_1 += \" SELECT \";\n            } else {\n              expression_1 += \"(\";\n            }\n          }\n\n          var paramName = \"i\" + valueSetIndex + \"_\" + column.databaseName; // extract real value from the entity\n\n          var value = column.getEntityValue(valueSet); // if column is relational and value is an object then get real referenced column value from this object\n          // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n          // and we extract \"1\" from this object\n\n          /*if (column.referencedColumn && value instanceof Object && !(value instanceof Function)) { // todo: check if we still need it since getEntityValue already has similar code\n              value = column.referencedColumn.getEntityValue(value);\n          }*/\n\n          if (!(value instanceof Function)) {\n            // make sure our value is normalized by a driver\n            value = _this.connection.driver.preparePersistentValue(value, column);\n          } // newly inserted entities always have a version equal to 1 (first version)\n          // also, user-specified version must be empty\n\n\n          if (column.isVersion && value === undefined) {\n            expression_1 += \"1\"; // } else if (column.isNestedSetLeft) {\n            //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n            //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n            //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n            //     expression += subQuery;\n            //\n            // } else if (column.isNestedSetRight) {\n            //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n            //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n            //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n            //     expression += subQuery;\n          } else if (column.isDiscriminator) {\n            _this.expressionMap.nativeParameters[\"discriminator_value_\" + parametersCount_1] = _this.expressionMap.mainAlias.metadata.discriminatorValue;\n            expression_1 += _this.connection.driver.createParameter(\"discriminator_value_\" + parametersCount_1, parametersCount_1);\n            parametersCount_1++; // return \"1\";\n            // for create and update dates we insert current date\n            // no, we don't do it because this constant is already in \"default\" value of the column\n            // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n            // } else if (column.isCreateDate || column.isUpdateDate) {\n            //     return \"CURRENT_TIMESTAMP\";\n            // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n          } else if (column.isGenerated && column.generationStrategy === \"uuid\" && !_this.connection.driver.isUUIDGenerationSupported() && value === undefined) {\n            var paramName_1 = \"uuid_\" + column.databaseName + valueSetIndex;\n            value = RandomGenerator.uuid4();\n            _this.expressionMap.nativeParameters[paramName_1] = value;\n            expression_1 += _this.connection.driver.createParameter(paramName_1, parametersCount_1);\n            parametersCount_1++; // if value for this column was not provided then insert default value\n          } else if (value === undefined) {\n            if (_this.connection.driver instanceof OracleDriver && valueSets.length > 1 || _this.connection.driver instanceof AbstractSqliteDriver || _this.connection.driver instanceof SapDriver) {\n              // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n              if (column.default !== undefined && column.default !== null) {\n                // try to use default defined in the column\n                expression_1 += _this.connection.driver.normalizeDefault(column);\n              } else {\n                expression_1 += \"NULL\"; // otherwise simply use NULL and pray if column is nullable\n              }\n            } else {\n              expression_1 += \"DEFAULT\";\n            } // support for SQL expressions in queries\n\n          } else if (value instanceof Function) {\n            expression_1 += value(); // just any other regular value\n          } else {\n            if (_this.connection.driver instanceof SqlServerDriver) value = _this.connection.driver.parametrizeValue(column, value); // we need to store array values in a special class to make sure parameter replacement will work correctly\n            // if (value instanceof Array)\n            //     value = new ArrayParameter(value);\n\n            _this.expressionMap.nativeParameters[paramName] = value;\n\n            if ((_this.connection.driver instanceof MysqlDriver || _this.connection.driver instanceof AuroraDataApiDriver) && _this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              var useLegacy = _this.connection.driver.options.legacySpatialSupport;\n              var geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n\n              if (column.srid != null) {\n                expression_1 += geomFromText + \"(\" + _this.connection.driver.createParameter(paramName, parametersCount_1) + \", \" + column.srid + \")\";\n              } else {\n                expression_1 += geomFromText + \"(\" + _this.connection.driver.createParameter(paramName, parametersCount_1) + \")\";\n              }\n            } else if (_this.connection.driver instanceof PostgresDriver && _this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              if (column.srid != null) {\n                expression_1 += \"ST_SetSRID(ST_GeomFromGeoJSON(\" + _this.connection.driver.createParameter(paramName, parametersCount_1) + \"), \" + column.srid + \")::\" + column.type;\n              } else {\n                expression_1 += \"ST_GeomFromGeoJSON(\" + _this.connection.driver.createParameter(paramName, parametersCount_1) + \")::\" + column.type;\n              }\n            } else if (_this.connection.driver instanceof SqlServerDriver && _this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              expression_1 += column.type + \"::STGeomFromText(\" + _this.connection.driver.createParameter(paramName, parametersCount_1) + \", \" + (column.srid || \"0\") + \")\";\n            } else {\n              expression_1 += _this.connection.driver.createParameter(paramName, parametersCount_1);\n            }\n\n            parametersCount_1++;\n          }\n\n          if (columnIndex === columns.length - 1) {\n            if (valueSetIndex === valueSets.length - 1) {\n              if (_this.connection.driver instanceof OracleDriver && valueSets.length > 1) {\n                expression_1 += \" FROM DUAL \";\n              } else {\n                expression_1 += \")\";\n              }\n            } else {\n              if (_this.connection.driver instanceof OracleDriver && valueSets.length > 1) {\n                expression_1 += \" FROM DUAL UNION ALL \";\n              } else {\n                expression_1 += \"), \";\n              }\n            }\n          } else {\n            expression_1 += \", \";\n          }\n        });\n      });\n      if (expression_1 === \"()\") return \"\";\n      return expression_1;\n    } else {\n      // for tables without metadata\n      // get values needs to be inserted\n      var expression_2 = \"\";\n      var parametersCount_2 = Object.keys(this.expressionMap.nativeParameters).length;\n      valueSets.forEach(function (valueSet, insertionIndex) {\n        var columns = Object.keys(valueSet);\n        columns.forEach(function (columnName, columnIndex) {\n          if (columnIndex === 0) {\n            expression_2 += \"(\";\n          }\n\n          var paramName = \"i\" + insertionIndex + \"_\" + columnName;\n          var value = valueSet[columnName]; // support for SQL expressions in queries\n\n          if (value instanceof Function) {\n            expression_2 += value(); // if value for this column was not provided then insert default value\n          } else if (value === undefined) {\n            if (_this.connection.driver instanceof AbstractSqliteDriver || _this.connection.driver instanceof SapDriver) {\n              expression_2 += \"NULL\";\n            } else {\n              expression_2 += \"DEFAULT\";\n            } // just any other regular value\n\n          } else {\n            _this.expressionMap.nativeParameters[paramName] = value;\n            expression_2 += _this.connection.driver.createParameter(paramName, parametersCount_2);\n            parametersCount_2++;\n          }\n\n          if (columnIndex === Object.keys(valueSet).length - 1) {\n            if (insertionIndex === valueSets.length - 1) {\n              expression_2 += \")\";\n            } else {\n              expression_2 += \"), \";\n            }\n          } else {\n            expression_2 += \", \";\n          }\n        });\n      });\n      if (expression_2 === \"()\") return \"\";\n      return expression_2;\n    }\n  };\n  /**\n   * Gets array of values need to be inserted into the target table.\n   */\n\n\n  InsertQueryBuilder.prototype.getValueSets = function () {\n    if (Array.isArray(this.expressionMap.valuesSet)) return this.expressionMap.valuesSet;\n    if (this.expressionMap.valuesSet instanceof Object) return [this.expressionMap.valuesSet];\n    throw new InsertValuesMissingError();\n  };\n  /**\n   * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n   *\n   * @param column\n   */\n\n\n  InsertQueryBuilder.prototype.isOverridingAutoIncrementBehavior = function (column) {\n    return column.isPrimary && column.isGenerated && column.generationStrategy === \"increment\" && this.getValueSets().some(function (valueSet) {\n      return column.getEntityValue(valueSet) !== undefined && column.getEntityValue(valueSet) !== null;\n    });\n  };\n\n  return InsertQueryBuilder;\n}(QueryBuilder);\n\nexport { InsertQueryBuilder };","map":{"version":3,"sources":["../browser/src/query-builder/InsertQueryBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {CockroachDriver} from \"../driver/cockroachdb/CockroachDriver\";\nimport {SapDriver} from \"../driver/sap/SapDriver\";\nimport {QueryBuilder} from \"./QueryBuilder\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {QueryDeepPartialEntity} from \"./QueryPartialEntity\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {RandomGenerator} from \"../util/RandomGenerator\";\nimport {InsertResult} from \"./result/InsertResult\";\nimport {ReturningStatementNotSupportedError} from \"../error/ReturningStatementNotSupportedError\";\nimport {InsertValuesMissingError} from \"../error/InsertValuesMissingError\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {ReturningResultsEntityUpdator} from \"./ReturningResultsEntityUpdator\";\nimport {AbstractSqliteDriver} from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\nimport {SqljsDriver} from \"../driver/sqljs/SqljsDriver\";\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\nimport {EntitySchema} from \"../entity-schema/EntitySchema\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class InsertQueryBuilder<Entity> extends QueryBuilder<Entity> {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated sql query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment();\n        sql += this.createInsertExpression();\n        return sql.trim();\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<InsertResult> {\n        // console.time(\".value sets\");\n        const valueSets: ObjectLiteral[] = this.getValueSets();\n        // console.timeEnd(\".value sets\");\n\n        // If user passed empty array of entities then we don't need to do\n        // anything.\n        //\n        // Fixes GitHub issues #3111 and #5734. If we were to let this through\n        // we would run into problems downstream, like subscribers getting\n        // invoked with the empty array where they expect an entity, and SQL\n        // queries with an empty VALUES clause.\n        if (valueSets.length === 0)\n            return new InsertResult();\n\n        // console.time(\"QueryBuilder.execute\");\n        // console.time(\".database stuff\");\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs: boolean = false;\n\n        try {\n\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n\n            // console.timeEnd(\".database stuff\");\n\n            // call before insertion methods in listeners and subscribers\n            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias!.hasMetadata) {\n                const broadcastResult = new BroadcasterResult();\n                valueSets.forEach(valueSet => {\n                    queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, this.expressionMap.mainAlias!.metadata, valueSet);\n                });\n                if (broadcastResult.promises.length > 0) await Promise.all(broadcastResult.promises);\n            }\n\n            let declareSql: string | null = null;\n            let selectOutputSql: string | null = null;\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            // console.time(\".prepare returning statement\");\n            const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias!.hasMetadata) {\n                if (!(valueSets.length > 1 && this.connection.driver instanceof OracleDriver)) {\n                    this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getInsertionReturningColumns();\n                }\n                if (this.expressionMap.extraReturningColumns.length > 0 && this.connection.driver instanceof SqlServerDriver) {\n                    declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", this.expressionMap.extraReturningColumns);\n                    selectOutputSql = `SELECT * FROM @OutputTable`;\n                }\n            }\n            // console.timeEnd(\".prepare returning statement\");\n\n            // execute query\n            // console.time(\".getting query and parameters\");\n            const [insertSql, parameters] = this.getQueryAndParameters();\n            // console.timeEnd(\".getting query and parameters\");\n            const insertResult = new InsertResult();\n            // console.time(\".query execution by database\");\n            const statements = [declareSql, insertSql, selectOutputSql];\n            insertResult.raw = await queryRunner.query(\n                statements.filter(sql => sql != null).join(\";\\n\\n\"),\n                parameters,\n            );\n            // console.timeEnd(\".query execution by database\");\n\n            // load returning results and set them to the entity if entity updation is enabled\n            if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias!.hasMetadata) {\n                // console.time(\".updating entity\");\n                await returningResultsEntityUpdator.insert(insertResult, valueSets);\n                // console.timeEnd(\".updating entity\");\n            }\n\n            // call after insertion methods in listeners and subscribers\n            if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias!.hasMetadata) {\n                const broadcastResult = new BroadcasterResult();\n                valueSets.forEach(valueSet => {\n                    queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, this.expressionMap.mainAlias!.metadata, valueSet);\n                });\n                if (broadcastResult.promises.length > 0) await Promise.all(broadcastResult.promises);\n            }\n\n            // close transaction if we started it\n            // console.time(\".commit\");\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            // console.timeEnd(\".commit\");\n\n            return insertResult;\n\n        } catch (error) {\n\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) { }\n            }\n            throw error;\n\n        } finally {\n\n            // console.time(\".releasing connection\");\n            if (queryRunner !== this.queryRunner) { // means we created our own query runner\n                await queryRunner.release();\n            }\n            if (this.connection.driver instanceof SqljsDriver && !queryRunner.isTransactionActive) {\n                await this.connection.driver.autoSave();\n            }\n            // console.timeEnd(\".releasing connection\");\n            // console.timeEnd(\"QueryBuilder.execute\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies INTO which entity's table insertion will be executed.\n     */\n    into<T>(entityTarget: EntityTarget<T>, columns?: string[]): InsertQueryBuilder<T> {\n        entityTarget = entityTarget instanceof EntitySchema ? entityTarget.options.name : entityTarget;\n        const mainAlias = this.createFromAlias(entityTarget);\n        this.expressionMap.setMainAlias(mainAlias);\n        this.expressionMap.insertColumns = columns || [];\n        return (this as any) as InsertQueryBuilder<T>;\n    }\n\n    /**\n     * Values needs to be inserted into table.\n     */\n    values(values: QueryDeepPartialEntity<Entity>|QueryDeepPartialEntity<Entity>[]): this {\n        this.expressionMap.valuesSet = values;\n        return this;\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this;\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this;\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string|string[]): this;\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string|string[]): this {\n        return this.returning(output);\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this;\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this;\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string|string[]): this;\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string|string[]): this {\n\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported())\n            throw new ReturningStatementNotSupportedError();\n\n        this.expressionMap.returning = returning;\n        return this;\n    }\n\n    /**\n     * Indicates if entity must be updated after insertion operations.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled;\n        return this;\n    }\n\n    /**\n     * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n     */\n    onConflict(statement: string): this {\n        this.expressionMap.onConflict = statement;\n        return this;\n    }\n\n    /**\n     * Adds additional ignore statement supported in databases.\n     */\n    orIgnore(statement: string | boolean = true): this {\n        this.expressionMap.onIgnore = statement;\n        return this;\n    }\n\n    /**\n     * Adds additional update statement supported in databases.\n     */\n    orUpdate(statement?: { columns?: string[], overwrite?: string[], conflict_target?: string | string[] }): this {\n      this.expressionMap.onUpdate = {};\n      if (statement && Array.isArray(statement.conflict_target))\n          this.expressionMap.onUpdate.conflict = ` ( ${statement.conflict_target.map((columnName) => this.escape(columnName)).join(\", \")} ) `;\n      if (statement && typeof statement.conflict_target === \"string\")\n          this.expressionMap.onUpdate.conflict = ` ON CONSTRAINT ${this.escape(statement.conflict_target)} `;\n      if (statement && Array.isArray(statement.columns))\n          this.expressionMap.onUpdate.columns = statement.columns.map(column => `${this.escape(column)} = :${column}`).join(\", \");\n      if (statement && Array.isArray(statement.overwrite)) {\n        if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n          this.expressionMap.onUpdate.overwrite = statement.overwrite.map(column => `${column} = VALUES(${column})`).join(\", \");\n        } else if (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof AbstractSqliteDriver || this.connection.driver instanceof CockroachDriver) {\n          this.expressionMap.onUpdate.overwrite = statement.overwrite.map(column => `${this.escape(column)} = EXCLUDED.${this.escape(column)}`).join(\", \");\n        }\n      }\n      return this;\n  }\n\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates INSERT express used to perform insert query.\n     */\n    protected createInsertExpression() {\n        const tableName = this.getTableName(this.getMainTableName());\n        const valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n        const returningExpression = (this.connection.driver instanceof OracleDriver && this.getValueSets().length > 1) ? null : this.createReturningExpression(); // oracle doesnt support returning with multi-row insert\n        const columnsExpression = this.createColumnNamesExpression();\n        let query = \"INSERT \";\n\n        if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n          query += `${this.expressionMap.onIgnore ? \" IGNORE \" : \"\"}`;\n        }\n\n        query += `INTO ${tableName}`;\n\n        // add columns expression\n        if (columnsExpression) {\n            query += `(${columnsExpression})`;\n        } else {\n            if (!valuesExpression && (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver)) // special syntax for mysql DEFAULT VALUES insertion\n                query += \"()\";\n        }\n\n        // add OUTPUT expression\n        if (returningExpression && this.connection.driver instanceof SqlServerDriver) {\n            query += ` OUTPUT ${returningExpression}`;\n        }\n\n        // add VALUES expression\n        if (valuesExpression) {\n            if (this.connection.driver instanceof OracleDriver && this.getValueSets().length > 1) {\n                query += ` ${valuesExpression}`;\n            } else {\n                query += ` VALUES ${valuesExpression}`;\n            }\n        } else {\n            if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) { // special syntax for mysql DEFAULT VALUES insertion\n                query += \" VALUES ()\";\n            } else {\n                query += ` DEFAULT VALUES`;\n            }\n        }\n        if (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof AbstractSqliteDriver || this.connection.driver instanceof CockroachDriver) {\n          query += `${this.expressionMap.onIgnore ? \" ON CONFLICT DO NOTHING \" : \"\"}`;\n          query += `${this.expressionMap.onConflict ? \" ON CONFLICT \" + this.expressionMap.onConflict : \"\"}`;\n          if (this.expressionMap.onUpdate) {\n            const { overwrite, columns, conflict } = this.expressionMap.onUpdate;\n            query += `${columns ? \" ON CONFLICT \" + conflict + \" DO UPDATE SET \" + columns : \"\"}`;\n            query += `${overwrite ? \" ON CONFLICT \" + conflict + \" DO UPDATE SET \" + overwrite : \"\"}`;\n          }\n        } else if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) {\n            if (this.expressionMap.onUpdate) {\n              const { overwrite, columns } = this.expressionMap.onUpdate;\n              query += `${columns ? \" ON DUPLICATE KEY UPDATE \" + columns : \"\"}`;\n              query += `${overwrite ? \" ON DUPLICATE KEY UPDATE \" + overwrite : \"\"}`;\n            }\n        }\n\n        // add RETURNING expression\n        if (returningExpression && (this.connection.driver instanceof PostgresDriver || this.connection.driver instanceof OracleDriver || this.connection.driver instanceof CockroachDriver)) {\n            query += ` RETURNING ${returningExpression}`;\n        }\n\n\n        // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n        // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n        if (this.connection.driver instanceof SqlServerDriver\n            && this.expressionMap.mainAlias!.hasMetadata\n            && this.expressionMap.mainAlias!.metadata.columns\n                .filter((column) => this.expressionMap.insertColumns.length > 0 ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert)\n                .some((column) => this.isOverridingAutoIncrementBehavior(column))\n        ) {\n            query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;\n        }\n\n        return query;\n    }\n\n    /**\n     * Gets list of columns where values must be inserted to.\n     */\n    protected getInsertedColumns(): ColumnMetadata[] {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            return [];\n\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\n\n            // if user specified list of columns he wants to insert to, then we filter only them\n            if (this.expressionMap.insertColumns.length)\n                return this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1;\n\n            // skip columns the user doesn't want included by default\n            if (!column.isInsert) { return false; }\n\n            // if user did not specified such list then return all columns except auto-increment one\n            // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n            if (column.isGenerated && column.generationStrategy === \"increment\"\n                && !(this.connection.driver instanceof OracleDriver)\n                && !(this.connection.driver instanceof AbstractSqliteDriver)\n                && !(this.connection.driver instanceof MysqlDriver)\n                && !(this.connection.driver instanceof AuroraDataApiDriver)\n                && !(this.connection.driver instanceof SqlServerDriver && this.isOverridingAutoIncrementBehavior(column)))\n                return false;\n\n            return true;\n        });\n    }\n\n    /**\n     * Creates a columns string where values must be inserted to for INSERT INTO expression.\n     */\n    protected createColumnNamesExpression(): string {\n        const columns = this.getInsertedColumns();\n        if (columns.length > 0)\n            return columns.map(column => this.escape(column.databaseName)).join(\", \");\n\n        // in the case if there are no insert columns specified and table without metadata used\n        // we get columns from the inserted value map, in the case if only one inserted map is specified\n        if (!this.expressionMap.mainAlias!.hasMetadata && !this.expressionMap.insertColumns.length) {\n            const valueSets = this.getValueSets();\n            if (valueSets.length === 1)\n                return Object.keys(valueSets[0]).map(columnName => this.escape(columnName)).join(\", \");\n        }\n\n        // get a table name and all column database names\n        return this.expressionMap.insertColumns.map(columnName => this.escape(columnName)).join(\", \");\n    }\n\n    /**\n     * Creates list of values needs to be inserted in the VALUES expression.\n     */\n    protected createValuesExpression(): string {\n        const valueSets = this.getValueSets();\n        const columns = this.getInsertedColumns();\n\n        // if column metadatas are given then apply all necessary operations with values\n        if (columns.length > 0) {\n            let expression = \"\";\n            let parametersCount = Object.keys(this.expressionMap.nativeParameters).length;\n            valueSets.forEach((valueSet, valueSetIndex) => {\n                columns.forEach((column, columnIndex) => {\n                    if (columnIndex === 0) {\n                        if (this.connection.driver instanceof OracleDriver && valueSets.length > 1) {\n                            expression += \" SELECT \";\n                        } else {\n                            expression += \"(\";\n                        }\n                    }\n                    const paramName = \"i\" + valueSetIndex + \"_\" + column.databaseName;\n\n                    // extract real value from the entity\n                    let value = column.getEntityValue(valueSet);\n\n                    // if column is relational and value is an object then get real referenced column value from this object\n                    // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n                    // and we extract \"1\" from this object\n                    /*if (column.referencedColumn && value instanceof Object && !(value instanceof Function)) { // todo: check if we still need it since getEntityValue already has similar code\n                        value = column.referencedColumn.getEntityValue(value);\n                    }*/\n\n\n                    if (!(value instanceof Function)) {\n                      // make sure our value is normalized by a driver\n                      value = this.connection.driver.preparePersistentValue(value, column);\n                    }\n\n                    // newly inserted entities always have a version equal to 1 (first version)\n                    // also, user-specified version must be empty\n                    if (column.isVersion && value === undefined) {\n                        expression += \"1\";\n\n                    // } else if (column.isNestedSetLeft) {\n                    //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                    //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                    //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                    //     expression += subQuery;\n                    //\n                    // } else if (column.isNestedSetRight) {\n                    //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                    //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                    //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                    //     expression += subQuery;\n\n                    } else if (column.isDiscriminator) {\n                        this.expressionMap.nativeParameters[\"discriminator_value_\" + parametersCount] = this.expressionMap.mainAlias!.metadata.discriminatorValue;\n                        expression += this.connection.driver.createParameter(\"discriminator_value_\" + parametersCount, parametersCount);\n                        parametersCount++;\n                        // return \"1\";\n\n                    // for create and update dates we insert current date\n                    // no, we don't do it because this constant is already in \"default\" value of the column\n                    // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n                    // } else if (column.isCreateDate || column.isUpdateDate) {\n                    //     return \"CURRENT_TIMESTAMP\";\n\n                    // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n                    } else if (column.isGenerated && column.generationStrategy === \"uuid\" && !this.connection.driver.isUUIDGenerationSupported() && value === undefined) {\n\n                        const paramName = \"uuid_\" + column.databaseName + valueSetIndex;\n                        value = RandomGenerator.uuid4();\n                        this.expressionMap.nativeParameters[paramName] = value;\n                        expression += this.connection.driver.createParameter(paramName, parametersCount);\n                        parametersCount++;\n\n                    // if value for this column was not provided then insert default value\n                    } else if (value === undefined) {\n                        if ((this.connection.driver instanceof OracleDriver && valueSets.length > 1) || this.connection.driver instanceof AbstractSqliteDriver || this.connection.driver instanceof SapDriver) { // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n                            if (column.default !== undefined && column.default !== null) { // try to use default defined in the column\n                                expression += this.connection.driver.normalizeDefault(column);\n                            } else {\n                                expression += \"NULL\"; // otherwise simply use NULL and pray if column is nullable\n                            }\n\n                        } else {\n                            expression += \"DEFAULT\";\n                        }\n\n                    // support for SQL expressions in queries\n                    } else if (value instanceof Function) {\n                        expression += value();\n\n                    // just any other regular value\n                    } else {\n                        if (this.connection.driver instanceof SqlServerDriver)\n                            value = this.connection.driver.parametrizeValue(column, value);\n\n                        // we need to store array values in a special class to make sure parameter replacement will work correctly\n                        // if (value instanceof Array)\n                        //     value = new ArrayParameter(value);\n\n                        this.expressionMap.nativeParameters[paramName] = value;\n                        if ((this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            const useLegacy = this.connection.driver.options.legacySpatialSupport;\n                            const geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n                            if (column.srid != null) {\n                                expression += `${geomFromText}(${this.connection.driver.createParameter(paramName, parametersCount)}, ${column.srid})`;\n                            } else {\n                                expression += `${geomFromText}(${this.connection.driver.createParameter(paramName, parametersCount)})`;\n                            }\n                        } else if (this.connection.driver instanceof PostgresDriver && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            if (column.srid != null) {\n                              expression += `ST_SetSRID(ST_GeomFromGeoJSON(${this.connection.driver.createParameter(paramName, parametersCount)}), ${column.srid})::${column.type}`;\n                            } else {\n                              expression += `ST_GeomFromGeoJSON(${this.connection.driver.createParameter(paramName, parametersCount)})::${column.type}`;\n                            }\n                        } else if (this.connection.driver instanceof SqlServerDriver && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            expression += column.type + \"::STGeomFromText(\" + this.connection.driver.createParameter(paramName, parametersCount) + \", \" + (column.srid || \"0\") + \")\";\n                        } else {\n                            expression += this.connection.driver.createParameter(paramName, parametersCount);\n                        }\n                        parametersCount++;\n                    }\n\n                    if (columnIndex === columns.length - 1) {\n                        if (valueSetIndex === valueSets.length - 1) {\n                            if (this.connection.driver instanceof OracleDriver && valueSets.length > 1) {\n                                expression += \" FROM DUAL \";\n                            } else {\n                                expression += \")\";\n                            }\n                        } else {\n                            if (this.connection.driver instanceof OracleDriver && valueSets.length > 1) {\n                                expression += \" FROM DUAL UNION ALL \";\n                            } else {\n                                expression += \"), \";\n                            }\n                        }\n                    } else {\n                        expression += \", \";\n                    }\n                });\n            });\n            if (expression === \"()\")\n                return \"\";\n\n            return expression;\n        } else { // for tables without metadata\n            // get values needs to be inserted\n            let expression = \"\";\n            let parametersCount = Object.keys(this.expressionMap.nativeParameters).length;\n\n            valueSets.forEach((valueSet, insertionIndex) => {\n                const columns = Object.keys(valueSet);\n                columns.forEach((columnName, columnIndex) => {\n                    if (columnIndex === 0) {\n                        expression += \"(\";\n                    }\n                    const paramName = \"i\" + insertionIndex + \"_\" + columnName;\n                    const value = valueSet[columnName];\n\n                    // support for SQL expressions in queries\n                    if (value instanceof Function) {\n                        expression += value();\n\n                    // if value for this column was not provided then insert default value\n                    } else if (value === undefined) {\n                        if (this.connection.driver instanceof AbstractSqliteDriver || this.connection.driver instanceof SapDriver) {\n                            expression += \"NULL\";\n\n                        } else {\n                            expression += \"DEFAULT\";\n                        }\n\n                    // just any other regular value\n                    } else {\n                        this.expressionMap.nativeParameters[paramName] = value;\n                        expression += this.connection.driver.createParameter(paramName, parametersCount);\n                        parametersCount++;\n                    }\n\n                    if (columnIndex === Object.keys(valueSet).length - 1) {\n                        if (insertionIndex === valueSets.length - 1) {\n                            expression += \")\";\n                        } else {\n                            expression += \"), \";\n                        }\n                    }\n                    else {\n                        expression += \", \";\n                    }\n                });\n            });\n            if (expression === \"()\")\n                return \"\";\n            return expression;\n        }\n    }\n\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    protected getValueSets(): ObjectLiteral[] {\n        if (Array.isArray(this.expressionMap.valuesSet))\n            return this.expressionMap.valuesSet;\n\n        if (this.expressionMap.valuesSet instanceof Object)\n            return [this.expressionMap.valuesSet];\n\n        throw new InsertValuesMissingError();\n    }\n\n    /**\n     * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n     * \n     * @param column\n     */\n    protected isOverridingAutoIncrementBehavior(column: ColumnMetadata): boolean {\n        return column.isPrimary \n                && column.isGenerated \n                && column.generationStrategy === \"increment\"\n                && this.getValueSets().some((valueSet) => \n                    column.getEntityValue(valueSet) !== undefined \n                    && column.getEntityValue(valueSet) !== null\n                );\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}