{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { PlatformTools } from \"../platform/PlatformTools\";\n/**\n * Caches query result into Redis database.\n */\n\nvar RedisQueryResultCache =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function RedisQueryResultCache(connection, clientType) {\n    this.connection = connection;\n    this.clientType = clientType;\n    this.redis = this.loadRedis();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates a connection with given cache provider.\n   */\n\n\n  RedisQueryResultCache.prototype.connect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cacheOptions;\n      return __generator(this, function (_a) {\n        cacheOptions = this.connection.options.cache;\n\n        if (this.clientType === \"redis\") {\n          if (cacheOptions && cacheOptions.options) {\n            this.client = this.redis.createClient(cacheOptions.options);\n          } else {\n            this.client = this.redis.createClient();\n          }\n        } else if (this.clientType === \"ioredis\") {\n          if (cacheOptions && cacheOptions.port) {\n            if (cacheOptions.options) {\n              this.client = new this.redis(cacheOptions.port, cacheOptions.options);\n            } else {\n              this.client = new this.redis(cacheOptions.port);\n            }\n          } else if (cacheOptions && cacheOptions.options) {\n            this.client = new this.redis(cacheOptions.options);\n          } else {\n            this.client = new this.redis();\n          }\n        } else if (this.clientType === \"ioredis/cluster\") {\n          if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {\n            this.client = new this.redis.Cluster(cacheOptions.options);\n          } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {\n            this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);\n          } else {\n            throw new Error(\"options.startupNodes required for \" + this.clientType + \".\");\n          }\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Disconnects the connection\n   */\n\n\n  RedisQueryResultCache.prototype.disconnect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (ok, fail) {\n          _this.client.quit(function (err, result) {\n            if (err) return fail(err);\n            ok();\n            _this.client = undefined;\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n\n\n  RedisQueryResultCache.prototype.synchronize = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Caches given query result.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n\n\n  RedisQueryResultCache.prototype.getFromCache = function (options, queryRunner) {\n    var _this = this;\n\n    return new Promise(function (ok, fail) {\n      if (options.identifier) {\n        _this.client.get(options.identifier, function (err, result) {\n          if (err) return fail(err);\n          ok(JSON.parse(result));\n        });\n      } else if (options.query) {\n        _this.client.get(options.query, function (err, result) {\n          if (err) return fail(err);\n          ok(JSON.parse(result));\n        });\n      } else {\n        ok(undefined);\n      }\n    });\n  };\n  /**\n   * Checks if cache is expired or not.\n   */\n\n\n  RedisQueryResultCache.prototype.isExpired = function (savedCache) {\n    return savedCache.time + savedCache.duration < new Date().getTime();\n  };\n  /**\n   * Stores given query result in the cache.\n   */\n\n\n  RedisQueryResultCache.prototype.storeInCache = function (options, savedCache, queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (ok, fail) {\n          if (options.identifier) {\n            _this.client.set(options.identifier, JSON.stringify(options), \"PX\", options.duration, function (err, result) {\n              if (err) return fail(err);\n              ok();\n            });\n          } else if (options.query) {\n            _this.client.set(options.query, JSON.stringify(options), \"PX\", options.duration, function (err, result) {\n              if (err) return fail(err);\n              ok();\n            });\n          }\n        })];\n      });\n    });\n  };\n  /**\n   * Clears everything stored in the cache.\n   */\n\n\n  RedisQueryResultCache.prototype.clear = function (queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (ok, fail) {\n          _this.client.flushdb(function (err, result) {\n            if (err) return fail(err);\n            ok();\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n\n\n  RedisQueryResultCache.prototype.remove = function (identifiers, queryRunner) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all(identifiers.map(function (identifier) {\n              return _this.deleteKey(identifier);\n            }))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Removes a single key from redis database.\n   */\n\n\n  RedisQueryResultCache.prototype.deleteKey = function (key) {\n    var _this = this;\n\n    return new Promise(function (ok, fail) {\n      _this.client.del(key, function (err, result) {\n        if (err) return fail(err);\n        ok();\n      });\n    });\n  };\n  /**\n   * Loads redis dependency.\n   */\n\n\n  RedisQueryResultCache.prototype.loadRedis = function () {\n    try {\n      if (this.clientType === \"ioredis/cluster\") {\n        return PlatformTools.load(\"ioredis\");\n      } else {\n        return PlatformTools.load(this.clientType);\n      }\n    } catch (e) {\n      throw new Error(\"Cannot use cache because \" + this.clientType + \" is not installed. Please run \\\"npm i \" + this.clientType + \" --save\\\".\");\n    }\n  };\n\n  return RedisQueryResultCache;\n}();\n\nexport { RedisQueryResultCache };","map":{"version":3,"sources":["../browser/src/cache/RedisQueryResultCache.ts"],"names":[],"mappings":"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","sourcesContent":["import {QueryResultCache} from \"./QueryResultCache\";\nimport {QueryResultCacheOptions} from \"./QueryResultCacheOptions\";\nimport {PlatformTools} from \"../platform/PlatformTools\";\nimport {Connection} from \"../connection/Connection\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\n\n/**\n * Caches query result into Redis database.\n */\nexport class RedisQueryResultCache implements QueryResultCache {\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Redis module instance loaded dynamically.\n     */\n    protected redis: any;\n\n    /**\n     * Connected redis client.\n     */\n    protected client: any;\n\n    /**\n     * Type of the Redis Client (redis or ioredis).\n     */\n    protected clientType: \"redis\" | \"ioredis\" | \"ioredis/cluster\";\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection, clientType: \"redis\" | \"ioredis\" | \"ioredis/cluster\") {\n        this.clientType = clientType;\n        this.redis = this.loadRedis();\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a connection with given cache provider.\n     */\n\n\n    async connect(): Promise<void> {\n        const cacheOptions: any = this.connection.options.cache;\n        if (this.clientType === \"redis\") {\n            if (cacheOptions && cacheOptions.options) {\n                this.client = this.redis.createClient(cacheOptions.options);\n            } else {\n                this.client = this.redis.createClient();\n            }\n        } else if (this.clientType === \"ioredis\") {\n            if (cacheOptions && cacheOptions.port) {\n                if (cacheOptions.options) {\n                    this.client = new this.redis( cacheOptions.port, cacheOptions.options );\n                } else {\n                    this.client = new this.redis( cacheOptions.port );\n                }\n            }\n            else if (cacheOptions && cacheOptions.options) {\n                this.client = new this.redis(cacheOptions.options);\n            } else {\n                this.client = new this.redis();\n            }\n        } else if (this.clientType === \"ioredis/cluster\") {\n            if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {\n                this.client = new this.redis.Cluster(cacheOptions.options);\n            } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {\n                this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);\n            } else {\n                throw new Error(`options.startupNodes required for ${this.clientType}.`);\n            }\n        }\n    }\n\n    /**\n     * Disconnects the connection\n     */\n    async disconnect(): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.quit((err: any, result: any) => {\n                if (err) return fail(err);\n                ok();\n                this.client = undefined;\n            });\n        });\n    }\n\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner: QueryRunner): Promise<void> {\n    }\n\n    /**\n     * Caches given query result.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(options: QueryResultCacheOptions, queryRunner?: QueryRunner): Promise<QueryResultCacheOptions|undefined> {\n        return new Promise<QueryResultCacheOptions|undefined>((ok, fail) => {\n\n            if (options.identifier) {\n                this.client.get(options.identifier, (err: any, result: any) => {\n                    if (err) return fail(err);\n                    ok(JSON.parse(result));\n                });\n\n            } else if (options.query) {\n                this.client.get(options.query, (err: any, result: any) => {\n                    if (err) return fail(err);\n                    ok(JSON.parse(result));\n                });\n\n            } else {\n                ok(undefined);\n            }\n        });\n    }\n\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache: QueryResultCacheOptions): boolean {\n        return (savedCache.time! + savedCache.duration) < new Date().getTime();\n    }\n\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(options: QueryResultCacheOptions, savedCache: QueryResultCacheOptions, queryRunner?: QueryRunner): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            if (options.identifier) {\n                this.client.set(options.identifier, JSON.stringify(options), \"PX\", options.duration, (err: any, result: any) => {\n                    if (err) return fail(err);\n                    ok();\n                });\n\n            } else if (options.query) {\n                this.client.set(options.query, JSON.stringify(options), \"PX\", options.duration, (err: any, result: any) => {\n                    if (err) return fail(err);\n                    ok();\n                });\n            }\n        });\n    }\n\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner?: QueryRunner): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.flushdb((err: any, result: any) => {\n                if (err) return fail(err);\n                ok();\n            });\n        });\n    }\n\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(identifiers: string[], queryRunner?: QueryRunner): Promise<void> {\n        await Promise.all(identifiers.map(identifier => {\n            return this.deleteKey(identifier);\n        }));\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes a single key from redis database.\n     */\n    protected deleteKey(key: string): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.del(key, (err: any, result: any) => {\n                if (err) return fail(err);\n                ok();\n            });\n        });\n    }\n\n    /**\n     * Loads redis dependency.\n     */\n    protected loadRedis(): any {\n        try {\n            if (this.clientType === \"ioredis/cluster\") {\n                return PlatformTools.load(\"ioredis\");\n            } else {\n                return PlatformTools.load(this.clientType);\n            }\n        } catch (e) {\n            throw new Error(`Cannot use cache because ${this.clientType} is not installed. Please run \"npm i ${this.clientType} --save\".`);\n        }\n    }\n\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}