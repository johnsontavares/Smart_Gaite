{"ast":null,"code":"import { __awaiter, __generator, __values } from \"tslib\";\nimport { MustBeEntityError } from \"../error/MustBeEntityError\";\nimport { SubjectExecutor } from \"./SubjectExecutor\";\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\";\nimport { Subject } from \"./Subject\";\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\";\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\";\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\";\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\";\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\n\nvar EntityPersistExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function EntityPersistExecutor(connection, queryRunner, mode, target, entity, options) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.mode = mode;\n    this.target = target;\n    this.entity = entity;\n    this.options = options;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Executes persistence operation ob given entity or entities.\n   */\n\n\n  EntityPersistExecutor.prototype.execute = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryRunner, entities, entitiesInChunks, executors, executorsWithExecutableOperations, isTransactionStartedByUs, executorsWithExecutableOperations_1, executorsWithExecutableOperations_1_1, executor, e_1_1, error_1, rollbackError_1;\n\n      var e_1, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // check if entity we are going to save is valid and is an object\n            if (!this.entity || typeof this.entity !== \"object\") return [2\n            /*return*/\n            , Promise.reject(new MustBeEntityError(this.mode, this.entity))]; // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n\n            return [4\n            /*yield*/\n            , Promise.resolve()];\n\n          case 1:\n            // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n            _b.sent();\n\n            queryRunner = this.queryRunner || this.connection.createQueryRunner(); // save data in the query runner - this is useful functionality to share data from outside of the world\n            // with third classes - like subscribers and listener methods\n\n            if (this.options && this.options.data) queryRunner.data = this.options.data;\n            _b.label = 2;\n\n          case 2:\n            _b.trys.push([2,, 22, 25]);\n\n            entities = Array.isArray(this.entity) ? this.entity : [this.entity];\n            entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils.chunk(entities, this.options.chunk) : [entities];\n            return [4\n            /*yield*/\n            , Promise.all(entitiesInChunks.map(function (entities) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var subjects, cascadesSubjectBuilder;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      subjects = []; // create subjects for all entities we received for the persistence\n\n                      entities.forEach(function (entity) {\n                        var entityTarget = _this.target ? _this.target : entity.constructor;\n                        if (entityTarget === Object) throw new CannotDetermineEntityError(_this.mode);\n                        subjects.push(new Subject({\n                          metadata: _this.connection.getMetadata(entityTarget),\n                          entity: entity,\n                          canBeInserted: _this.mode === \"save\",\n                          canBeUpdated: _this.mode === \"save\",\n                          mustBeRemoved: _this.mode === \"remove\",\n                          canBeSoftRemoved: _this.mode === \"soft-remove\",\n                          canBeRecovered: _this.mode === \"recover\"\n                        }));\n                      });\n                      cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);\n                      subjects.forEach(function (subject) {\n                        // next step we build list of subjects we will operate with\n                        // these subjects are subjects that we need to insert or update alongside with main persisted entity\n                        cascadesSubjectBuilder.build(subject, _this.mode);\n                      }); // console.timeEnd(\"building cascades...\");\n                      // load database entities for all subjects we have\n                      // next step is to load database entities for all operate subjects\n                      // console.time(\"loading...\");\n\n                      return [4\n                      /*yield*/\n                      , new SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode)];\n\n                    case 1:\n                      // console.timeEnd(\"building cascades...\");\n                      // load database entities for all subjects we have\n                      // next step is to load database entities for all operate subjects\n                      // console.time(\"loading...\");\n                      _a.sent(); // console.timeEnd(\"loading...\");\n                      // console.time(\"other subjects...\");\n                      // build all related subjects and change maps\n\n\n                      if (this.mode === \"save\" || this.mode === \"soft-remove\" || this.mode === \"recover\") {\n                        new OneToManySubjectBuilder(subjects).build();\n                        new OneToOneInverseSideSubjectBuilder(subjects).build();\n                        new ManyToManySubjectBuilder(subjects).build();\n                      } else {\n                        subjects.forEach(function (subject) {\n                          if (subject.mustBeRemoved) {\n                            new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);\n                          }\n                        });\n                      } // console.timeEnd(\"other subjects...\");\n                      // console.timeEnd(\"building subjects...\");\n                      // console.log(\"subjects\", subjects);\n                      // create a subject executor\n\n\n                      return [2\n                      /*return*/\n                      , new SubjectExecutor(queryRunner, subjects, this.options)];\n                  }\n                });\n              });\n            }))];\n\n          case 3:\n            executors = _b.sent();\n            executorsWithExecutableOperations = executors.filter(function (executor) {\n              return executor.hasExecutableOperations;\n            });\n            if (executorsWithExecutableOperations.length === 0) return [2\n            /*return*/\n            ];\n            isTransactionStartedByUs = false;\n            _b.label = 4;\n\n          case 4:\n            _b.trys.push([4, 16,, 21]);\n\n            if (!!queryRunner.isTransactionActive) return [3\n            /*break*/\n            , 6];\n            if (!(!this.options || this.options.transaction !== false)) return [3\n            /*break*/\n            , 6];\n            isTransactionStartedByUs = true;\n            return [4\n            /*yield*/\n            , queryRunner.startTransaction()];\n\n          case 5:\n            _b.sent();\n\n            _b.label = 6;\n\n          case 6:\n            _b.trys.push([6, 11, 12, 13]);\n\n            executorsWithExecutableOperations_1 = __values(executorsWithExecutableOperations), executorsWithExecutableOperations_1_1 = executorsWithExecutableOperations_1.next();\n            _b.label = 7;\n\n          case 7:\n            if (!!executorsWithExecutableOperations_1_1.done) return [3\n            /*break*/\n            , 10];\n            executor = executorsWithExecutableOperations_1_1.value;\n            return [4\n            /*yield*/\n            , executor.execute()];\n\n          case 8:\n            _b.sent();\n\n            _b.label = 9;\n\n          case 9:\n            executorsWithExecutableOperations_1_1 = executorsWithExecutableOperations_1.next();\n            return [3\n            /*break*/\n            , 7];\n\n          case 10:\n            return [3\n            /*break*/\n            , 13];\n\n          case 11:\n            e_1_1 = _b.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            try {\n              if (executorsWithExecutableOperations_1_1 && !executorsWithExecutableOperations_1_1.done && (_a = executorsWithExecutableOperations_1.return)) _a.call(executorsWithExecutableOperations_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 13:\n            if (!(isTransactionStartedByUs === true)) return [3\n            /*break*/\n            , 15];\n            return [4\n            /*yield*/\n            , queryRunner.commitTransaction()];\n\n          case 14:\n            _b.sent();\n\n            _b.label = 15;\n\n          case 15:\n            return [3\n            /*break*/\n            , 21];\n\n          case 16:\n            error_1 = _b.sent();\n            if (!isTransactionStartedByUs) return [3\n            /*break*/\n            , 20];\n            _b.label = 17;\n\n          case 17:\n            _b.trys.push([17, 19,, 20]);\n\n            return [4\n            /*yield*/\n            , queryRunner.rollbackTransaction()];\n\n          case 18:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 20];\n\n          case 19:\n            rollbackError_1 = _b.sent();\n            return [3\n            /*break*/\n            , 20];\n\n          case 20:\n            throw error_1;\n\n          case 21:\n            return [3\n            /*break*/\n            , 25];\n\n          case 22:\n            if (!!this.queryRunner) return [3\n            /*break*/\n            , 24];\n            return [4\n            /*yield*/\n            , queryRunner.release()];\n\n          case 23:\n            _b.sent();\n\n            _b.label = 24;\n\n          case 24:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 25:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return EntityPersistExecutor;\n}();\n\nexport { EntityPersistExecutor };","map":{"version":3,"sources":["../browser/src/persistence/EntityPersistExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {MustBeEntityError} from \"../error/MustBeEntityError\";\nimport {SubjectExecutor} from \"./SubjectExecutor\";\nimport {CannotDetermineEntityError} from \"../error/CannotDetermineEntityError\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Connection} from \"../connection/Connection\";\nimport {Subject} from \"./Subject\";\nimport {OneToManySubjectBuilder} from \"./subject-builder/OneToManySubjectBuilder\";\nimport {OneToOneInverseSideSubjectBuilder} from \"./subject-builder/OneToOneInverseSideSubjectBuilder\";\nimport {ManyToManySubjectBuilder} from \"./subject-builder/ManyToManySubjectBuilder\";\nimport {SubjectDatabaseEntityLoader} from \"./SubjectDatabaseEntityLoader\";\nimport {CascadesSubjectBuilder} from \"./subject-builder/CascadesSubjectBuilder\";\nimport {OrmUtils} from \"../util/OrmUtils\";\n\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunner: QueryRunner|undefined,\n                protected mode: \"save\"|\"remove\"|\"soft-remove\"|\"recover\",\n                protected target: Function|string|undefined,\n                protected entity: ObjectLiteral|ObjectLiteral[],\n                protected options?: SaveOptions & RemoveOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes persistence operation ob given entity or entities.\n     */\n    async execute(): Promise<void> {\n\n        // check if entity we are going to save is valid and is an object\n        if (!this.entity || typeof this.entity !== \"object\")\n            return Promise.reject(new MustBeEntityError(this.mode, this.entity));\n\n        // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n        await Promise.resolve();\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n        // save data in the query runner - this is useful functionality to share data from outside of the world\n        // with third classes - like subscribers and listener methods\n        if (this.options && this.options.data)\n            queryRunner.data = this.options.data;\n\n        try {\n\n            // collect all operate subjects\n            const entities: ObjectLiteral[] = Array.isArray(this.entity) ? this.entity : [this.entity];\n            const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils.chunk(entities, this.options.chunk) : [entities];\n\n            // console.time(\"building subject executors...\");\n            const executors = await Promise.all(entitiesInChunks.map(async entities => {\n                const subjects: Subject[] = [];\n\n                // create subjects for all entities we received for the persistence\n                entities.forEach(entity => {\n                    const entityTarget = this.target ? this.target : entity.constructor;\n                    if (entityTarget === Object)\n                        throw new CannotDetermineEntityError(this.mode);\n\n                    subjects.push(new Subject({\n                        metadata: this.connection.getMetadata(entityTarget),\n                        entity: entity,\n                        canBeInserted: this.mode === \"save\",\n                        canBeUpdated: this.mode === \"save\",\n                        mustBeRemoved: this.mode === \"remove\",\n                        canBeSoftRemoved: this.mode === \"soft-remove\",\n                        canBeRecovered: this.mode === \"recover\"\n                    }));\n                });\n\n                // console.time(\"building cascades...\");\n                // go through each entity with metadata and create subjects and subjects by cascades for them\n                const cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);\n                subjects.forEach(subject => {\n                    // next step we build list of subjects we will operate with\n                    // these subjects are subjects that we need to insert or update alongside with main persisted entity\n                    cascadesSubjectBuilder.build(subject, this.mode);\n                });\n                // console.timeEnd(\"building cascades...\");\n\n                // load database entities for all subjects we have\n                // next step is to load database entities for all operate subjects\n                // console.time(\"loading...\");\n                await new SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode);\n                // console.timeEnd(\"loading...\");\n\n                // console.time(\"other subjects...\");\n                // build all related subjects and change maps\n                if (this.mode === \"save\" || this.mode === \"soft-remove\" || this.mode === \"recover\") {\n                    new OneToManySubjectBuilder(subjects).build();\n                    new OneToOneInverseSideSubjectBuilder(subjects).build();\n                    new ManyToManySubjectBuilder(subjects).build();\n                } else {\n                    subjects.forEach(subject => {\n                        if (subject.mustBeRemoved) {\n                            new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);\n                        }\n                    });\n                }\n                // console.timeEnd(\"other subjects...\");\n                // console.timeEnd(\"building subjects...\");\n                // console.log(\"subjects\", subjects);\n\n                // create a subject executor\n                return new SubjectExecutor(queryRunner, subjects, this.options);\n            }));\n            // console.timeEnd(\"building subject executors...\");\n\n            // make sure we have at least one executable operation before we create a transaction and proceed\n            // if we don't have operations it means we don't really need to update or remove something\n            const executorsWithExecutableOperations = executors.filter(executor => executor.hasExecutableOperations);\n            if (executorsWithExecutableOperations.length === 0)\n                return;\n\n            // start execute queries in a transaction\n            // if transaction is already opened in this query runner then we don't touch it\n            // if its not opened yet then we open it here, and once we finish - we close it\n            let isTransactionStartedByUs = false;\n            try {\n\n                // open transaction if its not opened yet\n                if (!queryRunner.isTransactionActive) {\n                    if (!this.options || this.options.transaction !== false) { // start transaction until it was not explicitly disabled\n                        isTransactionStartedByUs = true;\n                        await queryRunner.startTransaction();\n                    }\n                }\n\n                // execute all persistence operations for all entities we have\n                // console.time(\"executing subject executors...\");\n                for (const executor of executorsWithExecutableOperations) {\n                    await executor.execute();\n                }\n                // console.timeEnd(\"executing subject executors...\");\n\n                // commit transaction if it was started by us\n                // console.time(\"commit\");\n                if (isTransactionStartedByUs === true)\n                    await queryRunner.commitTransaction();\n                // console.timeEnd(\"commit\");\n\n            } catch (error) {\n\n                // rollback transaction if it was started by us\n                if (isTransactionStartedByUs) {\n                    try {\n                        await queryRunner.rollbackTransaction();\n                    } catch (rollbackError) { }\n                }\n                throw error;\n            }\n\n        } finally {\n\n            // release query runner only if its created by us\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}