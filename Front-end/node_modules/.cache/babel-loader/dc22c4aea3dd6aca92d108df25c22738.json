{"ast":null,"code":"/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n\n/**\n * A simple dependency graph\n */\n\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges, leavesOnly, result) {\n  var currentPath = [];\n  var visited = {};\n  return function DFS(currentNode) {\n    visited[currentNode] = true;\n    currentPath.push(currentNode);\n    edges[currentNode].forEach(function (node) {\n      if (!visited[node]) {\n        DFS(node);\n      } else if (currentPath.indexOf(node) >= 0) {\n        currentPath.push(node);\n        throw new Error(\"Dependency Cycle Found: \" + currentPath.join(\" -> \"));\n      }\n    });\n    currentPath.pop();\n\n    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n      result.push(currentNode);\n    }\n  };\n}\n\nvar DepGraph =\n/** @class */\nfunction () {\n  function DepGraph() {\n    this.nodes = {};\n    this.outgoingEdges = {}; // Node -> [Dependency Node]\n\n    this.incomingEdges = {}; // Node -> [Dependant Node]\n  }\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n\n\n  DepGraph.prototype.addNode = function (node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  };\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n\n\n  DepGraph.prototype.removeNode = function (node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          var idx = edgeList[key].indexOf(node);\n\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  };\n  /**\n   * Check if a node exists in the graph\n   */\n\n\n  DepGraph.prototype.hasNode = function (node) {\n    return this.nodes.hasOwnProperty(node);\n  };\n  /**\n   * Get the data associated with a node name\n   */\n\n\n  DepGraph.prototype.getNodeData = function (node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  };\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n\n\n  DepGraph.prototype.setNodeData = function (node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  };\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n\n\n  DepGraph.prototype.addDependency = function (from, to) {\n    if (!this.hasNode(from)) {\n      throw new Error(\"Node does not exist: \" + from);\n    }\n\n    if (!this.hasNode(to)) {\n      throw new Error(\"Node does not exist: \" + to);\n    }\n\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n\n    return true;\n  };\n  /**\n   * Remove a dependency between two nodes.\n   */\n\n\n  DepGraph.prototype.removeDependency = function (from, to) {\n    var idx;\n\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  };\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n\n\n  DepGraph.prototype.dependenciesOf = function (node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n      DFS(node);\n      var idx = result.indexOf(node);\n\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n\n      return result;\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  };\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n\n\n  DepGraph.prototype.dependantsOf = function (node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(this.incomingEdges, leavesOnly, result);\n      DFS(node);\n      var idx = result.indexOf(node);\n\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n\n      return result;\n    } else {\n      throw new Error(\"Node does not exist: \" + node);\n    }\n  };\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n\n\n  DepGraph.prototype.overallOrder = function (leavesOnly) {\n    var self = this;\n    var result = [];\n    var keys = Object.keys(this.nodes);\n\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      var CycleDFS_1 = createDFS(this.outgoingEdges, false, []);\n      keys.forEach(function (n) {\n        CycleDFS_1(n);\n      });\n      var DFS_1 = createDFS(this.outgoingEdges, leavesOnly, result); // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n\n      keys.filter(function (node) {\n        return self.incomingEdges[node].length === 0;\n      }).forEach(function (n) {\n        DFS_1(n);\n      });\n      return result;\n    }\n  };\n\n  return DepGraph;\n}();\n\nexport { DepGraph };","map":{"version":3,"sources":["../browser/src/util/DepGraph.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n\n/**\n * A simple dependency graph\n */\n\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges: any, leavesOnly: any, result: any) {\n    let currentPath: any[] = [];\n    let visited: any = {};\n    return function DFS(currentNode: any) {\n        visited[currentNode] = true;\n        currentPath.push(currentNode);\n        edges[currentNode].forEach(function (node: any) {\n            if (!visited[node]) {\n                DFS(node);\n            } else if (currentPath.indexOf(node) >= 0) {\n                currentPath.push(node);\n                throw new Error(`Dependency Cycle Found: ${currentPath.join(\" -> \")}`);\n            }\n        });\n        currentPath.pop();\n        if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n            result.push(currentNode);\n        }\n    };\n}\n\n\nexport class DepGraph {\n    nodes: any = {};\n    outgoingEdges: any = {}; // Node -> [Dependency Node]\n    incomingEdges: any = {}; // Node -> [Dependant Node]\n\n    /**\n     * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n     */\n    addNode(node: any, data?: any) {\n        if (!this.hasNode(node)) {\n            // Checking the arguments length allows the user to add a node with undefined data\n            if (arguments.length === 2) {\n                this.nodes[node] = data;\n            } else {\n                this.nodes[node] = node;\n            }\n            this.outgoingEdges[node] = [];\n            this.incomingEdges[node] = [];\n        }\n    }\n\n    /**\n     * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n     */\n    removeNode(node: any) {\n        if (this.hasNode(node)) {\n            delete this.nodes[node];\n            delete this.outgoingEdges[node];\n            delete this.incomingEdges[node];\n            [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n                Object.keys(edgeList).forEach(function (key: any) {\n                    let idx = edgeList[key].indexOf(node);\n                    if (idx >= 0) {\n                        edgeList[key].splice(idx, 1);\n                    }\n                }, this);\n            });\n        }\n    }\n\n    /**\n     * Check if a node exists in the graph\n     */\n    hasNode(node: any) {\n        return this.nodes.hasOwnProperty(node);\n    }\n\n    /**\n     * Get the data associated with a node name\n     */\n    getNodeData(node: any) {\n        if (this.hasNode(node)) {\n            return this.nodes[node];\n        } else {\n            throw new Error(`Node does not exist: ${node}`);\n        }\n    }\n\n    /**\n     * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n     */\n    setNodeData(node: any, data: any) {\n        if (this.hasNode(node)) {\n            this.nodes[node] = data;\n        } else {\n            throw new Error(`Node does not exist: ${node}`);\n        }\n    }\n\n    /**\n     * Add a dependency between two nodes. If either of the nodes does not exist,\n     * an Error will be thrown.\n     */\n    addDependency(from: any, to: any) {\n        if (!this.hasNode(from)) {\n            throw new Error(`Node does not exist: ${from}`);\n        }\n        if (!this.hasNode(to)) {\n            throw new Error(`Node does not exist: ${to}`);\n        }\n        if (this.outgoingEdges[from].indexOf(to) === -1) {\n            this.outgoingEdges[from].push(to);\n        }\n        if (this.incomingEdges[to].indexOf(from) === -1) {\n            this.incomingEdges[to].push(from);\n        }\n        return true;\n    }\n\n    /**\n     * Remove a dependency between two nodes.\n     */\n    removeDependency(from: any, to: any) {\n        let idx: any;\n        if (this.hasNode(from)) {\n            idx = this.outgoingEdges[from].indexOf(to);\n            if (idx >= 0) {\n                this.outgoingEdges[from].splice(idx, 1);\n            }\n        }\n\n        if (this.hasNode(to)) {\n            idx = this.incomingEdges[to].indexOf(from);\n            if (idx >= 0) {\n                this.incomingEdges[to].splice(idx, 1);\n            }\n        }\n    }\n\n    /**\n     * Get an array containing the nodes that the specified node depends on (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n     * in the array.\n     */\n    dependenciesOf(node: any, leavesOnly: any) {\n        if (this.hasNode(node)) {\n            let result: any[] = [];\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n            DFS(node);\n            let idx = result.indexOf(node);\n            if (idx >= 0) {\n                result.splice(idx, 1);\n            }\n            return result;\n        }\n        else {\n            throw new Error(`Node does not exist: ${node}`);\n        }\n    }\n\n    /**\n     * get an array containing the nodes that depend on the specified node (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n     */\n    dependantsOf(node: any, leavesOnly: any) {\n        if (this.hasNode(node)) {\n            let result: any[] = [];\n            let DFS = createDFS(this.incomingEdges, leavesOnly, result);\n            DFS(node);\n            let idx = result.indexOf(node);\n            if (idx >= 0) {\n                result.splice(idx, 1);\n            }\n            return result;\n        } else {\n            throw new Error(`Node does not exist: ${node}`);\n        }\n    }\n\n    /**\n     * Construct the overall processing order for the dependency graph.\n     *\n     * Throws an Error if the graph has a cycle.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n     */\n    overallOrder(leavesOnly?: any) {\n        let self = this;\n        let result: any[] = [];\n        let keys = Object.keys(this.nodes);\n        if (keys.length === 0) {\n            return result; // Empty graph\n        } else {\n            // Look for cycles - we run the DFS starting at all the nodes in case there\n            // are several disconnected subgraphs inside this dependency graph.\n            let CycleDFS = createDFS(this.outgoingEdges, false, []);\n            keys.forEach(function (n: any) {\n                CycleDFS(n);\n            });\n\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n            // Find all potential starting points (nodes with nothing depending on them) an\n            // run a DFS starting at these points to get the order\n            keys.filter(function (node) {\n                return self.incomingEdges[node].length === 0;\n            }).forEach(function (n) {\n                DFS(n);\n            });\n\n            return result;\n        }\n    }\n\n}"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}