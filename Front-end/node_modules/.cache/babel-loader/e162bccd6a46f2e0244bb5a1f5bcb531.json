{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\";\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\n\nvar JunctionEntityMetadataBuilder =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function JunctionEntityMetadataBuilder(connection) {\n    this.connection = connection;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds EntityMetadata for the junction of the given many-to-many relation.\n   */\n\n\n  JunctionEntityMetadataBuilder.prototype.build = function (relation, joinTable) {\n    var _this = this;\n\n    var referencedColumns = this.collectReferencedColumns(relation, joinTable);\n    var inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);\n    var joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : \"\");\n    var entityMetadata = new EntityMetadata({\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: joinTableName,\n        type: \"junction\",\n        database: joinTable.database || relation.entityMetadata.database,\n        schema: joinTable.schema || relation.entityMetadata.schema\n      }\n    });\n    entityMetadata.build(); // create original side junction columns\n\n    var junctionColumns = referencedColumns.map(function (referencedColumn) {\n      var joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(function (joinColumnArgs) {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      var columnName = joinColumn && joinColumn.name ? joinColumn.name : _this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: _this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: referencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            name: columnName,\n            length: !referencedColumn.length && (_this.connection.driver instanceof MysqlDriver || _this.connection.driver instanceof AuroraDataApiDriver) && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n            width: referencedColumn.width,\n            type: referencedColumn.type,\n            precision: referencedColumn.precision,\n            scale: referencedColumn.scale,\n            charset: referencedColumn.charset,\n            collation: referencedColumn.collation,\n            zerofill: referencedColumn.zerofill,\n            unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,\n            enum: referencedColumn.enum,\n            enumName: referencedColumn.enumName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    }); // create inverse side junction columns\n\n    var inverseJunctionColumns = inverseReferencedColumns.map(function (inverseReferencedColumn) {\n      var joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(function (joinColumnArgs) {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      var columnName = joinColumn && joinColumn.name ? joinColumn.name : _this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: _this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: inverseReferencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            length: !inverseReferencedColumn.length && (_this.connection.driver instanceof MysqlDriver || _this.connection.driver instanceof AuroraDataApiDriver) && (inverseReferencedColumn.generationStrategy === \"uuid\" || inverseReferencedColumn.type === \"uuid\") ? \"36\" : inverseReferencedColumn.length,\n            width: inverseReferencedColumn.width,\n            type: inverseReferencedColumn.type,\n            precision: inverseReferencedColumn.precision,\n            scale: inverseReferencedColumn.scale,\n            charset: inverseReferencedColumn.charset,\n            collation: inverseReferencedColumn.collation,\n            zerofill: inverseReferencedColumn.zerofill,\n            unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,\n            enum: inverseReferencedColumn.enum,\n            enumName: inverseReferencedColumn.enumName,\n            name: columnName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    });\n    this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns); // set junction table columns\n\n    entityMetadata.ownerColumns = junctionColumns;\n    entityMetadata.inverseColumns = inverseJunctionColumns;\n    entityMetadata.ownColumns = __spreadArray(__spreadArray([], __read(junctionColumns)), __read(inverseJunctionColumns));\n    entityMetadata.ownColumns.forEach(function (column) {\n      return column.relationMetadata = relation;\n    }); // create junction table foreign keys\n    // Note: UPDATE CASCADE clause is not supported in Oracle.\n\n    entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.entityMetadata,\n      columns: junctionColumns,\n      referencedColumns: referencedColumns,\n      onDelete: relation.onDelete || \"CASCADE\",\n      onUpdate: this.connection.driver instanceof OracleDriver ? \"NO ACTION\" : relation.onUpdate || \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      columns: inverseJunctionColumns,\n      referencedColumns: inverseReferencedColumns,\n      onDelete: relation.inverseRelation ? relation.inverseRelation.onDelete : \"CASCADE\",\n      onUpdate: this.connection.driver instanceof OracleDriver ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onUpdate : \"CASCADE\"\n    })] : []; // create junction table indices\n\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: junctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: inverseJunctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })]; // finally return entity metadata\n\n    return entityMetadata;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n\n\n  JunctionEntityMetadataBuilder.prototype.collectReferencedColumns = function (relation, joinTable) {\n    var hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(function (joinColumn) {\n      return !!joinColumn.referencedColumnName;\n    }) : false;\n\n    if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {\n      return relation.entityMetadata.columns.filter(function (column) {\n        return column.isPrimary;\n      });\n    } else {\n      return joinTable.joinColumns.map(function (joinColumn) {\n        var referencedColumn = relation.entityMetadata.columns.find(function (column) {\n          return column.propertyName === joinColumn.referencedColumnName;\n        });\n        if (!referencedColumn) throw new Error(\"Referenced column \" + joinColumn.referencedColumnName + \" was not found in entity \" + relation.entityMetadata.name);\n        return referencedColumn;\n      });\n    }\n  };\n  /**\n   * Collects inverse referenced columns from the given join column args.\n   */\n\n\n  JunctionEntityMetadataBuilder.prototype.collectInverseReferencedColumns = function (relation, joinTable) {\n    var hasInverseJoinColumns = !!joinTable.inverseJoinColumns;\n    var hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find(function (joinColumn) {\n      return !!joinColumn.referencedColumnName;\n    }) : false;\n\n    if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      return joinTable.inverseJoinColumns.map(function (joinColumn) {\n        var referencedColumn = relation.inverseEntityMetadata.ownColumns.find(function (column) {\n          return column.propertyName === joinColumn.referencedColumnName;\n        });\n        if (!referencedColumn) throw new Error(\"Referenced column \" + joinColumn.referencedColumnName + \" was not found in entity \" + relation.inverseEntityMetadata.name);\n        return referencedColumn;\n      });\n    }\n  };\n\n  JunctionEntityMetadataBuilder.prototype.changeDuplicatedColumnNames = function (junctionColumns, inverseJunctionColumns) {\n    var _this = this;\n\n    junctionColumns.forEach(function (junctionColumn) {\n      inverseJunctionColumns.forEach(function (inverseJunctionColumn) {\n        if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {\n          var junctionColumnName = _this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);\n\n          junctionColumn.propertyName = junctionColumnName;\n          junctionColumn.givenDatabaseName = junctionColumnName;\n\n          var inverseJunctionColumnName = _this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);\n\n          inverseJunctionColumn.propertyName = inverseJunctionColumnName;\n          inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;\n        }\n      });\n    });\n  };\n\n  return JunctionEntityMetadataBuilder;\n}();\n\nexport { JunctionEntityMetadataBuilder };","map":{"version":3,"sources":["../browser/src/metadata-builder/JunctionEntityMetadataBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {Connection} from \"../connection/Connection\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ForeignKeyMetadata} from \"../metadata/ForeignKeyMetadata\";\nimport {IndexMetadata} from \"../metadata/IndexMetadata\";\nimport {JoinTableMetadataArgs} from \"../metadata-args/JoinTableMetadataArgs\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\n\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\nexport class JunctionEntityMetadataBuilder {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds EntityMetadata for the junction of the given many-to-many relation.\n     */\n    build(relation: RelationMetadata, joinTable: JoinTableMetadataArgs): EntityMetadata {\n        const referencedColumns = this.collectReferencedColumns(relation, joinTable);\n        const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);\n\n        const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(\n            relation.entityMetadata.tableNameWithoutPrefix,\n            relation.inverseEntityMetadata.tableNameWithoutPrefix,\n            relation.propertyPath,\n            relation.inverseRelation ? relation.inverseRelation.propertyName : \"\"\n        );\n\n        const entityMetadata = new EntityMetadata({\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name: joinTableName,\n                type: \"junction\",\n                database: joinTable.database || relation.entityMetadata.database,\n                schema: joinTable.schema || relation.entityMetadata.schema,\n            }\n        });\n        entityMetadata.build();\n\n        // create original side junction columns\n        const junctionColumns = referencedColumns.map(referencedColumn => {\n            const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumnArgs => {\n                return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) &&\n                    !!joinColumnArgs.name;\n            }) : undefined;\n            const columnName = joinColumn && joinColumn.name ? joinColumn.name\n                : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);\n\n            return new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                referencedColumn: referencedColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: columnName,\n                    options: {\n                        name: columnName,\n                        length: !referencedColumn.length\n                        && (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver)\n                        && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\")\n                            ? \"36\"\n                            : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                        width: referencedColumn.width,\n                        type: referencedColumn.type,\n                        precision: referencedColumn.precision,\n                        scale: referencedColumn.scale,\n                        charset: referencedColumn.charset,\n                        collation: referencedColumn.collation,\n                        zerofill: referencedColumn.zerofill,\n                        unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,\n                        enum: referencedColumn.enum,\n                        enumName: referencedColumn.enumName,\n                        nullable: false,\n                        primary: true,\n                    }\n                }\n            });\n        });\n\n        // create inverse side junction columns\n        const inverseJunctionColumns = inverseReferencedColumns.map(inverseReferencedColumn => {\n            const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumnArgs => {\n                return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) &&\n                    !!joinColumnArgs.name;\n            }) : undefined;\n            const columnName = joinColumn && joinColumn.name ? joinColumn.name\n                : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);\n\n            return new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                referencedColumn: inverseReferencedColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: columnName,\n                    options: {\n                        length: !inverseReferencedColumn.length\n                        && (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver)\n                        && (inverseReferencedColumn.generationStrategy === \"uuid\" || inverseReferencedColumn.type === \"uuid\")\n                            ? \"36\"\n                            : inverseReferencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                        width: inverseReferencedColumn.width, // fix https://github.com/typeorm/typeorm/issues/6442\n                        type: inverseReferencedColumn.type,\n                        precision: inverseReferencedColumn.precision,\n                        scale: inverseReferencedColumn.scale,\n                        charset: inverseReferencedColumn.charset,\n                        collation: inverseReferencedColumn.collation,\n                        zerofill: inverseReferencedColumn.zerofill,\n                        unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,\n                        enum: inverseReferencedColumn.enum,\n                        enumName: inverseReferencedColumn.enumName,\n                        name: columnName,\n                        nullable: false,\n                        primary: true,\n                    }\n                }\n            });\n        });\n\n        this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);\n\n        // set junction table columns\n        entityMetadata.ownerColumns = junctionColumns;\n        entityMetadata.inverseColumns = inverseJunctionColumns;\n        entityMetadata.ownColumns = [...junctionColumns, ...inverseJunctionColumns];\n        entityMetadata.ownColumns.forEach(column => column.relationMetadata = relation);\n\n        // create junction table foreign keys\n        // Note: UPDATE CASCADE clause is not supported in Oracle.\n        entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: relation.entityMetadata,\n                columns: junctionColumns,\n                referencedColumns: referencedColumns,\n                onDelete: relation.onDelete || \"CASCADE\",\n                onUpdate: this.connection.driver instanceof OracleDriver ? \"NO ACTION\" : relation.onUpdate || \"CASCADE\",\n            }),\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: relation.inverseEntityMetadata,\n                columns: inverseJunctionColumns,\n                referencedColumns: inverseReferencedColumns,\n                onDelete: relation.inverseRelation ? relation.inverseRelation.onDelete : \"CASCADE\",\n                onUpdate: this.connection.driver instanceof OracleDriver\n                    ? \"NO ACTION\"\n                    : relation.inverseRelation\n                        ? relation.inverseRelation.onUpdate\n                        : \"CASCADE\",\n            }),\n        ] : [];\n\n        // create junction table indices\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: junctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true\n                }\n            }),\n\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: inverseJunctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true\n                }\n            })\n        ];\n\n        // finally return entity metadata\n        return entityMetadata;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    protected collectReferencedColumns(relation: RelationMetadata, joinTable: JoinTableMetadataArgs): ColumnMetadata[] {\n        const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n        if (!joinTable.joinColumns || (joinTable.joinColumns && !hasAnyReferencedColumnName)) {\n            return relation.entityMetadata.columns.filter(column => column.isPrimary);\n        } else {\n            return joinTable.joinColumns.map(joinColumn => {\n                const referencedColumn = relation.entityMetadata.columns.find(column => column.propertyName === joinColumn.referencedColumnName);\n                if (!referencedColumn)\n                    throw new Error(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);\n\n                return referencedColumn;\n            });\n        }\n    }\n\n    /**\n     * Collects inverse referenced columns from the given join column args.\n     */\n    protected collectInverseReferencedColumns(relation: RelationMetadata, joinTable: JoinTableMetadataArgs): ColumnMetadata[] {\n        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;\n        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns!.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n        if (!hasInverseJoinColumns || (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)) {\n            return relation.inverseEntityMetadata.primaryColumns;\n        } else {\n            return joinTable.inverseJoinColumns!.map(joinColumn => {\n                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName);\n                if (!referencedColumn)\n                    throw new Error(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n\n                return referencedColumn;\n            });\n        }\n    }\n\n    protected changeDuplicatedColumnNames(junctionColumns: ColumnMetadata[], inverseJunctionColumns: ColumnMetadata[]) {\n        junctionColumns.forEach(junctionColumn => {\n            inverseJunctionColumns.forEach(inverseJunctionColumn => {\n                if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {\n                    const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);\n                    junctionColumn.propertyName = junctionColumnName;\n                    junctionColumn.givenDatabaseName = junctionColumnName;\n\n                    const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);\n                    inverseJunctionColumn.propertyName = inverseJunctionColumnName;\n                    inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;\n                }\n            });\n        });\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}