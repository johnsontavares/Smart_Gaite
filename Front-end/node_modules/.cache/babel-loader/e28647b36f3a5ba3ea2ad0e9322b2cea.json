{"ast":null,"code":"/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nvar Broadcaster =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function Broadcaster(queryRunner) {\n    this.queryRunner = queryRunner;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Broadcasts \"BEFORE_INSERT\" event.\n   * Before insert event is executed before entity is being inserted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastBeforeInsertEvent = function (result, metadata, entity) {\n    var _this = this;\n\n    if (entity && metadata.beforeInsertListeners.length) {\n      metadata.beforeInsertListeners.forEach(function (listener) {\n        if (listener.isAllowed(entity)) {\n          var executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\n          var executionResult = subscriber.beforeInsert({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"BEFORE_UPDATE\" event.\n   * Before update event is executed before entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastBeforeUpdateEvent = function (result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    var _this = this;\n\n    if (entity && metadata.beforeUpdateListeners.length) {\n      metadata.beforeUpdateListeners.forEach(function (listener) {\n        if (listener.isAllowed(entity)) {\n          var executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\n          var executionResult = subscriber.beforeUpdate({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"BEFORE_REMOVE\" event.\n   * Before remove event is executed before entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastBeforeRemoveEvent = function (result, metadata, entity, databaseEntity) {\n    var _this = this;\n\n    if (entity && metadata.beforeRemoveListeners.length) {\n      metadata.beforeRemoveListeners.forEach(function (listener) {\n        if (listener.isAllowed(entity)) {\n          var executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\n          var executionResult = subscriber.beforeRemove({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_INSERT\" event.\n   * After insert event is executed after entity is being persisted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastAfterInsertEvent = function (result, metadata, entity) {\n    var _this = this;\n\n    if (entity && metadata.afterInsertListeners.length) {\n      metadata.afterInsertListeners.forEach(function (listener) {\n        if (listener.isAllowed(entity)) {\n          var executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\n          var executionResult = subscriber.afterInsert({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n   */\n\n\n  Broadcaster.prototype.broadcastBeforeTransactionStartEvent = function (result) {\n    var _this = this;\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (subscriber.beforeTransactionStart) {\n          var executionResult = subscriber.beforeTransactionStart({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_START\" event.\n   */\n\n\n  Broadcaster.prototype.broadcastAfterTransactionStartEvent = function (result) {\n    var _this = this;\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (subscriber.afterTransactionStart) {\n          var executionResult = subscriber.afterTransactionStart({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n   */\n\n\n  Broadcaster.prototype.broadcastBeforeTransactionCommitEvent = function (result) {\n    var _this = this;\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (subscriber.beforeTransactionCommit) {\n          var executionResult = subscriber.beforeTransactionCommit({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n   */\n\n\n  Broadcaster.prototype.broadcastAfterTransactionCommitEvent = function (result) {\n    var _this = this;\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (subscriber.afterTransactionCommit) {\n          var executionResult = subscriber.afterTransactionCommit({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n   */\n\n\n  Broadcaster.prototype.broadcastBeforeTransactionRollbackEvent = function (result) {\n    var _this = this;\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (subscriber.beforeTransactionRollback) {\n          var executionResult = subscriber.beforeTransactionRollback({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n   */\n\n\n  Broadcaster.prototype.broadcastAfterTransactionRollbackEvent = function (result) {\n    var _this = this;\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (subscriber.afterTransactionRollback) {\n          var executionResult = subscriber.afterTransactionRollback({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_UPDATE\" event.\n   * After update event is executed after entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastAfterUpdateEvent = function (result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    var _this = this;\n\n    if (entity && metadata.afterUpdateListeners.length) {\n      metadata.afterUpdateListeners.forEach(function (listener) {\n        if (listener.isAllowed(entity)) {\n          var executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\n          var executionResult = subscriber.afterUpdate({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_REMOVE\" event.\n   * After remove event is executed after entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastAfterRemoveEvent = function (result, metadata, entity, databaseEntity) {\n    var _this = this;\n\n    if (entity && metadata.afterRemoveListeners.length) {\n      metadata.afterRemoveListeners.forEach(function (listener) {\n        if (listener.isAllowed(entity)) {\n          var executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n        if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\n          var executionResult = subscriber.afterRemove({\n            connection: _this.queryRunner.connection,\n            queryRunner: _this.queryRunner,\n            manager: _this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  };\n  /**\n   * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n   * After load event is executed after entity has been loaded from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n\n\n  Broadcaster.prototype.broadcastLoadEventsForAll = function (result, metadata, entities) {\n    var _this = this;\n\n    entities.forEach(function (entity) {\n      if (entity instanceof Promise) // todo: check why need this?\n        return; // collect load events for all children entities that were loaded with the main entity\n\n      if (metadata.relations.length) {\n        metadata.relations.forEach(function (relation) {\n          // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n          if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;\n          var value = relation.getEntityValue(entity);\n          if (value instanceof Object) _this.broadcastLoadEventsForAll(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n        });\n      }\n\n      if (metadata.afterLoadListeners.length) {\n        metadata.afterLoadListeners.forEach(function (listener) {\n          if (listener.isAllowed(entity)) {\n            var executionResult = listener.execute(entity);\n            if (executionResult instanceof Promise) result.promises.push(executionResult);\n            result.count++;\n          }\n        });\n      }\n\n      if (_this.queryRunner.connection.subscribers.length) {\n        _this.queryRunner.connection.subscribers.forEach(function (subscriber) {\n          if (_this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad) {\n            var executionResult = subscriber.afterLoad(entity, {\n              connection: _this.queryRunner.connection,\n              queryRunner: _this.queryRunner,\n              manager: _this.queryRunner.manager,\n              entity: entity,\n              metadata: metadata\n            });\n            if (executionResult instanceof Promise) result.promises.push(executionResult);\n            result.count++;\n          }\n        });\n      }\n    });\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n   * or listens our entity.\n   */\n\n\n  Broadcaster.prototype.isAllowedSubscriber = function (subscriber, target) {\n    return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);\n  };\n\n  return Broadcaster;\n}();\n\nexport { Broadcaster };","map":{"version":3,"sources":["../browser/src/subscriber/Broadcaster.ts"],"names":[],"mappings":"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","sourcesContent":["import {EntitySubscriberInterface} from \"./EntitySubscriberInterface\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {BroadcasterResult} from \"./BroadcasterResult\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\n\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\" event.\n     * Before insert event is executed before entity is being inserted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeInsertEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral): void {\n\n        if (entity && metadata.beforeInsertListeners.length) {\n            metadata.beforeInsertListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\n                    const executionResult = subscriber.beforeInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_UPDATE\" event.\n     * Before update event is executed before entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeUpdateEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral, updatedColumns?: ColumnMetadata[], updatedRelations?: RelationMetadata[]): void { // todo: send relations too?\n        if (entity && metadata.beforeUpdateListeners.length) {\n            metadata.beforeUpdateListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\n                    const executionResult = subscriber.beforeUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || []\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_REMOVE\" event.\n     * Before remove event is executed before entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n        if (entity && metadata.beforeRemoveListeners.length) {\n            metadata.beforeRemoveListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\n                    const executionResult = subscriber.beforeRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\" event.\n     * After insert event is executed after entity is being persisted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterInsertEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral): void {\n\n        if (entity && metadata.afterInsertListeners.length) {\n            metadata.afterInsertListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\n                    const executionResult = subscriber.afterInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n     */\n    broadcastBeforeTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.beforeTransactionStart) {\n                    const executionResult = subscriber.beforeTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_START\" event.\n     */\n    broadcastAfterTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.afterTransactionStart) {\n                    const executionResult = subscriber.afterTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n     */\n    broadcastBeforeTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.beforeTransactionCommit) {\n                    const executionResult = subscriber.beforeTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n     */\n    broadcastAfterTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.afterTransactionCommit) {\n                    const executionResult = subscriber.afterTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastBeforeTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.beforeTransactionRollback) {\n                    const executionResult = subscriber.beforeTransactionRollback({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastAfterTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (subscriber.afterTransactionRollback) {\n                    const executionResult = subscriber.afterTransactionRollback({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_UPDATE\" event.\n     * After update event is executed after entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterUpdateEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral, updatedColumns?: ColumnMetadata[], updatedRelations?: RelationMetadata[]): void {\n\n        if (entity && metadata.afterUpdateListeners.length) {\n            metadata.afterUpdateListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\n                    const executionResult = subscriber.afterUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || []\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_REMOVE\" event.\n     * After remove event is executed after entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\n\n        if (entity && metadata.afterRemoveListeners.length) {\n            metadata.afterRemoveListeners.forEach(listener => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\n                    const executionResult = subscriber.afterRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastLoadEventsForAll(result: BroadcasterResult, metadata: EntityMetadata, entities: ObjectLiteral[]): void {\n        entities.forEach(entity => {\n            if (entity instanceof Promise) // todo: check why need this?\n                return;\n\n            // collect load events for all children entities that were loaded with the main entity\n            if (metadata.relations.length) {\n                metadata.relations.forEach(relation => {\n\n                    // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n                    if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName))\n                        return;\n\n                    const value = relation.getEntityValue(entity);\n                    if (value instanceof Object)\n                        this.broadcastLoadEventsForAll(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n                });\n            }\n\n            if (metadata.afterLoadListeners.length) {\n                metadata.afterLoadListeners.forEach(listener => {\n                    if (listener.isAllowed(entity)) {\n                        const executionResult = listener.execute(entity);\n                        if (executionResult instanceof Promise)\n                            result.promises.push(executionResult);\n                        result.count++;\n                    }\n                });\n            }\n\n            if (this.queryRunner.connection.subscribers.length) {\n                this.queryRunner.connection.subscribers.forEach(subscriber => {\n                    if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad) {\n                        const executionResult = subscriber.afterLoad!(entity, {\n                            connection: this.queryRunner.connection,\n                            queryRunner: this.queryRunner,\n                            manager: this.queryRunner.manager,\n                            entity: entity,\n                            metadata: metadata\n                        });\n                        if (executionResult instanceof Promise)\n                            result.promises.push(executionResult);\n                        result.count++;\n                    }\n                });\n            }\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n     * or listens our entity.\n     */\n    protected isAllowedSubscriber(subscriber: EntitySubscriberInterface<any>, target: Function|string): boolean {\n        return  !subscriber.listenTo ||\n            !subscriber.listenTo() ||\n            subscriber.listenTo() === Object ||\n            subscriber.listenTo() === target ||\n            subscriber.listenTo().isPrototypeOf(target);\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}