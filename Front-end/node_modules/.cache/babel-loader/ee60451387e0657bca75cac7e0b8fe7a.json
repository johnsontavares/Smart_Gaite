{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { ConnectionIsNotSetError } from \"../../error/ConnectionIsNotSetError\";\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\";\nimport { DriverUtils } from \"../DriverUtils\";\nimport { SqlServerQueryRunner } from \"./SqlServerQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { MssqlParameter } from \"./MssqlParameter\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\n/**\n * Organizes communication with SQL Server DBMS.\n */\n\nvar SqlServerDriver =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function SqlServerDriver(connection) {\n    /**\n     * Pool for slave databases.\n     * Used in replication.\n     */\n    this.slaves = [];\n    /**\n     * Indicates if replication is enabled.\n     */\n\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n\n    this.treeSupport = true;\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql\n     */\n\n    this.supportedDataTypes = [\"int\", \"bigint\", \"bit\", \"decimal\", \"money\", \"numeric\", \"smallint\", \"smallmoney\", \"tinyint\", \"float\", \"real\", \"date\", \"datetime2\", \"datetime\", \"datetimeoffset\", \"smalldatetime\", \"time\", \"char\", \"varchar\", \"text\", \"nchar\", \"nvarchar\", \"ntext\", \"binary\", \"image\", \"varbinary\", \"hierarchyid\", \"sql_variant\", \"timestamp\", \"uniqueidentifier\", \"xml\", \"geometry\", \"geography\", \"rowversion\"];\n    /**\n     * Gets list of spatial column data types.\n     */\n\n    this.spatialTypes = [\"geometry\", \"geography\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withLengthColumnTypes = [\"char\", \"varchar\", \"nchar\", \"nvarchar\", \"binary\", \"varbinary\"];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n\n    this.withPrecisionColumnTypes = [\"decimal\", \"numeric\", \"time\", \"datetime2\", \"datetimeoffset\"];\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n\n    this.withScaleColumnTypes = [\"decimal\", \"numeric\"];\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n\n    this.mappedDataTypes = {\n      createDate: \"datetime2\",\n      createDateDefault: \"getdate()\",\n      updateDate: \"datetime2\",\n      updateDateDefault: \"getdate()\",\n      deleteDate: \"datetime2\",\n      deleteDateNullable: true,\n      version: \"int\",\n      treeLevel: \"int\",\n      migrationId: \"int\",\n      migrationName: \"varchar\",\n      migrationTimestamp: \"bigint\",\n      cacheId: \"int\",\n      cacheIdentifier: \"nvarchar\",\n      cacheTime: \"bigint\",\n      cacheDuration: \"int\",\n      cacheQuery: \"nvarchar(MAX)\",\n      cacheResult: \"nvarchar(MAX)\",\n      metadataType: \"varchar\",\n      metadataDatabase: \"varchar\",\n      metadataSchema: \"varchar\",\n      metadataTable: \"varchar\",\n      metadataName: \"varchar\",\n      metadataValue: \"nvarchar(MAX)\"\n    };\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n\n    this.dataTypeDefaults = {\n      \"char\": {\n        length: 1\n      },\n      \"nchar\": {\n        length: 1\n      },\n      \"varchar\": {\n        length: 255\n      },\n      \"nvarchar\": {\n        length: 255\n      },\n      \"binary\": {\n        length: 1\n      },\n      \"varbinary\": {\n        length: 1\n      },\n      \"decimal\": {\n        precision: 18,\n        scale: 0\n      },\n      \"numeric\": {\n        precision: 18,\n        scale: 0\n      },\n      \"time\": {\n        precision: 7\n      },\n      \"datetime2\": {\n        precision: 7\n      },\n      \"datetimeoffset\": {\n        precision: 7\n      }\n    };\n    /**\n     * Max length allowed by MSSQL Server for aliases (identifiers).\n     * @see https://docs.microsoft.com/en-us/sql/sql-server/maximum-capacity-specifications-for-sql-server\n     */\n\n    this.maxAliasLength = 128;\n    this.connection = connection;\n    this.options = connection.options;\n    this.isReplicated = this.options.replication ? true : false; // load mssql package\n\n    this.loadDependencies(); // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way\n    // validate options to make sure everything is set\n    // if (!this.options.host)\n    // throw new DriverOptionNotSetError(\"host\");\n    // if (!this.options.username)\n    //     throw new DriverOptionNotSetError(\"username\");\n    // if (!this.options.database)\n    //     throw new DriverOptionNotSetError(\"database\");\n  } // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs connection to the database.\n   * Based on pooling options, it can either create connection immediately,\n   * either create a pool and create connection when needed.\n   */\n\n\n  SqlServerDriver.prototype.connect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, _c;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (!this.options.replication) return [3\n            /*break*/\n            , 3];\n            _a = this;\n            return [4\n            /*yield*/\n            , Promise.all(this.options.replication.slaves.map(function (slave) {\n              return _this.createPool(_this.options, slave);\n            }))];\n\n          case 1:\n            _a.slaves = _d.sent();\n            _b = this;\n            return [4\n            /*yield*/\n            , this.createPool(this.options, this.options.replication.master)];\n\n          case 2:\n            _b.master = _d.sent();\n            this.database = this.options.replication.master.database;\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            _c = this;\n            return [4\n            /*yield*/\n            , this.createPool(this.options, this.options)];\n\n          case 4:\n            _c.master = _d.sent();\n            this.database = this.options.database;\n            _d.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n\n\n  SqlServerDriver.prototype.afterConnect = function () {\n    return Promise.resolve();\n  };\n  /**\n   * Closes connection with the database.\n   */\n\n\n  SqlServerDriver.prototype.disconnect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.master) return [2\n            /*return*/\n            , Promise.reject(new ConnectionIsNotSetError(\"mssql\"))];\n            return [4\n            /*yield*/\n            , this.closePool(this.master)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , Promise.all(this.slaves.map(function (slave) {\n              return _this.closePool(slave);\n            }))];\n\n          case 2:\n            _a.sent();\n\n            this.master = undefined;\n            this.slaves = [];\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Closes connection pool.\n   */\n\n\n  SqlServerDriver.prototype.closePool = function (pool) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (ok, fail) {\n          pool.close(function (err) {\n            return err ? fail(err) : ok();\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n\n\n  SqlServerDriver.prototype.createSchemaBuilder = function () {\n    return new RdbmsSchemaBuilder(this.connection);\n  };\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n\n\n  SqlServerDriver.prototype.createQueryRunner = function (mode) {\n    return new SqlServerQueryRunner(this, mode);\n  };\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n\n\n  SqlServerDriver.prototype.escapeQueryWithParameters = function (sql, parameters, nativeParameters) {\n    var escapedParameters = Object.keys(nativeParameters).map(function (key) {\n      return nativeParameters[key];\n    });\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    var keys = Object.keys(parameters).map(function (parameter) {\n      return \"(:(\\\\.\\\\.\\\\.)?\" + parameter + \"\\\\b)\";\n    }).join(\"|\");\n    sql = sql.replace(new RegExp(keys, \"g\"), function (key) {\n      var value;\n      var isArray = false;\n\n      if (key.substr(0, 4) === \":...\") {\n        isArray = true;\n        value = parameters[key.substr(4)];\n      } else {\n        value = parameters[key.substr(1)];\n      }\n\n      if (isArray) {\n        return value.map(function (v) {\n          escapedParameters.push(v);\n          return \"@\" + (escapedParameters.length - 1);\n        }).join(\", \");\n      } else if (value instanceof Function) {\n        return value();\n      } else {\n        escapedParameters.push(value);\n        return \"@\" + (escapedParameters.length - 1);\n      }\n    }); // todo: make replace only in value statements, otherwise problems\n\n    return [sql, escapedParameters];\n  };\n  /**\n   * Escapes a column name.\n   */\n\n\n  SqlServerDriver.prototype.escape = function (columnName) {\n    return \"\\\"\" + columnName + \"\\\"\";\n  };\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. \"myDB\".\"mySchema\".\"myTable\"\n   */\n\n\n  SqlServerDriver.prototype.buildTableName = function (tableName, schema, database) {\n    var fullName = tableName;\n    if (schema) fullName = schema + \".\" + tableName;\n\n    if (database) {\n      if (!schema) {\n        fullName = database + \"..\" + tableName;\n      } else {\n        fullName = database + \".\" + fullName;\n      }\n    }\n\n    return fullName;\n  };\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n\n\n  SqlServerDriver.prototype.preparePersistentValue = function (value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n\n    if (columnMetadata.type === Boolean) {\n      return value === true ? 1 : 0;\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDate(value);\n    } else if (columnMetadata.type === \"time\") {\n      return DateUtils.mixedTimeToDate(value);\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === \"smalldatetime\" || columnMetadata.type === Date) {\n      return DateUtils.mixedDateToDate(value, false, false);\n    } else if (columnMetadata.type === \"datetime2\" || columnMetadata.type === \"datetimeoffset\") {\n      return DateUtils.mixedDateToDate(value, false, true);\n    } else if (columnMetadata.type === \"simple-array\") {\n      return DateUtils.simpleArrayToString(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      return DateUtils.simpleJsonToString(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      return DateUtils.simpleEnumToString(value);\n    }\n\n    return value;\n  };\n  /**\n   * Prepares given value to a value to be persisted, based on its column type or metadata.\n   */\n\n\n  SqlServerDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n    if (columnMetadata.type === Boolean) {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date || columnMetadata.type === \"datetime2\" || columnMetadata.type === \"smalldatetime\" || columnMetadata.type === \"datetimeoffset\") {\n      value = DateUtils.normalizeHydratedDate(value);\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      value = DateUtils.mixedTimeToString(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      value = DateUtils.stringToSimpleArray(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      value = DateUtils.stringToSimpleJson(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      value = DateUtils.stringToSimpleEnum(value, columnMetadata);\n    }\n\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  };\n  /**\n   * Creates a database type from a given column metadata.\n   */\n\n\n  SqlServerDriver.prototype.normalizeType = function (column) {\n    if (column.type === Number || column.type === \"integer\") {\n      return \"int\";\n    } else if (column.type === String) {\n      return \"nvarchar\";\n    } else if (column.type === Date) {\n      return \"datetime\";\n    } else if (column.type === Boolean) {\n      return \"bit\";\n    } else if (column.type === Buffer) {\n      return \"binary\";\n    } else if (column.type === \"uuid\") {\n      return \"uniqueidentifier\";\n    } else if (column.type === \"simple-array\" || column.type === \"simple-json\") {\n      return \"ntext\";\n    } else if (column.type === \"simple-enum\") {\n      return \"nvarchar\";\n    } else if (column.type === \"dec\") {\n      return \"decimal\";\n    } else if (column.type === \"double precision\") {\n      return \"float\";\n    } else if (column.type === \"rowversion\") {\n      return \"timestamp\"; // the rowversion type's name in SQL server metadata is timestamp\n    } else {\n      return column.type || \"\";\n    }\n  };\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n\n\n  SqlServerDriver.prototype.normalizeDefault = function (columnMetadata) {\n    var defaultValue = columnMetadata.default;\n\n    if (typeof defaultValue === \"number\") {\n      return \"\" + defaultValue;\n    } else if (typeof defaultValue === \"boolean\") {\n      return defaultValue === true ? \"1\" : \"0\";\n    } else if (typeof defaultValue === \"function\") {\n      var value = defaultValue();\n\n      if (value.toUpperCase() === \"CURRENT_TIMESTAMP\") {\n        return \"getdate()\";\n      }\n\n      return value;\n    } else if (typeof defaultValue === \"string\") {\n      return \"'\" + defaultValue + \"'\";\n    } else {\n      return defaultValue;\n    }\n  };\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n\n\n  SqlServerDriver.prototype.normalizeIsUnique = function (column) {\n    return column.entityMetadata.uniques.some(function (uq) {\n      return uq.columns.length === 1 && uq.columns[0] === column;\n    });\n  };\n  /**\n   * Returns default column lengths, which is required on column creation.\n   */\n\n\n  SqlServerDriver.prototype.getColumnLength = function (column) {\n    if (column.length) return column.length.toString();\n    if (column.type === \"varchar\" || column.type === \"nvarchar\" || column.type === String) return \"255\";\n    return \"\";\n  };\n  /**\n   * Creates column type definition including length, precision and scale\n   */\n\n\n  SqlServerDriver.prototype.createFullType = function (column) {\n    var type = column.type; // used 'getColumnLength()' method, because SqlServer sets `varchar` and `nvarchar` length to 1 by default.\n\n    if (this.getColumnLength(column)) {\n      type += \"(\" + this.getColumnLength(column) + \")\";\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += \"(\" + column.precision + \",\" + column.scale + \")\";\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += \"(\" + column.precision + \")\";\n    }\n\n    if (column.isArray) type += \" array\";\n    return type;\n  };\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n\n\n  SqlServerDriver.prototype.obtainMasterConnection = function () {\n    return Promise.resolve(this.master);\n  };\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n\n\n  SqlServerDriver.prototype.obtainSlaveConnection = function () {\n    if (!this.slaves.length) return this.obtainMasterConnection();\n    var random = Math.floor(Math.random() * this.slaves.length);\n    return Promise.resolve(this.slaves[random]);\n  };\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n\n\n  SqlServerDriver.prototype.createGeneratedMap = function (metadata, insertResult) {\n    var _this = this;\n\n    if (!insertResult) return undefined;\n    return Object.keys(insertResult).reduce(function (map, key) {\n      var column = metadata.findColumnWithDatabaseName(key);\n\n      if (column) {\n        OrmUtils.mergeDeep(map, column.createValueMap(_this.prepareHydratedValue(insertResult[key], column)));\n      }\n\n      return map;\n    }, {});\n  };\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n\n\n  SqlServerDriver.prototype.findChangedColumns = function (tableColumns, columnMetadatas) {\n    var _this = this;\n\n    return columnMetadatas.filter(function (columnMetadata) {\n      var tableColumn = tableColumns.find(function (c) {\n        return c.name === columnMetadata.databaseName;\n      });\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n\n      var isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== _this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale // || tableColumn.comment !== columnMetadata.comment || // todo\n      || tableColumn.isGenerated !== columnMetadata.isGenerated || !tableColumn.isGenerated && _this.lowerDefaultValueIfNecessary(_this.normalizeDefault(columnMetadata)) !== _this.lowerDefaultValueIfNecessary(tableColumn.default) // we included check for generated here, because generated columns already can have default values\n      || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== _this.normalizeIsUnique(columnMetadata); // DEBUG SECTION\n      // if (isColumnChanged) {\n      //     console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n      //     console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n      //     console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n      //     console.log(\"length:\", tableColumn.length, columnMetadata.length);\n      //     console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n      //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n      //     console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n      //     console.log(\"isGenerated 2:\", !tableColumn.isGenerated && this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata)) !== this.lowerDefaultValueIfNecessary(tableColumn.default));\n      //     console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n      //     console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n      //     console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n      //     console.log(\"==========================================\");\n      // }\n\n\n      return isColumnChanged;\n    });\n  };\n\n  SqlServerDriver.prototype.lowerDefaultValueIfNecessary = function (value) {\n    // SqlServer saves function calls in default value as lowercase https://github.com/typeorm/typeorm/issues/2733\n    if (!value) {\n      return value;\n    }\n\n    return value.split(\"'\").map(function (v, i) {\n      return i % 2 === 1 ? v : v.toLowerCase();\n    }).join(\"'\");\n  };\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n\n\n  SqlServerDriver.prototype.isReturningSqlSupported = function () {\n    if (this.options.options && this.options.options.disableOutputReturning) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n\n\n  SqlServerDriver.prototype.isUUIDGenerationSupported = function () {\n    return true;\n  };\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n\n\n  SqlServerDriver.prototype.isFullTextColumnTypeSupported = function () {\n    return false;\n  };\n  /**\n   * Creates an escaped parameter.\n   */\n\n\n  SqlServerDriver.prototype.createParameter = function (parameterName, index) {\n    return \"@\" + index;\n  }; // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Sql server's parameters needs to be wrapped into special object with type information about this value.\n   * This method wraps given value into MssqlParameter based on its column definition.\n   */\n\n\n  SqlServerDriver.prototype.parametrizeValue = function (column, value) {\n    // if its already MssqlParameter then simply return it\n    if (value instanceof MssqlParameter) return value;\n    var normalizedType = this.normalizeType({\n      type: column.type\n    });\n\n    if (column.length) {\n      return new MssqlParameter(value, normalizedType, column.length);\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      return new MssqlParameter(value, normalizedType, column.precision, column.scale);\n    } else if (column.precision !== null && column.precision !== undefined) {\n      return new MssqlParameter(value, normalizedType, column.precision);\n    } else if (column.scale !== null && column.scale !== undefined) {\n      return new MssqlParameter(value, normalizedType, column.scale);\n    }\n\n    return new MssqlParameter(value, normalizedType);\n  };\n  /**\n   * Sql server's parameters needs to be wrapped into special object with type information about this value.\n   * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.\n   */\n\n\n  SqlServerDriver.prototype.parametrizeMap = function (tablePath, map) {\n    var _this = this; // find metadata for the given table\n\n\n    if (!this.connection.hasMetadata(tablePath)) // if no metadata found then we can't proceed because we don't have columns and their types\n      return map;\n    var metadata = this.connection.getMetadata(tablePath);\n    return Object.keys(map).reduce(function (newMap, key) {\n      var value = map[key]; // find column metadata\n\n      var column = metadata.findColumnWithDatabaseName(key);\n      if (!column) // if we didn't find a column then we can't proceed because we don't have a column type\n        return value;\n      newMap[key] = _this.parametrizeValue(column, value);\n      return newMap;\n    }, {});\n  };\n\n  SqlServerDriver.prototype.buildTableVariableDeclaration = function (identifier, columns) {\n    var _this = this;\n\n    var outputColumns = columns.map(function (column) {\n      return _this.escape(column.databaseName) + \" \" + _this.createFullType(new TableColumn({\n        name: column.databaseName,\n        type: _this.normalizeType(column),\n        length: column.length,\n        isNullable: column.isNullable,\n        isArray: column.isArray\n      }));\n    });\n    return \"DECLARE \" + identifier + \" TABLE (\" + outputColumns.join(\", \") + \")\";\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * If driver dependency is not given explicitly, then try to load it via \"require\".\n   */\n\n\n  SqlServerDriver.prototype.loadDependencies = function () {\n    try {\n      this.mssql = PlatformTools.load(\"mssql\");\n    } catch (e) {\n      // todo: better error for browser env\n      throw new DriverPackageNotInstalledError(\"SQL Server\", \"mssql\");\n    }\n  };\n  /**\n   * Creates a new connection pool for a given database credentials.\n   */\n\n\n  SqlServerDriver.prototype.createPool = function (options, credentials) {\n    var _this = this;\n\n    credentials = Object.assign({}, credentials, DriverUtils.buildDriverOptions(credentials)); // todo: do it better way\n    // todo: credentials.domain is deprecation. remove it in future\n\n    var authentication = !credentials.domain ? credentials.authentication : {\n      type: \"ntlm\",\n      options: {\n        domain: credentials.domain,\n        userName: credentials.username,\n        password: credentials.password\n      }\n    }; // build connection options for the driver\n\n    var connectionOptions = Object.assign({}, {\n      connectionTimeout: this.options.connectionTimeout,\n      requestTimeout: this.options.requestTimeout,\n      stream: this.options.stream,\n      pool: this.options.pool,\n      options: this.options.options\n    }, {\n      server: credentials.host,\n      database: credentials.database,\n      port: credentials.port,\n      user: credentials.username,\n      password: credentials.password,\n      authentication: authentication\n    }, options.extra || {}); // set default useUTC option if it hasn't been set\n\n    if (!connectionOptions.options) connectionOptions.options = {\n      useUTC: false\n    };else if (!connectionOptions.options.useUTC) connectionOptions.options.useUTC = false; // pooling is enabled either when its set explicitly to true,\n    // either when its not defined at all (e.g. enabled by default)\n\n    return new Promise(function (ok, fail) {\n      var pool = new _this.mssql.ConnectionPool(connectionOptions);\n      var logger = _this.connection.logger;\n\n      var poolErrorHandler = options.pool && options.pool.errorHandler || function (error) {\n        return logger.log(\"warn\", \"MSSQL pool raised an error. \" + error);\n      };\n      /*\n        Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and\n        cause the hosting app to crash.\n       */\n\n\n      pool.on(\"error\", poolErrorHandler);\n      var connection = pool.connect(function (err) {\n        if (err) return fail(err);\n        ok(connection);\n      });\n    });\n  };\n\n  return SqlServerDriver;\n}();\n\nexport { SqlServerDriver };","map":{"version":3,"sources":["../browser/src/driver/sqlserver/SqlServerDriver.ts"],"names":[],"mappings":"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","sourcesContent":["import {Driver} from \"../Driver\";\nimport {ConnectionIsNotSetError} from \"../../error/ConnectionIsNotSetError\";\nimport {DriverPackageNotInstalledError} from \"../../error/DriverPackageNotInstalledError\";\nimport {DriverUtils} from \"../DriverUtils\";\nimport {SqlServerQueryRunner} from \"./SqlServerQueryRunner\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\nimport {DateUtils} from \"../../util/DateUtils\";\nimport {PlatformTools} from \"../../platform/PlatformTools\";\nimport {Connection} from \"../../connection/Connection\";\nimport {RdbmsSchemaBuilder} from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport {SqlServerConnectionOptions} from \"./SqlServerConnectionOptions\";\nimport {MappedColumnTypes} from \"../types/MappedColumnTypes\";\nimport {ColumnType} from \"../types/ColumnTypes\";\nimport {DataTypeDefaults} from \"../types/DataTypeDefaults\";\nimport {MssqlParameter} from \"./MssqlParameter\";\nimport {TableColumn} from \"../../schema-builder/table/TableColumn\";\nimport {SqlServerConnectionCredentialsOptions} from \"./SqlServerConnectionCredentialsOptions\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {ApplyValueTransformers} from \"../../util/ApplyValueTransformers\";\nimport {ReplicationMode} from \"../types/ReplicationMode\";\n\n/**\n * Organizes communication with SQL Server DBMS.\n */\nexport class SqlServerDriver implements Driver {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: Connection;\n\n    /**\n     * SQL Server library.\n     */\n    mssql: any;\n\n    /**\n     * Pool for master database.\n     */\n    master: any;\n\n    /**\n     * Pool for slave databases.\n     * Used in replication.\n     */\n    slaves: any[] = [];\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: SqlServerConnectionOptions;\n\n    /**\n     * Master database used to perform all write queries.\n     */\n    database?: string;\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false;\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true;\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"int\",\n        \"bigint\",\n        \"bit\",\n        \"decimal\",\n        \"money\",\n        \"numeric\",\n        \"smallint\",\n        \"smallmoney\",\n        \"tinyint\",\n        \"float\",\n        \"real\",\n        \"date\",\n        \"datetime2\",\n        \"datetime\",\n        \"datetimeoffset\",\n        \"smalldatetime\",\n        \"time\",\n        \"char\",\n        \"varchar\",\n        \"text\",\n        \"nchar\",\n        \"nvarchar\",\n        \"ntext\",\n        \"binary\",\n        \"image\",\n        \"varbinary\",\n        \"hierarchyid\",\n        \"sql_variant\",\n        \"timestamp\",\n        \"uniqueidentifier\",\n        \"xml\",\n        \"geometry\",\n        \"geography\",\n        \"rowversion\"\n    ];\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = [\n        \"geometry\",\n        \"geography\"\n    ];\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"char\",\n        \"varchar\",\n        \"nchar\",\n        \"nvarchar\",\n        \"binary\",\n        \"varbinary\"\n    ];\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"numeric\",\n        \"time\",\n        \"datetime2\",\n        \"datetimeoffset\"\n    ];\n\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"numeric\"\n    ];\n\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime2\",\n        createDateDefault: \"getdate()\",\n        updateDate: \"datetime2\",\n        updateDateDefault: \"getdate()\",\n        deleteDate: \"datetime2\",\n        deleteDateNullable: true,\n        version: \"int\",\n        treeLevel: \"int\",\n        migrationId: \"int\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"nvarchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"nvarchar(MAX)\" as any,\n        cacheResult: \"nvarchar(MAX)\" as any,\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"nvarchar(MAX)\" as any,\n    };\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults = {\n        \"char\": { length: 1 },\n        \"nchar\": { length: 1 },\n        \"varchar\": { length: 255 },\n        \"nvarchar\": { length: 255 },\n        \"binary\": { length: 1 },\n        \"varbinary\": { length: 1 },\n        \"decimal\": { precision: 18, scale: 0 },\n        \"numeric\": { precision: 18, scale: 0 },\n        \"time\": { precision: 7 },\n        \"datetime2\": { precision: 7 },\n        \"datetimeoffset\": { precision: 7 }\n    };\n\n    /**\n     * Max length allowed by MSSQL Server for aliases (identifiers).\n     * @see https://docs.microsoft.com/en-us/sql/sql-server/maximum-capacity-specifications-for-sql-server\n     */\n    maxAliasLength = 128;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: Connection) {\n        this.connection = connection;\n        this.options = connection.options as SqlServerConnectionOptions;\n        this.isReplicated = this.options.replication ? true : false;\n\n        // load mssql package\n        this.loadDependencies();\n\n        // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way\n        // validate options to make sure everything is set\n        // if (!this.options.host)\n            // throw new DriverOptionNotSetError(\"host\");\n        // if (!this.options.username)\n        //     throw new DriverOptionNotSetError(\"username\");\n        // if (!this.options.database)\n        //     throw new DriverOptionNotSetError(\"database\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     * Based on pooling options, it can either create connection immediately,\n     * either create a pool and create connection when needed.\n     */\n    async connect(): Promise<void> {\n\n        if (this.options.replication) {\n            this.slaves = await Promise.all(this.options.replication.slaves.map(slave => {\n                return this.createPool(this.options, slave);\n            }));\n            this.master = await this.createPool(this.options, this.options.replication.master);\n            this.database = this.options.replication.master.database;\n\n        } else {\n            this.master = await this.createPool(this.options, this.options);\n            this.database = this.options.database;\n        }\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect(): Promise<void> {\n        if (!this.master)\n            return Promise.reject(new ConnectionIsNotSetError(\"mssql\"));\n\n        await this.closePool(this.master);\n        await Promise.all(this.slaves.map(slave => this.closePool(slave)));\n        this.master = undefined;\n        this.slaves = [];\n    }\n\n\n    /**\n     * Closes connection pool.\n     */\n    protected async closePool(pool: any): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            pool.close((err: any) => err ? fail(err) : ok());\n        });\n    }\n\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection);\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode) {\n        return new SqlServerQueryRunner(this, mode);\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(sql: string, parameters: ObjectLiteral, nativeParameters: ObjectLiteral): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(key => nativeParameters[key]);\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters];\n\n        const keys = Object.keys(parameters).map(parameter => \"(:(\\\\.\\\\.\\\\.)?\" + parameter + \"\\\\b)\").join(\"|\");\n        sql = sql.replace(new RegExp(keys, \"g\"), (key: string) => {\n            let value: any;\n            let isArray = false;\n            if (key.substr(0, 4) === \":...\") {\n                isArray = true;\n                value = parameters[key.substr(4)];\n            } else {\n                value = parameters[key.substr(1)];\n            }\n\n            if (isArray) {\n                return value.map((v: any) => {\n                    escapedParameters.push(v);\n                    return \"@\" + (escapedParameters.length - 1);\n                }).join(\", \");\n\n            } else if (value instanceof Function) {\n                return value();\n\n            } else {\n                escapedParameters.push(value);\n                return \"@\" + (escapedParameters.length - 1);\n            }\n        }); // todo: make replace only in value statements, otherwise problems\n        return [sql, escapedParameters];\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return `\"${columnName}\"`;\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. \"myDB\".\"mySchema\".\"myTable\"\n     */\n    buildTableName(tableName: string, schema?: string, database?: string): string {\n        let fullName = tableName;\n        if (schema)\n            fullName = schema + \".\" + tableName;\n        if (database) {\n            if (!schema) {\n                fullName = database + \"..\" + tableName;\n            } else {\n                fullName = database + \".\" + fullName;\n            }\n        }\n\n        return fullName;\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n\n        if (value === null || value === undefined)\n            return value;\n\n        if (columnMetadata.type === Boolean) {\n            return value === true ? 1 : 0;\n\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDate(value);\n\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedTimeToDate(value);\n\n        } else if (columnMetadata.type === \"datetime\"\n            || columnMetadata.type === \"smalldatetime\"\n            || columnMetadata.type === Date) {\n            return DateUtils.mixedDateToDate(value, false, false);\n\n        } else if (columnMetadata.type === \"datetime2\"\n            || columnMetadata.type === \"datetimeoffset\") {\n            return DateUtils.mixedDateToDate(value, false, true);\n\n        } else if (columnMetadata.type === \"simple-array\") {\n            return DateUtils.simpleArrayToString(value);\n\n        } else if (columnMetadata.type === \"simple-json\") {\n            return DateUtils.simpleJsonToString(value);\n\n        } else if (columnMetadata.type === \"simple-enum\") {\n            return DateUtils.simpleEnumToString(value);\n\n        }\n\n        return value;\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n        if (columnMetadata.type === Boolean) {\n            value = value ? true : false;\n\n        } else if (columnMetadata.type === \"datetime\"\n            || columnMetadata.type === Date\n            || columnMetadata.type === \"datetime2\"\n            || columnMetadata.type === \"smalldatetime\"\n            || columnMetadata.type === \"datetimeoffset\") {\n            value = DateUtils.normalizeHydratedDate(value);\n\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value);\n\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value);\n\n        } else if (columnMetadata.type === \"simple-array\") {\n            value = DateUtils.stringToSimpleArray(value);\n\n        } else if (columnMetadata.type === \"simple-json\") {\n            value = DateUtils.stringToSimpleJson(value);\n\n        } else if (columnMetadata.type === \"simple-enum\") {\n            value = DateUtils.stringToSimpleEnum(value, columnMetadata);\n\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n\n        return value;\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: { type?: ColumnType, length?: number | string, precision?: number|null, scale?: number }): string {\n        if (column.type === Number || column.type === \"integer\") {\n            return \"int\";\n\n        } else if (column.type === String) {\n            return \"nvarchar\";\n\n        } else if (column.type === Date) {\n            return \"datetime\";\n\n        } else if (column.type === Boolean) {\n            return \"bit\";\n\n        } else if ((column.type as any) === Buffer) {\n            return \"binary\";\n\n        } else if (column.type === \"uuid\") {\n            return \"uniqueidentifier\";\n\n        } else if (column.type === \"simple-array\" || column.type === \"simple-json\") {\n            return \"ntext\";\n\n        } else if (column.type === \"simple-enum\") {\n            return \"nvarchar\";\n\n        } else if (column.type === \"dec\") {\n            return \"decimal\";\n\n        } else if (column.type === \"double precision\") {\n            return \"float\";\n\n        } else if (column.type === \"rowversion\") {\n            return \"timestamp\";  // the rowversion type's name in SQL server metadata is timestamp\n\n        } else {\n            return column.type as string || \"\";\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default;\n\n        if (typeof defaultValue === \"number\") {\n            return \"\" + defaultValue;\n\n        } else if (typeof defaultValue === \"boolean\") {\n            return defaultValue === true ? \"1\" : \"0\";\n\n        } else if (typeof defaultValue === \"function\") {\n            const value = defaultValue();\n            if (value.toUpperCase() === \"CURRENT_TIMESTAMP\") {\n                return \"getdate()\"\n            }\n            return value\n\n        } else if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`;\n\n        } else {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.uniques.some(uq => uq.columns.length === 1 && uq.columns[0] === column);\n    }\n\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column: ColumnMetadata|TableColumn): string {\n        if (column.length)\n            return column.length.toString();\n\n        if (column.type === \"varchar\" || column.type === \"nvarchar\" || column.type === String)\n            return \"255\";\n\n        return \"\";\n    }\n\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type;\n\n        // used 'getColumnLength()' method, because SqlServer sets `varchar` and `nvarchar` length to 1 by default.\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`;\n\n        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n            type += `(${column.precision},${column.scale})`;\n\n        } else if (column.precision !== null && column.precision !== undefined) {\n            type +=  `(${column.precision})`;\n        }\n\n        if (column.isArray)\n            type += \" array\";\n\n        return type;\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return Promise.resolve(this.master);\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        if (!this.slaves.length)\n            return this.obtainMasterConnection();\n\n        const random = Math.floor(Math.random() * this.slaves.length);\n        return Promise.resolve(this.slaves[random]);\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(metadata: EntityMetadata, insertResult: ObjectLiteral) {\n        if (!insertResult)\n            return undefined;\n\n        return Object.keys(insertResult).reduce((map, key) => {\n            const column = metadata.findColumnWithDatabaseName(key);\n            if (column) {\n                OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column)));\n            }\n            return map;\n        }, {} as ObjectLiteral);\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(tableColumns: TableColumn[], columnMetadatas: ColumnMetadata[]): ColumnMetadata[] {\n        return columnMetadatas.filter(columnMetadata => {\n            const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n            if (!tableColumn)\n                return false; // we don't need new columns, we only need exist and changed\n\n            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName\n                || tableColumn.type !== this.normalizeType(columnMetadata)\n                || tableColumn.length !== columnMetadata.length\n                || tableColumn.precision !== columnMetadata.precision\n                || tableColumn.scale !== columnMetadata.scale\n                // || tableColumn.comment !== columnMetadata.comment || // todo\n                || tableColumn.isGenerated !== columnMetadata.isGenerated\n                || (!tableColumn.isGenerated && this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata)) !== this.lowerDefaultValueIfNecessary(tableColumn.default)) // we included check for generated here, because generated columns already can have default values\n                || tableColumn.isPrimary !== columnMetadata.isPrimary\n                || tableColumn.isNullable !== columnMetadata.isNullable\n                || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);\n\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n            //     console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n            //     console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n            //     console.log(\"length:\", tableColumn.length, columnMetadata.length);\n            //     console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n            //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n            //     console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n            //     console.log(\"isGenerated 2:\", !tableColumn.isGenerated && this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata)) !== this.lowerDefaultValueIfNecessary(tableColumn.default));\n            //     console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n            //     console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n            //     console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n            //     console.log(\"==========================================\");\n            // }\n\n            return isColumnChanged\n        });\n    }\n    private lowerDefaultValueIfNecessary(value: string | undefined) {\n        // SqlServer saves function calls in default value as lowercase https://github.com/typeorm/typeorm/issues/2733\n        if (!value) {\n            return value;\n        }\n        return value.split(`'`).map((v, i) => {\n            return i % 2 === 1 ? v : v.toLowerCase();\n        }).join(`'`);\n    }\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        if (this.options.options && this.options.options.disableOutputReturning) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return true;\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false;\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        return \"@\" + index;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sql server's parameters needs to be wrapped into special object with type information about this value.\n     * This method wraps given value into MssqlParameter based on its column definition.\n     */\n    parametrizeValue(column: ColumnMetadata, value: any) {\n\n        // if its already MssqlParameter then simply return it\n        if (value instanceof MssqlParameter)\n            return value;\n\n        const normalizedType = this.normalizeType({ type: column.type });\n        if (column.length) {\n            return new MssqlParameter(value, normalizedType as any, column.length as any);\n\n        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n            return new MssqlParameter(value, normalizedType as any, column.precision, column.scale);\n\n        } else if (column.precision !== null && column.precision !== undefined) {\n            return new MssqlParameter(value, normalizedType as any, column.precision);\n\n        } else if (column.scale !== null && column.scale !== undefined) {\n            return new MssqlParameter(value, normalizedType as any, column.scale);\n        }\n\n        return new MssqlParameter(value, normalizedType as any);\n    }\n\n    /**\n     * Sql server's parameters needs to be wrapped into special object with type information about this value.\n     * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.\n     */\n    parametrizeMap(tablePath: string, map: ObjectLiteral): ObjectLiteral {\n\n        // find metadata for the given table\n        if (!this.connection.hasMetadata(tablePath)) // if no metadata found then we can't proceed because we don't have columns and their types\n            return map;\n        const metadata = this.connection.getMetadata(tablePath);\n\n        return Object.keys(map).reduce((newMap, key) => {\n            const value = map[key];\n\n            // find column metadata\n            const column = metadata.findColumnWithDatabaseName(key);\n            if (!column) // if we didn't find a column then we can't proceed because we don't have a column type\n                return value;\n\n            newMap[key] = this.parametrizeValue(column, value);\n            return newMap;\n        }, {} as ObjectLiteral);\n    }\n\n    buildTableVariableDeclaration(identifier: string, columns: ColumnMetadata[]): string {\n        const outputColumns = columns.map(column => {\n            return `${this.escape(column.databaseName)} ${this.createFullType(new TableColumn({\n                name: column.databaseName,\n                type: this.normalizeType(column),\n                length: column.length,\n                isNullable: column.isNullable,\n                isArray: column.isArray,\n            }))}`;\n        });\n\n        return `DECLARE ${identifier} TABLE (${outputColumns.join(\", \")})`;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * If driver dependency is not given explicitly, then try to load it via \"require\".\n     */\n    protected loadDependencies(): void {\n        try {\n            this.mssql = PlatformTools.load(\"mssql\");\n\n        } catch (e) { // todo: better error for browser env\n            throw new DriverPackageNotInstalledError(\"SQL Server\", \"mssql\");\n        }\n    }\n\n    /**\n     * Creates a new connection pool for a given database credentials.\n     */\n    protected createPool(options: SqlServerConnectionOptions, credentials: SqlServerConnectionCredentialsOptions): Promise<any> {\n\n        credentials = Object.assign({}, credentials, DriverUtils.buildDriverOptions(credentials)); // todo: do it better way\n\n        // todo: credentials.domain is deprecation. remove it in future\n        const authentication = !credentials.domain ? credentials.authentication : {\n            type: \"ntlm\",\n            options: {\n                domain: credentials.domain,\n                userName: credentials.username,\n                password: credentials.password\n            }\n        };\n        // build connection options for the driver\n        const connectionOptions = Object.assign({}, {\n            connectionTimeout: this.options.connectionTimeout,\n            requestTimeout: this.options.requestTimeout,\n            stream: this.options.stream,\n            pool: this.options.pool,\n            options: this.options.options,\n        }, {\n            server: credentials.host,\n            database: credentials.database,\n            port: credentials.port,\n            user: credentials.username,\n            password: credentials.password,\n            authentication: authentication,\n        }, options.extra || {});\n\n        // set default useUTC option if it hasn't been set\n        if (!connectionOptions.options) connectionOptions.options = { useUTC: false };\n        else if (!connectionOptions.options.useUTC) connectionOptions.options.useUTC = false;\n\n        // pooling is enabled either when its set explicitly to true,\n        // either when its not defined at all (e.g. enabled by default)\n        return new Promise<void>((ok, fail) => {\n            const pool = new this.mssql.ConnectionPool(connectionOptions);\n\n            const { logger } = this.connection;\n\n            const poolErrorHandler = (options.pool && options.pool.errorHandler) || ((error: any) => logger.log(\"warn\", `MSSQL pool raised an error. ${error}`));\n            /*\n              Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and\n              cause the hosting app to crash.\n             */\n            pool.on(\"error\", poolErrorHandler);\n\n            const connection = pool.connect((err: any) => {\n                if (err) return fail(err);\n                ok(connection);\n            });\n        });\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}