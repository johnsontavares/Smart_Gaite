{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { CockroachDriver } from \"../driver/cockroachdb/CockroachDriver\";\nimport { SapDriver } from \"../driver/sap/SapDriver\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\nimport { EmbeddedMetadata } from \"../metadata/EmbeddedMetadata\";\nimport { RelationIdMetadata } from \"../metadata/RelationIdMetadata\";\nimport { RelationCountMetadata } from \"../metadata/RelationCountMetadata\";\nimport { EventListenerTypes } from \"../metadata/types/EventListenerTypes\";\nimport { MetadataUtils } from \"./MetadataUtils\";\nimport { JunctionEntityMetadataBuilder } from \"./JunctionEntityMetadataBuilder\";\nimport { ClosureJunctionEntityMetadataBuilder } from \"./ClosureJunctionEntityMetadataBuilder\";\nimport { RelationJoinColumnBuilder } from \"./RelationJoinColumnBuilder\";\nimport { EntityListenerMetadata } from \"../metadata/EntityListenerMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\";\nimport { CheckMetadata } from \"../metadata/CheckMetadata\";\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\";\nimport { PostgresDriver } from \"../driver/postgres/PostgresDriver\";\nimport { ExclusionMetadata } from \"../metadata/ExclusionMetadata\";\nimport { AuroraDataApiDriver } from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\n\nvar EntityMetadataBuilder =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function EntityMetadataBuilder(connection, metadataArgsStorage) {\n    this.connection = connection;\n    this.metadataArgsStorage = metadataArgsStorage;\n    this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\n    this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);\n    this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds a complete entity metadatas for the given entity classes.\n   */\n\n\n  EntityMetadataBuilder.prototype.build = function (entityClasses) {\n    var _this = this; // if entity classes to filter entities by are given then do filtering, otherwise use all\n\n\n    var allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables; // filter out table metadata args for those we really create entity metadatas and tables in the db\n\n    var realTables = allTables.filter(function (table) {\n      return table.type === \"regular\" || table.type === \"closure\" || table.type === \"entity-child\" || table.type === \"view\";\n    }); // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n\n    var entityMetadatas = realTables.map(function (tableArgs) {\n      return _this.createEntityMetadata(tableArgs);\n    }); // compute parent entity metadatas for table inheritance\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      return _this.computeParentEntityMetadata(entityMetadatas, entityMetadata);\n    }); // after all metadatas created we set child entity metadatas for table inheritance\n\n    entityMetadatas.forEach(function (metadata) {\n      metadata.childEntityMetadatas = entityMetadatas.filter(function (childMetadata) {\n        return metadata.target instanceof Function && childMetadata.target instanceof Function && MetadataUtils.isInherited(childMetadata.target, metadata.target);\n      });\n    }); // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)\n\n    entityMetadatas.filter(function (entityMetadata) {\n      return entityMetadata.tableType !== \"entity-child\";\n    }).forEach(function (entityMetadata) {\n      return entityMetadata.build();\n    }); // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)\n\n    entityMetadatas.filter(function (entityMetadata) {\n      return entityMetadata.tableType === \"entity-child\";\n    }).forEach(function (entityMetadata) {\n      return entityMetadata.build();\n    }); // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas\n\n    entityMetadatas.filter(function (entityMetadata) {\n      return entityMetadata.tableType !== \"entity-child\";\n    }).forEach(function (entityMetadata) {\n      return _this.computeEntityMetadataStep1(entityMetadatas, entityMetadata);\n    }); // then do it for single table inheritance children (since they are depend on their parents to be built)\n\n    entityMetadatas.filter(function (entityMetadata) {\n      return entityMetadata.tableType === \"entity-child\";\n    }).forEach(function (entityMetadata) {\n      return _this.computeEntityMetadataStep1(entityMetadatas, entityMetadata);\n    }); // calculate entity metadata computed properties and all its sub-metadatas\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      return _this.computeEntityMetadataStep2(entityMetadata);\n    }); // calculate entity metadata's inverse properties\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      return _this.computeInverseProperties(entityMetadata, entityMetadatas);\n    }); // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n\n    entityMetadatas.filter(function (entityMetadata) {\n      return entityMetadata.tableType !== \"entity-child\";\n    }).forEach(function (entityMetadata) {\n      // create entity's relations join columns (for many-to-one and one-to-one owner)\n      entityMetadata.relations.filter(function (relation) {\n        return relation.isOneToOne || relation.isManyToOne;\n      }).forEach(function (relation) {\n        var joinColumns = _this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\n\n        var _a = _this.relationJoinColumnBuilder.build(joinColumns, relation),\n            foreignKey = _a.foreignKey,\n            columns = _a.columns,\n            uniqueConstraint = _a.uniqueConstraint; // create a foreign key based on its metadata args\n\n\n        if (foreignKey) {\n          relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\n\n          entityMetadata.foreignKeys.push(foreignKey);\n        }\n\n        if (columns) {\n          relation.registerJoinColumns(columns);\n        }\n\n        if (uniqueConstraint) {\n          if (_this.connection.driver instanceof MysqlDriver || _this.connection.driver instanceof AuroraDataApiDriver || _this.connection.driver instanceof SqlServerDriver || _this.connection.driver instanceof SapDriver) {\n            var index = new IndexMetadata({\n              entityMetadata: uniqueConstraint.entityMetadata,\n              columns: uniqueConstraint.columns,\n              args: {\n                target: uniqueConstraint.target,\n                name: uniqueConstraint.name,\n                unique: true,\n                synchronize: true\n              }\n            });\n\n            if (_this.connection.driver instanceof SqlServerDriver) {\n              index.where = index.columns.map(function (column) {\n                return _this.connection.driver.escape(column.databaseName) + \" IS NOT NULL\";\n              }).join(\" AND \");\n            }\n\n            if (relation.embeddedMetadata) {\n              relation.embeddedMetadata.indices.push(index);\n            } else {\n              relation.entityMetadata.ownIndices.push(index);\n            }\n\n            _this.computeEntityMetadataStep2(entityMetadata);\n          } else {\n            if (relation.embeddedMetadata) {\n              relation.embeddedMetadata.uniques.push(uniqueConstraint);\n            } else {\n              relation.entityMetadata.ownUniques.push(uniqueConstraint);\n            }\n\n            _this.computeEntityMetadataStep2(entityMetadata);\n          }\n        }\n\n        if (foreignKey && _this.connection.driver instanceof CockroachDriver) {\n          var index = new IndexMetadata({\n            entityMetadata: relation.entityMetadata,\n            columns: foreignKey.columns,\n            args: {\n              target: relation.entityMetadata.target,\n              synchronize: true\n            }\n          });\n\n          if (relation.embeddedMetadata) {\n            relation.embeddedMetadata.indices.push(index);\n          } else {\n            relation.entityMetadata.ownIndices.push(index);\n          }\n\n          _this.computeEntityMetadataStep2(entityMetadata);\n        }\n      }); // create junction entity metadatas for entity many-to-many relations\n\n      entityMetadata.relations.filter(function (relation) {\n        return relation.isManyToMany;\n      }).forEach(function (relation) {\n        var joinTable = _this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);\n\n        if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\n        // here we create a junction entity metadata for a new junction table of many-to-many relation\n\n        var junctionEntityMetadata = _this.junctionEntityMetadataBuilder.build(relation, joinTable);\n\n        relation.registerForeignKeys.apply(relation, __spreadArray([], __read(junctionEntityMetadata.foreignKeys)));\n        relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);\n        relation.registerJunctionEntityMetadata(junctionEntityMetadata); // compute new entity metadata properties and push it to entity metadatas pool\n\n        _this.computeEntityMetadataStep2(junctionEntityMetadata);\n\n        _this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\n\n        entityMetadatas.push(junctionEntityMetadata);\n      });\n    }); // update entity metadata depend properties\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(function (relation) {\n        return relation.isWithJoinColumn;\n      });\n      entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(function (relation) {\n        return !relation.isNullable || relation.isPrimary;\n      });\n    }); // generate closure junction tables for all closure tables\n\n    entityMetadatas.filter(function (metadata) {\n      return metadata.treeType === \"closure-table\";\n    }).forEach(function (entityMetadata) {\n      var closureJunctionEntityMetadata = _this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\n\n      entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;\n\n      _this.computeEntityMetadataStep2(closureJunctionEntityMetadata);\n\n      _this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\n\n      entityMetadatas.push(closureJunctionEntityMetadata);\n    }); // generate keys for tables with single-table inheritance\n\n    entityMetadatas.filter(function (metadata) {\n      return metadata.inheritancePattern === \"STI\" && metadata.discriminatorColumn;\n    }).forEach(function (entityMetadata) {\n      return _this.createKeysForTableInheritance(entityMetadata);\n    }); // build all indices (need to do it after relations and their join columns are built)\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.indices.forEach(function (index) {\n        return index.build(_this.connection.namingStrategy);\n      });\n    }); // build all unique constraints (need to do it after relations and their join columns are built)\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.uniques.forEach(function (unique) {\n        return unique.build(_this.connection.namingStrategy);\n      });\n    }); // build all check constraints\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.checks.forEach(function (check) {\n        return check.build(_this.connection.namingStrategy);\n      });\n    }); // build all exclusion constraints\n\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.exclusions.forEach(function (exclusion) {\n        return exclusion.build(_this.connection.namingStrategy);\n      });\n    }); // add lazy initializer for entity relations\n\n    entityMetadatas.filter(function (metadata) {\n      return metadata.target instanceof Function;\n    }).forEach(function (entityMetadata) {\n      entityMetadata.relations.filter(function (relation) {\n        return relation.isLazy;\n      }).forEach(function (relation) {\n        _this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);\n      });\n    });\n    entityMetadatas.forEach(function (entityMetadata) {\n      entityMetadata.columns.forEach(function (column) {\n        // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n        var generated = _this.metadataArgsStorage.findGenerated(column.target, column.propertyName);\n\n        if (generated) {\n          column.isGenerated = true;\n          column.generationStrategy = generated.strategy;\n\n          if (generated.strategy === \"uuid\") {\n            column.type = \"uuid\";\n          } else if (generated.strategy === \"rowid\") {\n            column.type = \"int\";\n          } else {\n            column.type = column.type || Number;\n          }\n\n          column.build(_this.connection);\n\n          _this.computeEntityMetadataStep2(entityMetadata);\n        }\n      });\n    });\n    return entityMetadatas;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates entity metadata from the given table args.\n   * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n   */\n\n\n  EntityMetadataBuilder.prototype.createEntityMetadata = function (tableArgs) {\n    // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n    // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n    // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n    var inheritanceTree = tableArgs.target instanceof Function ? MetadataUtils.getInheritanceTree(tableArgs.target) : [tableArgs.target]; // todo: implement later here inheritance for string-targets\n\n    var tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\n    var tableTree = this.metadataArgsStorage.findTree(tableArgs.target); // if single table inheritance used, we need to copy all children columns in to parent table\n\n    var singleTableChildrenTargets;\n\n    if (tableInheritance && tableInheritance.pattern === \"STI\" || tableArgs.type === \"entity-child\") {\n      singleTableChildrenTargets = this.metadataArgsStorage.filterSingleTableChildren(tableArgs.target).map(function (args) {\n        return args.target;\n      }).filter(function (target) {\n        return target instanceof Function;\n      });\n      inheritanceTree.push.apply(inheritanceTree, __spreadArray([], __read(singleTableChildrenTargets)));\n    }\n\n    return new EntityMetadata({\n      connection: this.connection,\n      args: tableArgs,\n      inheritanceTree: inheritanceTree,\n      tableTree: tableTree,\n      inheritancePattern: tableInheritance ? tableInheritance.pattern : undefined\n    });\n  };\n\n  EntityMetadataBuilder.prototype.computeParentEntityMetadata = function (allEntityMetadatas, entityMetadata) {\n    // after all metadatas created we set parent entity metadata for table inheritance\n    if (entityMetadata.tableType === \"entity-child\") {\n      entityMetadata.parentEntityMetadata = allEntityMetadatas.find(function (allEntityMetadata) {\n        return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 && allEntityMetadata.inheritancePattern === \"STI\";\n      });\n    }\n  };\n\n  EntityMetadataBuilder.prototype.computeEntityMetadataStep1 = function (allEntityMetadatas, entityMetadata) {\n    var _a, _b, _c;\n\n    var _this = this;\n\n    var entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);\n    var discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);\n\n    if (typeof discriminatorValue !== \"undefined\") {\n      entityMetadata.discriminatorValue = discriminatorValue.value;\n    } else {\n      entityMetadata.discriminatorValue = entityMetadata.target.name;\n    } // if single table inheritance is used, we need to mark all embedded columns as nullable\n\n\n    entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map(function (embedded) {\n      if (entityMetadata.inheritancePattern === \"STI\") {\n        embedded.columns = embedded.columns.map(function (column) {\n          column.isNullable = true;\n          return column;\n        });\n      }\n\n      return embedded;\n    });\n    entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(entityMetadata.inheritanceTree).map(function (args) {\n      // for single table children we reuse columns created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.ownColumns.find(function (column) {\n        return column.propertyName === args.propertyName;\n      });\n      var column = new ColumnMetadata({\n        connection: _this.connection,\n        entityMetadata: entityMetadata,\n        args: args\n      }); // if single table inheritance used, we need to mark all inherit table columns as nullable\n\n      var columnInSingleTableInheritedChild = allEntityMetadatas.find(function (otherEntityMetadata) {\n        return otherEntityMetadata.tableType === \"entity-child\" && otherEntityMetadata.target === args.target;\n      });\n      if (columnInSingleTableInheritedChild) column.isNullable = true;\n      return column;\n    }); // for table inheritance we need to add a discriminator column\n    //\n\n    if (entityInheritance && entityInheritance.column) {\n      var discriminatorColumnName_1 = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : \"type\";\n      var discriminatorColumn = entityMetadata.ownColumns.find(function (column) {\n        return column.propertyName === discriminatorColumnName_1;\n      });\n\n      if (!discriminatorColumn) {\n        discriminatorColumn = new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata: entityMetadata,\n          args: {\n            target: entityMetadata.target,\n            mode: \"virtual\",\n            propertyName: discriminatorColumnName_1,\n            options: entityInheritance.column || {\n              name: discriminatorColumnName_1,\n              type: \"varchar\",\n              nullable: false\n            }\n          }\n        });\n        discriminatorColumn.isVirtual = true;\n        discriminatorColumn.isDiscriminator = true;\n        entityMetadata.ownColumns.push(discriminatorColumn);\n      } else {\n        discriminatorColumn.isDiscriminator = true;\n      }\n    } // add discriminator column to the child entity metadatas\n    // discriminator column will not be there automatically since we are creating it in the code above\n\n\n    if (entityMetadata.tableType === \"entity-child\") {\n      var discriminatorColumn_1 = entityMetadata.parentEntityMetadata.ownColumns.find(function (column) {\n        return column.isDiscriminator;\n      });\n\n      if (discriminatorColumn_1 && !entityMetadata.ownColumns.find(function (column) {\n        return column === discriminatorColumn_1;\n      })) {\n        entityMetadata.ownColumns.push(discriminatorColumn_1);\n      }\n    }\n\n    var namingStrategy = this.connection.namingStrategy; // check if tree is used then we need to add extra columns for specific tree types\n\n    if (entityMetadata.treeType === \"materialized-path\") {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        materializedPath: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: \"mpath\",\n          options:\n          /*tree.column || */\n          {\n            name: namingStrategy.materializedPathColumnName,\n            type: \"varchar\",\n            nullable: true,\n            default: \"\"\n          }\n        }\n      }));\n    } else if (entityMetadata.treeType === \"nested-set\") {\n      var _d = namingStrategy.nestedSetColumnNames,\n          left = _d.left,\n          right = _d.right;\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        nestedSetLeft: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: left,\n          options:\n          /*tree.column || */\n          {\n            name: left,\n            type: \"integer\",\n            nullable: false,\n            default: 1\n          }\n        }\n      }));\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        nestedSetRight: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: right,\n          options:\n          /*tree.column || */\n          {\n            name: right,\n            type: \"integer\",\n            nullable: false,\n            default: 2\n          }\n        }\n      }));\n    }\n\n    entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map(function (args) {\n      // for single table children we reuse relations created for their parents\n      if (entityMetadata.tableType === \"entity-child\") {\n        var parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find(function (relation) {\n          return relation.propertyName === args.propertyName;\n        });\n        var type = args.type instanceof Function ? args.type() : args.type;\n\n        if (parentRelation.type !== type) {\n          var clone = Object.create(parentRelation);\n          clone.type = type;\n          return clone;\n        }\n\n        return parentRelation;\n      }\n\n      return new RelationMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    });\n    entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map(function (args) {\n      // for single table children we reuse relation ids created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.relationIds.find(function (relationId) {\n        return relationId.propertyName === args.propertyName;\n      });\n      return new RelationIdMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    });\n    entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map(function (args) {\n      // for single table children we reuse relation counts created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.relationCounts.find(function (relationCount) {\n        return relationCount.propertyName === args.propertyName;\n      });\n      return new RelationCountMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    });\n    entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map(function (args) {\n      return new EntityListenerMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    });\n    entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map(function (args) {\n      return new CheckMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    }); // Only PostgreSQL supports exclusion constraints.\n\n    if (this.connection.driver instanceof PostgresDriver) {\n      entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map(function (args) {\n        return new ExclusionMetadata({\n          entityMetadata: entityMetadata,\n          args: args\n        });\n      });\n    }\n\n    if (this.connection.driver instanceof CockroachDriver) {\n      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter(function (args) {\n        return !args.unique;\n      }).map(function (args) {\n        return new IndexMetadata({\n          entityMetadata: entityMetadata,\n          args: args\n        });\n      });\n      var uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter(function (args) {\n        return args.unique;\n      }).map(function (args) {\n        return new UniqueMetadata({\n          entityMetadata: entityMetadata,\n          args: {\n            target: args.target,\n            name: args.name,\n            columns: args.columns\n          }\n        });\n      });\n\n      (_a = entityMetadata.ownUniques).push.apply(_a, __spreadArray([], __read(uniques)));\n    } else {\n      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map(function (args) {\n        return new IndexMetadata({\n          entityMetadata: entityMetadata,\n          args: args\n        });\n      });\n    } // Mysql and SAP HANA stores unique constraints as unique indices.\n\n\n    if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver || this.connection.driver instanceof SapDriver) {\n      var indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(function (args) {\n        return new IndexMetadata({\n          entityMetadata: entityMetadata,\n          args: {\n            target: args.target,\n            name: args.name,\n            columns: args.columns,\n            unique: true,\n            synchronize: true\n          }\n        });\n      });\n\n      (_b = entityMetadata.ownIndices).push.apply(_b, __spreadArray([], __read(indices)));\n    } else {\n      var uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(function (args) {\n        return new UniqueMetadata({\n          entityMetadata: entityMetadata,\n          args: args\n        });\n      });\n\n      (_c = entityMetadata.ownUniques).push.apply(_c, __spreadArray([], __read(uniques)));\n    }\n  };\n  /**\n   * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n   * and does the same for all its sub-embeddeds (goes recursively).\n   */\n\n\n  EntityMetadataBuilder.prototype.createEmbeddedsRecursively = function (entityMetadata, embeddedArgs) {\n    var _this = this;\n\n    return embeddedArgs.map(function (embeddedArgs) {\n      var embeddedMetadata = new EmbeddedMetadata({\n        entityMetadata: entityMetadata,\n        args: embeddedArgs\n      });\n      var targets = MetadataUtils.getInheritanceTree(embeddedMetadata.type);\n      embeddedMetadata.columns = _this.metadataArgsStorage.filterColumns(targets).map(function (args) {\n        return new ColumnMetadata({\n          connection: _this.connection,\n          entityMetadata: entityMetadata,\n          embeddedMetadata: embeddedMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.relations = _this.metadataArgsStorage.filterRelations(targets).map(function (args) {\n        return new RelationMetadata({\n          entityMetadata: entityMetadata,\n          embeddedMetadata: embeddedMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.listeners = _this.metadataArgsStorage.filterListeners(targets).map(function (args) {\n        return new EntityListenerMetadata({\n          entityMetadata: entityMetadata,\n          embeddedMetadata: embeddedMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.indices = _this.metadataArgsStorage.filterIndices(targets).map(function (args) {\n        return new IndexMetadata({\n          entityMetadata: entityMetadata,\n          embeddedMetadata: embeddedMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.uniques = _this.metadataArgsStorage.filterUniques(targets).map(function (args) {\n        return new UniqueMetadata({\n          entityMetadata: entityMetadata,\n          embeddedMetadata: embeddedMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.relationIds = _this.metadataArgsStorage.filterRelationIds(targets).map(function (args) {\n        return new RelationIdMetadata({\n          entityMetadata: entityMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.relationCounts = _this.metadataArgsStorage.filterRelationCounts(targets).map(function (args) {\n        return new RelationCountMetadata({\n          entityMetadata: entityMetadata,\n          args: args\n        });\n      });\n      embeddedMetadata.embeddeds = _this.createEmbeddedsRecursively(entityMetadata, _this.metadataArgsStorage.filterEmbeddeds(targets));\n      embeddedMetadata.embeddeds.forEach(function (subEmbedded) {\n        return subEmbedded.parentEmbeddedMetadata = embeddedMetadata;\n      });\n      entityMetadata.allEmbeddeds.push(embeddedMetadata);\n      return embeddedMetadata;\n    });\n  };\n  /**\n   * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n   */\n\n\n  EntityMetadataBuilder.prototype.computeEntityMetadataStep2 = function (entityMetadata) {\n    var _this = this;\n\n    entityMetadata.embeddeds.forEach(function (embedded) {\n      return embedded.build(_this.connection);\n    });\n    entityMetadata.embeddeds.forEach(function (embedded) {\n      embedded.columnsFromTree.forEach(function (column) {\n        return column.build(_this.connection);\n      });\n      embedded.relationsFromTree.forEach(function (relation) {\n        return relation.build();\n      });\n    });\n    entityMetadata.ownColumns.forEach(function (column) {\n      return column.build(_this.connection);\n    });\n    entityMetadata.ownRelations.forEach(function (relation) {\n      return relation.build();\n    });\n    entityMetadata.relations = entityMetadata.embeddeds.reduce(function (relations, embedded) {\n      return relations.concat(embedded.relationsFromTree);\n    }, entityMetadata.ownRelations);\n    entityMetadata.eagerRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isEager;\n    });\n    entityMetadata.lazyRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isLazy;\n    });\n    entityMetadata.oneToOneRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isOneToOne;\n    });\n    entityMetadata.oneToManyRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isOneToMany;\n    });\n    entityMetadata.manyToOneRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isManyToOne;\n    });\n    entityMetadata.manyToManyRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isManyToMany;\n    });\n    entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isOneToOneOwner;\n    });\n    entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(function (relation) {\n      return relation.isManyToManyOwner;\n    });\n    entityMetadata.treeParentRelation = entityMetadata.relations.find(function (relation) {\n      return relation.isTreeParent;\n    });\n    entityMetadata.treeChildrenRelation = entityMetadata.relations.find(function (relation) {\n      return relation.isTreeChildren;\n    });\n    entityMetadata.columns = entityMetadata.embeddeds.reduce(function (columns, embedded) {\n      return columns.concat(embedded.columnsFromTree);\n    }, entityMetadata.ownColumns);\n    entityMetadata.listeners = entityMetadata.embeddeds.reduce(function (columns, embedded) {\n      return columns.concat(embedded.listenersFromTree);\n    }, entityMetadata.ownListeners);\n    entityMetadata.afterLoadListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.AFTER_LOAD;\n    });\n    entityMetadata.afterInsertListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.AFTER_INSERT;\n    });\n    entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.AFTER_UPDATE;\n    });\n    entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.AFTER_REMOVE;\n    });\n    entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.BEFORE_INSERT;\n    });\n    entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.BEFORE_UPDATE;\n    });\n    entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter(function (listener) {\n      return listener.type === EventListenerTypes.BEFORE_REMOVE;\n    });\n    entityMetadata.indices = entityMetadata.embeddeds.reduce(function (columns, embedded) {\n      return columns.concat(embedded.indicesFromTree);\n    }, entityMetadata.ownIndices);\n    entityMetadata.uniques = entityMetadata.embeddeds.reduce(function (columns, embedded) {\n      return columns.concat(embedded.uniquesFromTree);\n    }, entityMetadata.ownUniques);\n    entityMetadata.primaryColumns = entityMetadata.columns.filter(function (column) {\n      return column.isPrimary;\n    });\n    entityMetadata.nonVirtualColumns = entityMetadata.columns.filter(function (column) {\n      return !column.isVirtual;\n    });\n    entityMetadata.ancestorColumns = entityMetadata.columns.filter(function (column) {\n      return column.closureType === \"ancestor\";\n    });\n    entityMetadata.descendantColumns = entityMetadata.columns.filter(function (column) {\n      return column.closureType === \"descendant\";\n    });\n    entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;\n    entityMetadata.generatedColumns = entityMetadata.columns.filter(function (column) {\n      return column.isGenerated || column.isObjectId;\n    });\n    entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter(function (column) {\n      return column.isGenerated || column.generationStrategy === \"uuid\";\n    }).length > 0;\n    entityMetadata.createDateColumn = entityMetadata.columns.find(function (column) {\n      return column.isCreateDate;\n    });\n    entityMetadata.updateDateColumn = entityMetadata.columns.find(function (column) {\n      return column.isUpdateDate;\n    });\n    entityMetadata.deleteDateColumn = entityMetadata.columns.find(function (column) {\n      return column.isDeleteDate;\n    });\n    entityMetadata.versionColumn = entityMetadata.columns.find(function (column) {\n      return column.isVersion;\n    });\n    entityMetadata.discriminatorColumn = entityMetadata.columns.find(function (column) {\n      return column.isDiscriminator;\n    });\n    entityMetadata.treeLevelColumn = entityMetadata.columns.find(function (column) {\n      return column.isTreeLevel;\n    });\n    entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find(function (column) {\n      return column.isNestedSetLeft;\n    });\n    entityMetadata.nestedSetRightColumn = entityMetadata.columns.find(function (column) {\n      return column.isNestedSetRight;\n    });\n    entityMetadata.materializedPathColumn = entityMetadata.columns.find(function (column) {\n      return column.isMaterializedPath;\n    });\n    entityMetadata.objectIdColumn = entityMetadata.columns.find(function (column) {\n      return column.isObjectId;\n    });\n    entityMetadata.foreignKeys.forEach(function (foreignKey) {\n      return foreignKey.build(_this.connection.namingStrategy);\n    });\n    entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\n    entityMetadata.relationIds.forEach(function (relationId) {\n      return relationId.build();\n    });\n    entityMetadata.relationCounts.forEach(function (relationCount) {\n      return relationCount.build();\n    });\n    entityMetadata.embeddeds.forEach(function (embedded) {\n      embedded.relationIdsFromTree.forEach(function (relationId) {\n        return relationId.build();\n      });\n      embedded.relationCountsFromTree.forEach(function (relationCount) {\n        return relationCount.build();\n      });\n    });\n  };\n  /**\n   * Computes entity metadata's relations inverse side properties.\n   */\n\n\n  EntityMetadataBuilder.prototype.computeInverseProperties = function (entityMetadata, entityMetadatas) {\n    entityMetadata.relations.forEach(function (relation) {\n      // compute inverse side (related) entity metadatas for all relation metadatas\n      var inverseEntityMetadata = entityMetadatas.find(function (m) {\n        return m.target === relation.type || typeof relation.type === \"string\" && (m.targetName === relation.type || m.givenTableName === relation.type);\n      });\n      if (!inverseEntityMetadata) throw new Error(\"Entity metadata for \" + entityMetadata.name + \"#\" + relation.propertyPath + \" was not found. Check if you specified a correct entity object and if it's connected in the connection options.\");\n      relation.inverseEntityMetadata = inverseEntityMetadata;\n      relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath(); // and compute inverse relation and mark if it has such\n\n      relation.inverseRelation = inverseEntityMetadata.relations.find(function (foundRelation) {\n        return foundRelation.propertyPath === relation.inverseSidePropertyPath;\n      });\n    });\n  };\n  /**\n   * Creates indices for the table of single table inheritance.\n   */\n\n\n  EntityMetadataBuilder.prototype.createKeysForTableInheritance = function (entityMetadata) {\n    entityMetadata.indices.push(new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.discriminatorColumn],\n      args: {\n        target: entityMetadata.target,\n        unique: false\n      }\n    }));\n  };\n\n  return EntityMetadataBuilder;\n}();\n\nexport { EntityMetadataBuilder };","map":{"version":3,"sources":["../browser/src/metadata-builder/EntityMetadataBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import {CockroachDriver} from \"../driver/cockroachdb/CockroachDriver\";\nimport {SapDriver} from \"../driver/sap/SapDriver\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {IndexMetadata} from \"../metadata/IndexMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {EmbeddedMetadata} from \"../metadata/EmbeddedMetadata\";\nimport {MetadataArgsStorage} from \"../metadata-args/MetadataArgsStorage\";\nimport {EmbeddedMetadataArgs} from \"../metadata-args/EmbeddedMetadataArgs\";\nimport {RelationIdMetadata} from \"../metadata/RelationIdMetadata\";\nimport {RelationCountMetadata} from \"../metadata/RelationCountMetadata\";\nimport { EventListenerTypes } from \"../metadata/types/EventListenerTypes\";\nimport {MetadataUtils} from \"./MetadataUtils\";\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\nimport {JunctionEntityMetadataBuilder} from \"./JunctionEntityMetadataBuilder\";\nimport {ClosureJunctionEntityMetadataBuilder} from \"./ClosureJunctionEntityMetadataBuilder\";\nimport {RelationJoinColumnBuilder} from \"./RelationJoinColumnBuilder\";\nimport {Connection} from \"../connection/Connection\";\nimport {EntityListenerMetadata} from \"../metadata/EntityListenerMetadata\";\nimport {UniqueMetadata} from \"../metadata/UniqueMetadata\";\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\nimport {CheckMetadata} from \"../metadata/CheckMetadata\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {ExclusionMetadata} from \"../metadata/ExclusionMetadata\";\nimport {AuroraDataApiDriver} from \"../driver/aurora-data-api/AuroraDataApiDriver\";\n\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\nexport class EntityMetadataBuilder {\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Used to build entity metadatas of the junction entities.\n     */\n    protected junctionEntityMetadataBuilder: JunctionEntityMetadataBuilder;\n\n    /**\n     * Used to build entity metadatas of the closure junction entities.\n     */\n    protected closureJunctionEntityMetadataBuilder: ClosureJunctionEntityMetadataBuilder;\n\n    /**\n     * Used to build join columns of the relations.\n     */\n    protected relationJoinColumnBuilder: RelationJoinColumnBuilder;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: Connection,\n                private metadataArgsStorage: MetadataArgsStorage) {\n\n        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\n        this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);\n        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds a complete entity metadatas for the given entity classes.\n     */\n    build(entityClasses?: Function[]): EntityMetadata[] {\n\n        // if entity classes to filter entities by are given then do filtering, otherwise use all\n        const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;\n\n        // filter out table metadata args for those we really create entity metadatas and tables in the db\n        const realTables = allTables.filter(table => table.type === \"regular\" || table.type === \"closure\" || table.type === \"entity-child\" || table.type === \"view\");\n\n        // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n        const entityMetadatas = realTables.map(tableArgs => this.createEntityMetadata(tableArgs));\n\n        // compute parent entity metadatas for table inheritance\n        entityMetadatas.forEach(entityMetadata => this.computeParentEntityMetadata(entityMetadatas, entityMetadata));\n\n        // after all metadatas created we set child entity metadatas for table inheritance\n        entityMetadatas.forEach(metadata => {\n            metadata.childEntityMetadatas = entityMetadatas.filter(childMetadata => {\n                return metadata.target instanceof Function\n                    && childMetadata.target instanceof Function\n                    && MetadataUtils.isInherited(childMetadata.target, metadata.target);\n            });\n        });\n\n        // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)\n        entityMetadatas\n            .filter(entityMetadata => entityMetadata.tableType !== \"entity-child\")\n            .forEach(entityMetadata => entityMetadata.build());\n\n        // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)\n        entityMetadatas\n            .filter(entityMetadata => entityMetadata.tableType === \"entity-child\")\n            .forEach(entityMetadata => entityMetadata.build());\n\n        // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas\n        entityMetadatas\n            .filter(entityMetadata => entityMetadata.tableType !== \"entity-child\")\n            .forEach(entityMetadata => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));\n\n        // then do it for single table inheritance children (since they are depend on their parents to be built)\n        entityMetadatas\n            .filter(entityMetadata => entityMetadata.tableType === \"entity-child\")\n            .forEach(entityMetadata => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));\n\n        // calculate entity metadata computed properties and all its sub-metadatas\n        entityMetadatas.forEach(entityMetadata => this.computeEntityMetadataStep2(entityMetadata));\n\n        // calculate entity metadata's inverse properties\n        entityMetadatas.forEach(entityMetadata => this.computeInverseProperties(entityMetadata, entityMetadatas));\n\n        // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n        entityMetadatas\n            .filter(entityMetadata => entityMetadata.tableType !== \"entity-child\")\n            .forEach(entityMetadata => {\n\n                // create entity's relations join columns (for many-to-one and one-to-one owner)\n                entityMetadata.relations.filter(relation => relation.isOneToOne || relation.isManyToOne).forEach(relation => {\n                    const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\n                    const { foreignKey, columns, uniqueConstraint } = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args\n                    if (foreignKey) {\n                        relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\n                        entityMetadata.foreignKeys.push(foreignKey);\n                    }\n                    if (columns) {\n                        relation.registerJoinColumns(columns);\n                    }\n                    if (uniqueConstraint) {\n                        if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver\n                            || this.connection.driver instanceof SqlServerDriver || this.connection.driver instanceof SapDriver) {\n                            const index = new IndexMetadata({\n                                entityMetadata: uniqueConstraint.entityMetadata,\n                                columns: uniqueConstraint.columns,\n                                args: {\n                                    target: uniqueConstraint.target!,\n                                    name: uniqueConstraint.name,\n                                    unique: true,\n                                    synchronize: true\n                                }\n                            });\n\n                            if (this.connection.driver instanceof SqlServerDriver) {\n                                index.where = index.columns.map(column => {\n                                    return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;\n                                }).join(\" AND \");\n                            }\n\n                            if (relation.embeddedMetadata) {\n                                relation.embeddedMetadata.indices.push(index);\n                            } else {\n                                relation.entityMetadata.ownIndices.push(index);\n                            }\n                            this.computeEntityMetadataStep2(entityMetadata);\n\n                        } else {\n                            if (relation.embeddedMetadata) {\n                                relation.embeddedMetadata.uniques.push(uniqueConstraint);\n                            } else {\n                                relation.entityMetadata.ownUniques.push(uniqueConstraint);\n                            }\n                            this.computeEntityMetadataStep2(entityMetadata);\n                        }\n                    }\n\n                    if (foreignKey && this.connection.driver instanceof CockroachDriver) {\n                        const index = new IndexMetadata({\n                            entityMetadata: relation.entityMetadata,\n                            columns: foreignKey.columns,\n                            args: {\n                                target: relation.entityMetadata.target!,\n                                synchronize: true\n                            }\n                        });\n                        if (relation.embeddedMetadata) {\n                            relation.embeddedMetadata.indices.push(index);\n                        } else {\n                            relation.entityMetadata.ownIndices.push(index);\n                        }\n                        this.computeEntityMetadataStep2(entityMetadata);\n                    }\n                });\n\n                // create junction entity metadatas for entity many-to-many relations\n                entityMetadata.relations.filter(relation => relation.isManyToMany).forEach(relation => {\n                    const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName)!;\n                    if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\n\n                    // here we create a junction entity metadata for a new junction table of many-to-many relation\n                    const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);\n                    relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);\n                    relation.registerJoinColumns(\n                        junctionEntityMetadata.ownIndices[0].columns,\n                        junctionEntityMetadata.ownIndices[1].columns\n                    );\n                    relation.registerJunctionEntityMetadata(junctionEntityMetadata);\n\n                    // compute new entity metadata properties and push it to entity metadatas pool\n                    this.computeEntityMetadataStep2(junctionEntityMetadata);\n                    this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\n                    entityMetadatas.push(junctionEntityMetadata);\n                });\n\n        });\n\n        // update entity metadata depend properties\n        entityMetadatas\n            .forEach(entityMetadata => {\n                entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(relation => relation.isWithJoinColumn);\n                entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(relation => !relation.isNullable || relation.isPrimary);\n            });\n\n        // generate closure junction tables for all closure tables\n        entityMetadatas\n            .filter(metadata => metadata.treeType === \"closure-table\")\n            .forEach(entityMetadata => {\n                const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\n                entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;\n                this.computeEntityMetadataStep2(closureJunctionEntityMetadata);\n                this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\n                entityMetadatas.push(closureJunctionEntityMetadata);\n            });\n\n        // generate keys for tables with single-table inheritance\n        entityMetadatas\n            .filter(metadata => metadata.inheritancePattern === \"STI\" && metadata.discriminatorColumn)\n            .forEach(entityMetadata => this.createKeysForTableInheritance(entityMetadata));\n\n        // build all indices (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.indices.forEach(index => index.build(this.connection.namingStrategy));\n        });\n\n        // build all unique constraints (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.uniques.forEach(unique => unique.build(this.connection.namingStrategy));\n        });\n\n        // build all check constraints\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.checks.forEach(check => check.build(this.connection.namingStrategy));\n        });\n\n        // build all exclusion constraints\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.exclusions.forEach(exclusion => exclusion.build(this.connection.namingStrategy));\n        });\n\n        // add lazy initializer for entity relations\n        entityMetadatas\n            .filter(metadata => metadata.target instanceof Function)\n            .forEach(entityMetadata => {\n                entityMetadata.relations\n                    .filter(relation => relation.isLazy)\n                    .forEach(relation => {\n                        this.connection.relationLoader.enableLazyLoad(relation, (entityMetadata.target as Function).prototype);\n                    });\n            });\n\n        entityMetadatas.forEach(entityMetadata => {\n            entityMetadata.columns.forEach(column => {\n                // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n                const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);\n                if (generated) {\n                    column.isGenerated = true;\n                    column.generationStrategy = generated.strategy;\n                    if (generated.strategy === \"uuid\") {\n                        column.type = \"uuid\";\n                    } else if (generated.strategy === \"rowid\") {\n                        column.type = \"int\";\n                    } else {\n                        column.type = column.type || Number;\n                    }\n                    column.build(this.connection);\n                    this.computeEntityMetadataStep2(entityMetadata);\n                }\n            });\n\n        });\n\n        return entityMetadatas;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates entity metadata from the given table args.\n     * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n     */\n    protected createEntityMetadata(tableArgs: TableMetadataArgs): EntityMetadata {\n\n        // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n        // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n        // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n        const inheritanceTree: any[] = tableArgs.target instanceof Function\n            ? MetadataUtils.getInheritanceTree(tableArgs.target)\n            : [tableArgs.target]; // todo: implement later here inheritance for string-targets\n\n        const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\n        const tableTree = this.metadataArgsStorage.findTree(tableArgs.target);\n\n        // if single table inheritance used, we need to copy all children columns in to parent table\n        let singleTableChildrenTargets: any[];\n        if ((tableInheritance && tableInheritance.pattern === \"STI\") || tableArgs.type === \"entity-child\") {\n            singleTableChildrenTargets = this.metadataArgsStorage\n                .filterSingleTableChildren(tableArgs.target)\n                .map(args => args.target)\n                .filter(target => target instanceof Function);\n\n            inheritanceTree.push(...singleTableChildrenTargets);\n        }\n\n        return new EntityMetadata({\n            connection: this.connection,\n            args: tableArgs,\n            inheritanceTree: inheritanceTree,\n            tableTree: tableTree,\n            inheritancePattern: tableInheritance ? tableInheritance.pattern : undefined\n        });\n    }\n\n    protected computeParentEntityMetadata(allEntityMetadatas: EntityMetadata[], entityMetadata: EntityMetadata) {\n\n        // after all metadatas created we set parent entity metadata for table inheritance\n        if (entityMetadata.tableType === \"entity-child\") {\n            entityMetadata.parentEntityMetadata = allEntityMetadatas.find(allEntityMetadata => {\n                return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target as Function) !== -1 && allEntityMetadata.inheritancePattern === \"STI\";\n            })!;\n        }\n    }\n\n    protected computeEntityMetadataStep1(allEntityMetadatas: EntityMetadata[], entityMetadata: EntityMetadata) {\n\n        const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);\n\n        const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);\n\n        if (typeof discriminatorValue !== \"undefined\") {\n            entityMetadata.discriminatorValue = discriminatorValue.value;\n        } else {\n            entityMetadata.discriminatorValue = (entityMetadata.target as any).name;\n        }\n\n        // if single table inheritance is used, we need to mark all embedded columns as nullable\n        entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree))\n            .map((embedded: EmbeddedMetadata): EmbeddedMetadata => {\n                 if (entityMetadata.inheritancePattern === \"STI\") {\n                     embedded.columns = embedded.columns.map((column: ColumnMetadata): ColumnMetadata => {\n                         column.isNullable = true;\n                         return column;\n                     });\n                 }\n                 return embedded;\n            });\n\n        entityMetadata.ownColumns = this.metadataArgsStorage\n            .filterColumns(entityMetadata.inheritanceTree)\n            .map(args => {\n\n                // for single table children we reuse columns created for their parents\n                if (entityMetadata.tableType === \"entity-child\")\n                    return entityMetadata.parentEntityMetadata.ownColumns.find(column => column.propertyName === args.propertyName)!;\n\n                const column = new ColumnMetadata({ connection: this.connection, entityMetadata, args });\n\n                // if single table inheritance used, we need to mark all inherit table columns as nullable\n                const columnInSingleTableInheritedChild = allEntityMetadatas.find(otherEntityMetadata => otherEntityMetadata.tableType === \"entity-child\" && otherEntityMetadata.target === args.target);\n                if (columnInSingleTableInheritedChild)\n                    column.isNullable = true;\n                return column;\n            });\n\n        // for table inheritance we need to add a discriminator column\n        //\n        if (entityInheritance && entityInheritance.column) {\n            const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : \"type\";\n            let discriminatorColumn = entityMetadata.ownColumns.find(column => column.propertyName === discriminatorColumnName);\n            if (!discriminatorColumn) {\n                discriminatorColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: entityMetadata.target,\n                        mode: \"virtual\",\n                        propertyName: discriminatorColumnName,\n                        options: entityInheritance.column || {\n                            name: discriminatorColumnName,\n                            type: \"varchar\",\n                            nullable: false\n                        }\n                    }\n                });\n                discriminatorColumn.isVirtual = true;\n                discriminatorColumn.isDiscriminator = true;\n                entityMetadata.ownColumns.push(discriminatorColumn);\n            } else {\n                discriminatorColumn.isDiscriminator = true;\n            }\n        }\n\n        // add discriminator column to the child entity metadatas\n        // discriminator column will not be there automatically since we are creating it in the code above\n        if (entityMetadata.tableType === \"entity-child\") {\n            const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find(column => column.isDiscriminator);\n            if (discriminatorColumn && !entityMetadata.ownColumns.find(column => column === discriminatorColumn)) {\n                entityMetadata.ownColumns.push(discriminatorColumn);\n            }\n        }\n\n        const { namingStrategy } = this.connection;\n\n        // check if tree is used then we need to add extra columns for specific tree types\n        if (entityMetadata.treeType === \"materialized-path\") {\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                materializedPath: true,\n                args: {\n                    target: entityMetadata.target,\n                    mode: \"virtual\",\n                    propertyName: \"mpath\",\n                    options: /*tree.column || */ {\n                        name: namingStrategy.materializedPathColumnName,\n                        type: \"varchar\",\n                        nullable: true,\n                        default: \"\"\n                    }\n                }\n            }));\n\n        } else if (entityMetadata.treeType === \"nested-set\") {\n            const { left, right } = namingStrategy.nestedSetColumnNames;\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                nestedSetLeft: true,\n                args: {\n                    target: entityMetadata.target,\n                    mode: \"virtual\",\n                    propertyName: left,\n                    options: /*tree.column || */ {\n                        name: left,\n                        type: \"integer\",\n                        nullable: false,\n                        default: 1\n                    }\n                }\n            }));\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                nestedSetRight: true,\n                args: {\n                    target: entityMetadata.target,\n                    mode: \"virtual\",\n                    propertyName: right,\n                    options: /*tree.column || */ {\n                        name: right,\n                        type: \"integer\",\n                        nullable: false,\n                        default: 2\n                    }\n                }\n            }));\n        }\n\n        entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map(args => {\n\n            // for single table children we reuse relations created for their parents\n            if (entityMetadata.tableType === \"entity-child\") {\n                const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find(relation => relation.propertyName === args.propertyName)!;\n                const type = args.type instanceof Function ? (args.type as () => any)() : args.type;\n                if (parentRelation.type !== type) {\n                    const clone = Object.create(parentRelation);\n                    clone.type = type;\n                    return clone;\n                }\n\n                return parentRelation;\n            }\n\n            return new RelationMetadata({ entityMetadata, args });\n        });\n        entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map(args => {\n\n            // for single table children we reuse relation ids created for their parents\n            if (entityMetadata.tableType === \"entity-child\")\n                return entityMetadata.parentEntityMetadata.relationIds.find(relationId => relationId.propertyName === args.propertyName)!;\n\n            return new RelationIdMetadata({ entityMetadata, args });\n        });\n        entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map(args => {\n\n            // for single table children we reuse relation counts created for their parents\n            if (entityMetadata.tableType === \"entity-child\")\n                return entityMetadata.parentEntityMetadata.relationCounts.find(relationCount => relationCount.propertyName === args.propertyName)!;\n\n            return new RelationCountMetadata({ entityMetadata, args });\n        });\n        entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map(args => {\n            return new EntityListenerMetadata({ entityMetadata: entityMetadata, args: args });\n        });\n        entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map(args => {\n            return new CheckMetadata({ entityMetadata, args });\n        });\n\n        // Only PostgreSQL supports exclusion constraints.\n        if (this.connection.driver instanceof PostgresDriver) {\n            entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map(args => {\n                return new ExclusionMetadata({ entityMetadata, args });\n            });\n        }\n\n        if (this.connection.driver instanceof CockroachDriver) {\n            entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree)\n                .filter(args => !args.unique)\n                .map(args => {\n                    return new IndexMetadata({entityMetadata, args});\n                });\n\n            const uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree)\n                .filter(args => args.unique)\n                .map(args => {\n                    return new UniqueMetadata({\n                        entityMetadata: entityMetadata,\n                        args: {\n                            target: args.target,\n                            name: args.name,\n                            columns: args.columns,\n                        }\n                    });\n                });\n            entityMetadata.ownUniques.push(...uniques);\n\n        } else {\n            entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map(args => {\n                return new IndexMetadata({entityMetadata, args});\n            });\n        }\n\n        // Mysql and SAP HANA stores unique constraints as unique indices.\n        if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof AuroraDataApiDriver || this.connection.driver instanceof SapDriver) {\n            const indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(args => {\n                return new IndexMetadata({\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: args.target,\n                        name: args.name,\n                        columns: args.columns,\n                        unique: true,\n                        synchronize: true\n                    }\n                });\n            });\n            entityMetadata.ownIndices.push(...indices);\n\n        } else {\n            const uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(args => {\n                return new UniqueMetadata({ entityMetadata, args });\n            });\n            entityMetadata.ownUniques.push(...uniques);\n        }\n    }\n\n    /**\n     * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n     * and does the same for all its sub-embeddeds (goes recursively).\n     */\n    protected createEmbeddedsRecursively(entityMetadata: EntityMetadata, embeddedArgs: EmbeddedMetadataArgs[]): EmbeddedMetadata[] {\n        return embeddedArgs.map(embeddedArgs => {\n            const embeddedMetadata = new EmbeddedMetadata({ entityMetadata: entityMetadata, args: embeddedArgs });\n            const targets = MetadataUtils.getInheritanceTree(embeddedMetadata.type);\n\n            embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map(args => {\n                return new ColumnMetadata({ connection: this.connection, entityMetadata, embeddedMetadata, args});\n            });\n            embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map(args => {\n                return new RelationMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map(args => {\n                return new EntityListenerMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map(args => {\n                return new IndexMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.uniques = this.metadataArgsStorage.filterUniques(targets).map(args => {\n                return new UniqueMetadata({ entityMetadata, embeddedMetadata, args });\n            });\n            embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map(args => {\n                return new RelationIdMetadata({ entityMetadata, args });\n            });\n            embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map(args => {\n                return new RelationCountMetadata({ entityMetadata, args });\n            });\n            embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));\n            embeddedMetadata.embeddeds.forEach(subEmbedded => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);\n            entityMetadata.allEmbeddeds.push(embeddedMetadata);\n            return embeddedMetadata;\n        });\n    }\n\n    /**\n     * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n     */\n    protected computeEntityMetadataStep2(entityMetadata: EntityMetadata) {\n        entityMetadata.embeddeds.forEach(embedded => embedded.build(this.connection));\n        entityMetadata.embeddeds.forEach(embedded => {\n            embedded.columnsFromTree.forEach(column => column.build(this.connection));\n            embedded.relationsFromTree.forEach(relation => relation.build());\n        });\n        entityMetadata.ownColumns.forEach(column => column.build(this.connection));\n        entityMetadata.ownRelations.forEach(relation => relation.build());\n        entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);\n        entityMetadata.eagerRelations = entityMetadata.relations.filter(relation => relation.isEager);\n        entityMetadata.lazyRelations = entityMetadata.relations.filter(relation => relation.isLazy);\n        entityMetadata.oneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOne);\n        entityMetadata.oneToManyRelations = entityMetadata.relations.filter(relation => relation.isOneToMany);\n        entityMetadata.manyToOneRelations = entityMetadata.relations.filter(relation => relation.isManyToOne);\n        entityMetadata.manyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToMany);\n        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOneOwner);\n        entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToManyOwner);\n        entityMetadata.treeParentRelation = entityMetadata.relations.find(relation => relation.isTreeParent);\n        entityMetadata.treeChildrenRelation = entityMetadata.relations.find(relation => relation.isTreeChildren);\n        entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);\n        entityMetadata.listeners = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.listenersFromTree), entityMetadata.ownListeners);\n        entityMetadata.afterLoadListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_LOAD);\n        entityMetadata.afterInsertListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_INSERT);\n        entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_UPDATE);\n        entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_REMOVE);\n        entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_INSERT);\n        entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_UPDATE);\n        entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_REMOVE);\n        entityMetadata.indices = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.indicesFromTree), entityMetadata.ownIndices);\n        entityMetadata.uniques = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);\n        entityMetadata.primaryColumns = entityMetadata.columns.filter(column => column.isPrimary);\n        entityMetadata.nonVirtualColumns = entityMetadata.columns.filter(column => !column.isVirtual);\n        entityMetadata.ancestorColumns = entityMetadata.columns.filter(column => column.closureType === \"ancestor\");\n        entityMetadata.descendantColumns = entityMetadata.columns.filter(column => column.closureType === \"descendant\");\n        entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;\n        entityMetadata.generatedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.isObjectId);\n        entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n        entityMetadata.createDateColumn = entityMetadata.columns.find(column => column.isCreateDate);\n        entityMetadata.updateDateColumn = entityMetadata.columns.find(column => column.isUpdateDate);\n        entityMetadata.deleteDateColumn = entityMetadata.columns.find(column => column.isDeleteDate);\n        entityMetadata.versionColumn = entityMetadata.columns.find(column => column.isVersion);\n        entityMetadata.discriminatorColumn = entityMetadata.columns.find(column => column.isDiscriminator);\n        entityMetadata.treeLevelColumn = entityMetadata.columns.find(column => column.isTreeLevel);\n        entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find(column => column.isNestedSetLeft);\n        entityMetadata.nestedSetRightColumn = entityMetadata.columns.find(column => column.isNestedSetRight);\n        entityMetadata.materializedPathColumn = entityMetadata.columns.find(column => column.isMaterializedPath);\n        entityMetadata.objectIdColumn = entityMetadata.columns.find(column => column.isObjectId);\n        entityMetadata.foreignKeys.forEach(foreignKey => foreignKey.build(this.connection.namingStrategy));\n        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\n        entityMetadata.relationIds.forEach(relationId => relationId.build());\n        entityMetadata.relationCounts.forEach(relationCount => relationCount.build());\n        entityMetadata.embeddeds.forEach(embedded => {\n            embedded.relationIdsFromTree.forEach(relationId => relationId.build());\n            embedded.relationCountsFromTree.forEach(relationCount => relationCount.build());\n        });\n    }\n\n    /**\n     * Computes entity metadata's relations inverse side properties.\n     */\n    protected computeInverseProperties(entityMetadata: EntityMetadata, entityMetadatas: EntityMetadata[]) {\n        entityMetadata.relations.forEach(relation => {\n\n            // compute inverse side (related) entity metadatas for all relation metadatas\n            const inverseEntityMetadata = entityMetadatas.find(m => m.target === relation.type || (typeof relation.type === \"string\" && (m.targetName === relation.type || m.givenTableName === relation.type)));\n            if (!inverseEntityMetadata)\n                throw new Error(\"Entity metadata for \" + entityMetadata.name + \"#\" + relation.propertyPath + \" was not found. Check if you specified a correct entity object and if it's connected in the connection options.\");\n\n            relation.inverseEntityMetadata = inverseEntityMetadata;\n            relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();\n\n            // and compute inverse relation and mark if it has such\n            relation.inverseRelation = inverseEntityMetadata.relations.find(foundRelation => foundRelation.propertyPath === relation.inverseSidePropertyPath);\n        });\n    }\n\n    /**\n     * Creates indices for the table of single table inheritance.\n     */\n    protected createKeysForTableInheritance(entityMetadata: EntityMetadata) {\n        entityMetadata.indices.push(\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.discriminatorColumn!],\n                args: {\n                    target: entityMetadata.target,\n                    unique: false\n                }\n            }),\n        );\n    }\n\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"module"}