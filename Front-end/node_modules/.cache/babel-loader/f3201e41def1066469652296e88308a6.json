{"ast":null,"code":"/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nvar PlainObjectToNewEntityTransformer =\n/** @class */\nfunction () {\n  function PlainObjectToNewEntityTransformer() {} // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  PlainObjectToNewEntityTransformer.prototype.transform = function (newEntity, object, metadata, getLazyRelationsPromiseValue) {\n    if (getLazyRelationsPromiseValue === void 0) {\n      getLazyRelationsPromiseValue = false;\n    } // console.log(\"groupAndTransform entity:\", newEntity);\n    // console.log(\"groupAndTransform object:\", object);\n\n\n    this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue); // console.log(\"result:\", newEntity);\n\n    return newEntity;\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n\n\n  PlainObjectToNewEntityTransformer.prototype.groupAndTransform = function (entity, object, metadata, getLazyRelationsPromiseValue) {\n    // console.log(\"groupAndTransform entity:\", entity);\n    // console.log(\"groupAndTransform object:\", object);\n    var _this = this;\n\n    if (getLazyRelationsPromiseValue === void 0) {\n      getLazyRelationsPromiseValue = false;\n    } // copy regular column properties from the given object\n\n\n    metadata.nonVirtualColumns.forEach(function (column) {\n      var objectColumnValue = column.getEntityValue(object);\n      if (objectColumnValue !== undefined) column.setEntityValue(entity, objectColumnValue);\n    }); // // copy relation properties from the given object\n\n    if (metadata.relations.length) {\n      metadata.relations.forEach(function (relation) {\n        var entityRelatedValue = relation.getEntityValue(entity);\n        var objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n        if (objectRelatedValue === undefined) return;\n\n        if (relation.isOneToMany || relation.isManyToMany) {\n          if (!Array.isArray(objectRelatedValue)) return;\n\n          if (!entityRelatedValue) {\n            entityRelatedValue = [];\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n\n          objectRelatedValue.forEach(function (objectRelatedValueItem) {\n            // check if we have this item from the merging object in the original entity we merge into\n            var objectRelatedValueEntity = entityRelatedValue.find(function (entityRelatedValueItem) {\n              return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n            }); // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n\n            if (!objectRelatedValueEntity) {\n              objectRelatedValueEntity = relation.inverseEntityMetadata.create();\n              entityRelatedValue.push(objectRelatedValueEntity);\n            }\n\n            _this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n          });\n        } else {\n          // if related object isn't an object (direct relation id for example)\n          // we just set it to the entity relation, we don't need anything more from it\n          // however we do it only if original entity does not have this relation set to object\n          // to prevent full overriding of objects\n          if (!(objectRelatedValue instanceof Object)) {\n            if (!(entityRelatedValue instanceof Object)) relation.setEntityValue(entity, objectRelatedValue);\n            return;\n          }\n\n          if (!entityRelatedValue) {\n            entityRelatedValue = relation.inverseEntityMetadata.create();\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n\n          _this.groupAndTransform(entityRelatedValue, objectRelatedValue, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n        }\n      });\n    }\n  };\n\n  return PlainObjectToNewEntityTransformer;\n}();\n\nexport { PlainObjectToNewEntityTransformer };","map":{"version":3,"sources":["../browser/src/query-builder/transformer/PlainObjectToNewEntityTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform<T>(newEntity: T, object: ObjectLiteral, metadata: EntityMetadata, getLazyRelationsPromiseValue: boolean = false): T {\n        // console.log(\"groupAndTransform entity:\", newEntity);\n        // console.log(\"groupAndTransform object:\", object);\n        this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);\n        // console.log(\"result:\", newEntity);\n        return newEntity;\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(entity: ObjectLiteral, object: ObjectLiteral, metadata: EntityMetadata, getLazyRelationsPromiseValue: boolean = false): void {\n\n        // console.log(\"groupAndTransform entity:\", entity);\n        // console.log(\"groupAndTransform object:\", object);\n\n        // copy regular column properties from the given object\n        metadata.nonVirtualColumns.forEach(column => {\n            const objectColumnValue = column.getEntityValue(object);\n            if (objectColumnValue !== undefined)\n                column.setEntityValue(entity, objectColumnValue);\n        });\n\n        // // copy relation properties from the given object\n        if (metadata.relations.length) {\n            metadata.relations.forEach(relation => {\n\n                let entityRelatedValue = relation.getEntityValue(entity);\n                const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n                if (objectRelatedValue === undefined)\n                    return;\n\n                if (relation.isOneToMany || relation.isManyToMany) {\n                    if (!Array.isArray(objectRelatedValue))\n                        return;\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = [];\n                        relation.setEntityValue(entity, entityRelatedValue);\n                    }\n\n                    objectRelatedValue.forEach(objectRelatedValueItem => {\n\n                        // check if we have this item from the merging object in the original entity we merge into\n                        let objectRelatedValueEntity = (entityRelatedValue as any[]).find(entityRelatedValueItem => {\n                            return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n                        });\n\n                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n                        if (!objectRelatedValueEntity) {\n                            objectRelatedValueEntity = relation.inverseEntityMetadata.create();\n                            entityRelatedValue.push(objectRelatedValueEntity);\n                        }\n\n                        this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n                    });\n\n                } else {\n\n                    // if related object isn't an object (direct relation id for example)\n                    // we just set it to the entity relation, we don't need anything more from it\n                    // however we do it only if original entity does not have this relation set to object\n                    // to prevent full overriding of objects\n                    if (!(objectRelatedValue instanceof Object)) {\n                        if (!(entityRelatedValue instanceof Object))\n                            relation.setEntityValue(entity, objectRelatedValue);\n                        return;\n                    }\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = relation.inverseEntityMetadata.create();\n                        relation.setEntityValue(entity, entityRelatedValue);\n                    }\n\n                    this.groupAndTransform(entityRelatedValue, objectRelatedValue, relation.inverseEntityMetadata, getLazyRelationsPromiseValue);\n                }\n            });\n        }\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}