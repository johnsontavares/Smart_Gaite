{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\n/**\n * Builds operations needs to be executed for one-to-many relations of the given subjects.\n *\n * by example: post contains one-to-many relation with category in the property called \"categories\", e.g.\n *             @OneToMany(type => Category, category => category.post) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\n\nvar OneToManySubjectBuilder =\n/** @class */\nfunction () {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  function OneToManySubjectBuilder(subjects) {\n    this.subjects = subjects;\n  } // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds all required operations.\n   */\n\n\n  OneToManySubjectBuilder.prototype.build = function () {\n    var _this = this;\n\n    this.subjects.forEach(function (subject) {\n      subject.metadata.oneToManyRelations.forEach(function (relation) {\n        // skip relations for which persistence is disabled\n        if (relation.persistenceEnabled === false) return;\n\n        _this.buildForSubjectRelation(subject, relation);\n      });\n    });\n  }; // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n\n  /**\n   * Builds operations for a given subject and relation.\n   *\n   * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n   */\n\n\n  OneToManySubjectBuilder.prototype.buildForSubjectRelation = function (subject, relation) {\n    var _this = this; // prepare objects (relation id maps) for the database entity\n    // note: subject.databaseEntity contains relations with loaded relation ids only\n    // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,\n    //             particularly their relation ids, e.g. category ids stored in the database\n\n\n    var relatedEntityDatabaseRelationIds = [];\n\n    if (subject.databaseEntity) {\n      // related entities in the database can exist only if this entity (post) is saved\n      relatedEntityDatabaseRelationIds = relation.getEntityValue(subject.databaseEntity);\n    } // get related entities of persisted entity\n    // by example: get categories from the passed to persist post entity\n\n\n    var relatedEntities = relation.getEntityValue(subject.entity);\n    if (relatedEntities === null) // we treat relations set to null as removed, so we don't skip it\n      relatedEntities = [];\n    if (relatedEntities === undefined) // if relation is undefined then nothing to update\n      return; // extract only relation ids from the related entities, since we only need them for comparision\n    // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)\n\n    var relatedPersistedEntityRelationIds = [];\n    relatedEntities.forEach(function (relatedEntity) {\n      var relationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }\n      // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n\n      var relatedEntitySubject = _this.subjects.find(function (subject) {\n        return subject.entity === relatedEntity;\n      }); // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n\n\n      if (relatedEntitySubject) relationIdMap = relatedEntitySubject.identifier; // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n      // by example: if post contains categories which does not have ids yet (because they are new)\n      //             it means they are always newly inserted and relation update operation always must be created for them\n      //             it does not make sense to perform difference operation for them for both add and remove actions\n\n      if (!relationIdMap) {\n        // we decided to remove this error because it brings complications when saving object with non-saved entities\n        // if (!relatedEntitySubject)\n        //     throw new Error(`One-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n        //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n        //         `Please setup cascade insertion or save entities before binding it.`);\n        if (!relatedEntitySubject) return; // okay, so related subject exist and its marked for insertion, then add a new change map\n        // by example: this will tell category to insert into its post relation our post we are working with\n        //             relatedEntitySubject is newly inserted CategorySubject\n        //             relation.inverseRelation is ManyToOne relation inside Category\n        //             subject is Post needs to be inserted into Category\n\n        relatedEntitySubject.changeMaps.push({\n          relation: relation.inverseRelation,\n          value: subject\n        });\n        return;\n      } // check if this binding really exist in the database\n      // by example: find our category if its already bind in the database\n\n\n      var relationIdInDatabaseSubjectRelation = relatedEntityDatabaseRelationIds.find(function (relatedDatabaseEntityRelationId) {\n        return OrmUtils.compareIds(relationIdMap, relatedDatabaseEntityRelationId);\n      }); // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to \"bind\" them\n      // by example: this will tell category to insert into its post relation our post we are working with\n      //             relatedEntitySubject is newly inserted CategorySubject\n      //             relation.inverseRelation is ManyToOne relation inside Category\n      //             subject is Post needs to be inserted into Category\n\n      if (!relationIdInDatabaseSubjectRelation) {\n        // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n        // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n        // we create a new subject here:\n        if (!relatedEntitySubject) {\n          relatedEntitySubject = new Subject({\n            metadata: relation.inverseEntityMetadata,\n            parentSubject: subject,\n            canBeUpdated: true,\n            identifier: relationIdMap\n          });\n\n          _this.subjects.push(relatedEntitySubject);\n        }\n\n        relatedEntitySubject.changeMaps.push({\n          relation: relation.inverseRelation,\n          value: subject\n        });\n      } // if related entity has relation id then we add it to the list of relation ids\n      // this list will be used later to compare with database relation ids to find a difference\n      // what exist in this array and does not exist in the database are newly inserted relations\n      // what does not exist in this array, but exist in the database are removed relations\n      // removed relations are set to null from inverse side of relation\n\n\n      relatedPersistedEntityRelationIds.push(relationIdMap);\n    }); // find what related entities were added and what were removed based on difference between what we save and what database has\n\n    EntityMetadata.difference(relatedEntityDatabaseRelationIds, relatedPersistedEntityRelationIds).forEach(function (removedRelatedEntityRelationId) {\n      // todo: probably we can improve this in the future by finding entity with column those values,\n      // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n      // we create a new subject which operations will be executed in subject operation executor\n      var removedRelatedEntitySubject = new Subject({\n        metadata: relation.inverseEntityMetadata,\n        parentSubject: subject,\n        identifier: removedRelatedEntityRelationId\n      });\n\n      if (!relation.inverseRelation || relation.inverseRelation.orphanedRowAction === \"nullify\") {\n        removedRelatedEntitySubject.canBeUpdated = true;\n        removedRelatedEntitySubject.changeMaps = [{\n          relation: relation.inverseRelation,\n          value: null\n        }];\n      } else if (relation.inverseRelation.orphanedRowAction === \"delete\") {\n        removedRelatedEntitySubject.mustBeRemoved = true;\n      }\n\n      _this.subjects.push(removedRelatedEntitySubject);\n    });\n  };\n\n  return OneToManySubjectBuilder;\n}();\n\nexport { OneToManySubjectBuilder };","map":{"version":3,"sources":["../browser/src/persistence/subject-builder/OneToManySubjectBuilder.ts"],"names":[],"mappings":"AAAA,SAAQ,OAAR,QAAsB,YAAtB;AACA,SAAQ,QAAR,QAAuB,qBAAvB;AAEA,SAAQ,cAAR,QAA6B,+BAA7B;AAGA;;;;;;;;;;AAUG;;AACH,IAAA,uBAAA;AAAA;AAAA,YAAA;AAEI;AACA;AACA;AAEA,WAAA,uBAAA,CAAsB,QAAtB,EAAyC;AAAnB,SAAA,QAAA,GAAA,QAAA;AACrB,GAPL,CASI;AACA;AACA;;AAEA;;AAEG;;;AACH,EAAA,uBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACI,SAAK,QAAL,CAAc,OAAd,CAAsB,UAAA,OAAA,EAAO;AACzB,MAAA,OAAO,CAAC,QAAR,CAAiB,kBAAjB,CAAoC,OAApC,CAA4C,UAAA,QAAA,EAAQ;AAEhD;AACA,YAAI,QAAQ,CAAC,kBAAT,KAAgC,KAApC,EACI;;AAEJ,QAAA,KAAI,CAAC,uBAAL,CAA6B,OAA7B,EAAsC,QAAtC;AACH,OAPD;AAQH,KATD;AAUH,GAXD,CAhBJ,CA6BI;AACA;AACA;;AAEA;;;;AAIG;;;AACO,EAAA,uBAAA,CAAA,SAAA,CAAA,uBAAA,GAAV,UAAkC,OAAlC,EAAoD,QAApD,EAA8E;AAA9E,QAAA,KAAA,GAAA,IAAA,CAA8E,CAE1E;AACA;AACA;AACA;;;AACA,QAAI,gCAAgC,GAAoB,EAAxD;;AACA,QAAI,OAAO,CAAC,cAAZ,EAA4B;AAAE;AAC1B,MAAA,gCAAgC,GAAG,QAAQ,CAAC,cAAT,CAAwB,OAAO,CAAC,cAAhC,CAAnC;AACH,KATyE,CAW1E;AACA;;;AACA,QAAI,eAAe,GAAoB,QAAQ,CAAC,cAAT,CAAwB,OAAO,CAAC,MAAhC,CAAvC;AACA,QAAI,eAAe,KAAK,IAAxB,EAA8B;AAC1B,MAAA,eAAe,GAAG,EAAlB;AACJ,QAAI,eAAe,KAAK,SAAxB,EAAmC;AAC/B,aAjBsE,CAmB1E;AACA;;AACA,QAAM,iCAAiC,GAAoB,EAA3D;AACA,IAAA,eAAe,CAAC,OAAhB,CAAwB,UAAA,aAAA,EAAa;AACjC,UAAI,aAAa,GAAG,QAAQ,CAAC,qBAAT,CAAgC,cAAhC,CAA+C,aAA/C,CAApB,CADiC,CACkD;AAEnF;;AACA,UAAI,oBAAoB,GAAG,KAAI,CAAC,QAAL,CAAc,IAAd,CAAmB,UAAA,OAAA,EAAO;AACjD,eAAO,OAAO,CAAC,MAAR,KAAmB,aAA1B;AACH,OAF0B,CAA3B,CAJiC,CAQjC;;;AACA,UAAI,oBAAJ,EACI,aAAa,GAAG,oBAAoB,CAAC,UAArC,CAV6B,CAYjC;AACA;AACA;AACA;;AACA,UAAI,CAAC,aAAL,EAAoB;AAEhB;AACA;AACA;AACA;AACA;AACA,YAAI,CAAC,oBAAL,EACI,OARY,CAUhB;AACA;AACA;AACA;AACA;;AACA,QAAA,oBAAoB,CAAC,UAArB,CAAgC,IAAhC,CAAqC;AACjC,UAAA,QAAQ,EAAE,QAAQ,CAAC,eADc;AAEjC,UAAA,KAAK,EAAE;AAF0B,SAArC;AAKA;AACH,OArCgC,CAuCjC;AACA;;;AACA,UAAM,mCAAmC,GAAG,gCAAgC,CAAC,IAAjC,CAAsC,UAAA,+BAAA,EAA+B;AAC7G,eAAO,QAAQ,CAAC,UAAT,CAAoB,aAApB,EAAmC,+BAAnC,CAAP;AACH,OAF2C,CAA5C,CAzCiC,CA6CjC;AACA;AACA;AACA;AACA;;AACA,UAAI,CAAC,mCAAL,EAA0C;AAEtC;AACA;AACA;AACA,YAAI,CAAC,oBAAL,EAA2B;AACvB,UAAA,oBAAoB,GAAG,IAAI,OAAJ,CAAY;AAC/B,YAAA,QAAQ,EAAE,QAAQ,CAAC,qBADY;AAE/B,YAAA,aAAa,EAAE,OAFgB;AAG/B,YAAA,YAAY,EAAE,IAHiB;AAI/B,YAAA,UAAU,EAAE;AAJmB,WAAZ,CAAvB;;AAMA,UAAA,KAAI,CAAC,QAAL,CAAc,IAAd,CAAmB,oBAAnB;AACH;;AAED,QAAA,oBAAoB,CAAC,UAArB,CAAgC,IAAhC,CAAqC;AACjC,UAAA,QAAQ,EAAE,QAAQ,CAAC,eADc;AAEjC,UAAA,KAAK,EAAE;AAF0B,SAArC;AAIH,OArEgC,CAuEjC;AACA;AACA;AACA;AACA;;;AACA,MAAA,iCAAiC,CAAC,IAAlC,CAAuC,aAAvC;AACH,KA7ED,EAtB0E,CAqG1E;;AACA,IAAA,cAAc,CACT,UADL,CACgB,gCADhB,EACkD,iCADlD,EAEK,OAFL,CAEa,UAAA,8BAAA,EAA8B;AAEnC;AACA;AACA;AACA,UAAM,2BAA2B,GAAG,IAAI,OAAJ,CAAY;AAC5C,QAAA,QAAQ,EAAE,QAAQ,CAAC,qBADyB;AAE5C,QAAA,aAAa,EAAE,OAF6B;AAG5C,QAAA,UAAU,EAAE;AAHgC,OAAZ,CAApC;;AAMA,UAAI,CAAC,QAAQ,CAAC,eAAV,IAA6B,QAAQ,CAAC,eAAT,CAAyB,iBAAzB,KAA+C,SAAhF,EAA2F;AACvF,QAAA,2BAA2B,CAAC,YAA5B,GAA2C,IAA3C;AACA,QAAA,2BAA2B,CAAC,UAA5B,GAAyC,CAAC;AACtC,UAAA,QAAQ,EAAE,QAAQ,CAAC,eADmB;AAEtC,UAAA,KAAK,EAAE;AAF+B,SAAD,CAAzC;AAIH,OAND,MAMO,IAAI,QAAQ,CAAC,eAAT,CAAyB,iBAAzB,KAA+C,QAAnD,EAA6D;AAChE,QAAA,2BAA2B,CAAC,aAA5B,GAA4C,IAA5C;AACH;;AAED,MAAA,KAAI,CAAC,QAAL,CAAc,IAAd,CAAmB,2BAAnB;AACH,KAxBL;AAyBH,GA/HS;;AAiId,SAAA,uBAAA;AAAC,CAvKD,EAAA","sourcesContent":["import {Subject} from \"../Subject\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {RelationMetadata} from \"../../metadata/RelationMetadata\";\n\n/**\n * Builds operations needs to be executed for one-to-many relations of the given subjects.\n *\n * by example: post contains one-to-many relation with category in the property called \"categories\", e.g.\n *             @OneToMany(type => Category, category => category.post) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\nexport class OneToManySubjectBuilder {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds all required operations.\n     */\n    build(): void {\n        this.subjects.forEach(subject => {\n            subject.metadata.oneToManyRelations.forEach(relation => {\n\n                // skip relations for which persistence is disabled\n                if (relation.persistenceEnabled === false)\n                    return;\n\n                this.buildForSubjectRelation(subject, relation);\n            });\n        });\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n     */\n    protected buildForSubjectRelation(subject: Subject, relation: RelationMetadata) {\n\n        // prepare objects (relation id maps) for the database entity\n        // note: subject.databaseEntity contains relations with loaded relation ids only\n        // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,\n        //             particularly their relation ids, e.g. category ids stored in the database\n        let relatedEntityDatabaseRelationIds: ObjectLiteral[] = [];\n        if (subject.databaseEntity) { // related entities in the database can exist only if this entity (post) is saved\n            relatedEntityDatabaseRelationIds = relation.getEntityValue(subject.databaseEntity);\n        }\n\n        // get related entities of persisted entity\n        // by example: get categories from the passed to persist post entity\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(subject.entity!);\n        if (relatedEntities === null) // we treat relations set to null as removed, so we don't skip it\n            relatedEntities = [] as ObjectLiteral[];\n        if (relatedEntities === undefined) // if relation is undefined then nothing to update\n            return;\n\n        // extract only relation ids from the related entities, since we only need them for comparision\n        // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)\n        const relatedPersistedEntityRelationIds: ObjectLiteral[] = [];\n        relatedEntities.forEach(relatedEntity => { // by example: relatedEntity is a category here\n            let relationIdMap = relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity); // by example: relationIdMap is category.id map here, e.g. { id: ... }\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            let relatedEntitySubject = this.subjects.find(subject => {\n                return subject.entity === relatedEntity;\n            });\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relationIdMap = relatedEntitySubject.identifier;\n\n            // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n            // by example: if post contains categories which does not have ids yet (because they are new)\n            //             it means they are always newly inserted and relation update operation always must be created for them\n            //             it does not make sense to perform difference operation for them for both add and remove actions\n            if (!relationIdMap) {\n\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if (!relatedEntitySubject)\n                //     throw new Error(`One-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n                //         `Please setup cascade insertion or save entities before binding it.`);\n                if (!relatedEntitySubject)\n                    return;\n\n                // okay, so related subject exist and its marked for insertion, then add a new change map\n                // by example: this will tell category to insert into its post relation our post we are working with\n                //             relatedEntitySubject is newly inserted CategorySubject\n                //             relation.inverseRelation is ManyToOne relation inside Category\n                //             subject is Post needs to be inserted into Category\n                relatedEntitySubject.changeMaps.push({\n                    relation: relation.inverseRelation!,\n                    value: subject\n                });\n\n                return;\n            }\n\n            // check if this binding really exist in the database\n            // by example: find our category if its already bind in the database\n            const relationIdInDatabaseSubjectRelation = relatedEntityDatabaseRelationIds.find(relatedDatabaseEntityRelationId => {\n                return OrmUtils.compareIds(relationIdMap, relatedDatabaseEntityRelationId);\n            });\n\n            // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to \"bind\" them\n            // by example: this will tell category to insert into its post relation our post we are working with\n            //             relatedEntitySubject is newly inserted CategorySubject\n            //             relation.inverseRelation is ManyToOne relation inside Category\n            //             subject is Post needs to be inserted into Category\n            if (!relationIdInDatabaseSubjectRelation) {\n\n                // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n                // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n                // we create a new subject here:\n                if (!relatedEntitySubject) {\n                    relatedEntitySubject = new Subject({\n                        metadata: relation.inverseEntityMetadata,\n                        parentSubject: subject,\n                        canBeUpdated: true,\n                        identifier: relationIdMap\n                    });\n                    this.subjects.push(relatedEntitySubject);\n                }\n\n                relatedEntitySubject.changeMaps.push({\n                    relation: relation.inverseRelation!,\n                    value: subject\n                });\n            }\n\n            // if related entity has relation id then we add it to the list of relation ids\n            // this list will be used later to compare with database relation ids to find a difference\n            // what exist in this array and does not exist in the database are newly inserted relations\n            // what does not exist in this array, but exist in the database are removed relations\n            // removed relations are set to null from inverse side of relation\n            relatedPersistedEntityRelationIds.push(relationIdMap);\n        });\n\n        // find what related entities were added and what were removed based on difference between what we save and what database has\n        EntityMetadata\n            .difference(relatedEntityDatabaseRelationIds, relatedPersistedEntityRelationIds)\n            .forEach(removedRelatedEntityRelationId => { // by example: removedRelatedEntityRelationId is category that was bind in the database before, but now its unbind\n\n                // todo: probably we can improve this in the future by finding entity with column those values,\n                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n                // we create a new subject which operations will be executed in subject operation executor\n                const removedRelatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    parentSubject: subject,\n                    identifier: removedRelatedEntityRelationId,\n                });\n\n                if (!relation.inverseRelation || relation.inverseRelation.orphanedRowAction === \"nullify\") {\n                    removedRelatedEntitySubject.canBeUpdated = true;\n                    removedRelatedEntitySubject.changeMaps = [{\n                        relation: relation.inverseRelation!,\n                        value: null\n                    }];\n                } else if (relation.inverseRelation.orphanedRowAction === \"delete\") {\n                    removedRelatedEntitySubject.mustBeRemoved = true;\n                }\n\n                this.subjects.push(removedRelatedEntitySubject);\n            });\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}