{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\n/**\n * Organizes communication with sqlite DBMS.\n */\n\nvar AbstractSqliteDriver =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function AbstractSqliteDriver(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n\n    this.treeSupport = true;\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm\n     * @see https://sqlite.org/datatype3.html\n     */\n\n    this.supportedDataTypes = [\"int\", \"integer\", \"tinyint\", \"smallint\", \"mediumint\", \"bigint\", \"unsigned big int\", \"int2\", \"int8\", \"integer\", \"character\", \"varchar\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"clob\", \"text\", \"blob\", \"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\", \"boolean\", \"date\", \"time\", \"datetime\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n\n    this.withLengthColumnTypes = [\"character\", \"varchar\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"blob\", \"clob\"];\n    /**\n     * Gets list of spatial column data types.\n     */\n\n    this.spatialTypes = [];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n\n    this.withPrecisionColumnTypes = [\"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\", \"date\", \"time\", \"datetime\"];\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n\n    this.withScaleColumnTypes = [\"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\"];\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n\n    this.mappedDataTypes = {\n      createDate: \"datetime\",\n      createDateDefault: \"datetime('now')\",\n      updateDate: \"datetime\",\n      updateDateDefault: \"datetime('now')\",\n      deleteDate: \"datetime\",\n      deleteDateNullable: true,\n      version: \"integer\",\n      treeLevel: \"integer\",\n      migrationId: \"integer\",\n      migrationName: \"varchar\",\n      migrationTimestamp: \"bigint\",\n      cacheId: \"int\",\n      cacheIdentifier: \"varchar\",\n      cacheTime: \"bigint\",\n      cacheDuration: \"int\",\n      cacheQuery: \"text\",\n      cacheResult: \"text\",\n      metadataType: \"varchar\",\n      metadataDatabase: \"varchar\",\n      metadataSchema: \"varchar\",\n      metadataTable: \"varchar\",\n      metadataName: \"varchar\",\n      metadataValue: \"text\"\n    };\n    this.connection = connection;\n    this.options = connection.options;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Performs connection to the database.\n   */\n\n\n  AbstractSqliteDriver.prototype.connect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this;\n            return [4\n            /*yield*/\n            , this.createDatabaseConnection()];\n\n          case 1:\n            _a.databaseConnection = _b.sent();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n\n\n  AbstractSqliteDriver.prototype.afterConnect = function () {\n    return Promise.resolve();\n  };\n  /**\n   * Closes connection with database.\n   */\n\n\n  AbstractSqliteDriver.prototype.disconnect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (ok, fail) {\n          _this.queryRunner = undefined;\n\n          _this.databaseConnection.close(function (err) {\n            return err ? fail(err) : ok();\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n\n\n  AbstractSqliteDriver.prototype.createSchemaBuilder = function () {\n    return new RdbmsSchemaBuilder(this.connection);\n  };\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n\n\n  AbstractSqliteDriver.prototype.preparePersistentValue = function (value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n      return value === true ? 1 : 0;\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      return DateUtils.mixedDateToTimeString(value);\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      // to string conversation needs because SQLite stores date as integer number, when date came as Object\n      // TODO: think about `toUTC` conversion\n      return DateUtils.mixedDateToUtcDatetimeString(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      return DateUtils.simpleArrayToString(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      return DateUtils.simpleJsonToString(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      return DateUtils.simpleEnumToString(value);\n    }\n\n    return value;\n  };\n  /**\n   * Prepares given value to a value to be hydrated, based on its column type or metadata.\n   */\n\n\n  AbstractSqliteDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      /**\n       * Fix date conversion issue\n       *\n       * If the format of the date string is \"2018-03-14 02:33:33.906\", Safari (and iOS WKWebView) will convert it to an invalid date object.\n       * We need to modify the date string to \"2018-03-14T02:33:33.906Z\" and Safari will convert it correctly.\n       *\n       * ISO 8601\n       * https://www.w3.org/TR/NOTE-datetime\n       */\n      if (value && typeof value === \"string\") {\n        // There are various valid time string formats a sqlite time string might have:\n        // https://www.sqlite.org/lang_datefunc.html\n        // There are two separate fixes we may need to do:\n        //   1) Add 'T' separator if space is used instead\n        //   2) Add 'Z' UTC suffix if no timezone or offset specified\n        if (/^\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d/.test(value)) {\n          value = value.replace(\" \", \"T\");\n        }\n\n        if (/^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d\\d\\d)?)?$/.test(value)) {\n          value += \"Z\";\n        }\n      }\n\n      value = DateUtils.normalizeHydratedDate(value);\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      value = DateUtils.mixedTimeToString(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      value = DateUtils.stringToSimpleArray(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      value = DateUtils.stringToSimpleJson(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      value = DateUtils.stringToSimpleEnum(value, columnMetadata);\n    }\n\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  };\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n\n\n  AbstractSqliteDriver.prototype.escapeQueryWithParameters = function (sql, parameters, nativeParameters) {\n    var builtParameters = Object.keys(nativeParameters).map(function (key) {\n      // Mapping boolean values to their numeric representation\n      if (typeof nativeParameters[key] === \"boolean\") {\n        return nativeParameters[key] === true ? 1 : 0;\n      }\n\n      return nativeParameters[key];\n    });\n    if (!parameters || !Object.keys(parameters).length) return [sql, builtParameters];\n    var keys = Object.keys(parameters).map(function (parameter) {\n      return \"(:(\\\\.\\\\.\\\\.)?\" + parameter + \"\\\\b)\";\n    }).join(\"|\");\n    sql = sql.replace(new RegExp(keys, \"g\"), function (key) {\n      var value;\n      var isArray = false;\n\n      if (key.substr(0, 4) === \":...\") {\n        isArray = true;\n        value = parameters[key.substr(4)];\n      } else {\n        value = parameters[key.substr(1)];\n      }\n\n      if (isArray) {\n        return value.map(function (v) {\n          builtParameters.push(v);\n          return \"?\"; // return \"$\" + builtParameters.length;\n        }).join(\", \");\n      } else if (value instanceof Function) {\n        return value();\n      } else {\n        builtParameters.push(value);\n        return \"?\"; // return \"$\" + builtParameters.length;\n      }\n    }); // todo: make replace only in value statements, otherwise problems\n\n    return [sql, builtParameters];\n  };\n  /**\n   * Escapes a column name.\n   */\n\n\n  AbstractSqliteDriver.prototype.escape = function (columnName) {\n    return \"\\\"\" + columnName + \"\\\"\";\n  };\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. \"myDB\".\"mySchema\".\"myTable\"\n   *\n   * Returns only simple table name because all inherited drivers does not supports schema and database.\n   */\n\n\n  AbstractSqliteDriver.prototype.buildTableName = function (tableName, schema, database) {\n    return tableName;\n  };\n  /**\n   * Creates a database type from a given column metadata.\n   */\n\n\n  AbstractSqliteDriver.prototype.normalizeType = function (column) {\n    if (column.type === Number || column.type === \"int\") {\n      return \"integer\";\n    } else if (column.type === String) {\n      return \"varchar\";\n    } else if (column.type === Date) {\n      return \"datetime\";\n    } else if (column.type === Boolean) {\n      return \"boolean\";\n    } else if (column.type === \"uuid\") {\n      return \"varchar\";\n    } else if (column.type === \"simple-array\") {\n      return \"text\";\n    } else if (column.type === \"simple-json\") {\n      return \"text\";\n    } else if (column.type === \"simple-enum\") {\n      return \"varchar\";\n    } else {\n      return column.type || \"\";\n    }\n  };\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n\n\n  AbstractSqliteDriver.prototype.normalizeDefault = function (columnMetadata) {\n    var defaultValue = columnMetadata.default;\n\n    if (typeof defaultValue === \"number\") {\n      return \"\" + defaultValue;\n    } else if (typeof defaultValue === \"boolean\") {\n      return defaultValue === true ? \"1\" : \"0\";\n    } else if (typeof defaultValue === \"function\") {\n      return defaultValue();\n    } else if (typeof defaultValue === \"string\") {\n      return \"'\" + defaultValue + \"'\";\n    } else if (defaultValue === null) {\n      return undefined;\n    } else {\n      return defaultValue;\n    }\n  };\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n\n\n  AbstractSqliteDriver.prototype.normalizeIsUnique = function (column) {\n    return column.entityMetadata.uniques.some(function (uq) {\n      return uq.columns.length === 1 && uq.columns[0] === column;\n    });\n  };\n  /**\n   * Calculates column length taking into account the default length values.\n   */\n\n\n  AbstractSqliteDriver.prototype.getColumnLength = function (column) {\n    return column.length ? column.length.toString() : \"\";\n  };\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n\n\n  AbstractSqliteDriver.prototype.createFullType = function (column) {\n    var type = column.type;\n\n    if (column.enum) {\n      return \"varchar\";\n    }\n\n    if (column.length) {\n      type += \"(\" + column.length + \")\";\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += \"(\" + column.precision + \",\" + column.scale + \")\";\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += \"(\" + column.precision + \")\";\n    }\n\n    if (column.isArray) type += \" array\";\n    return type;\n  };\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n\n\n  AbstractSqliteDriver.prototype.obtainMasterConnection = function () {\n    return Promise.resolve();\n  };\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n\n\n  AbstractSqliteDriver.prototype.obtainSlaveConnection = function () {\n    return Promise.resolve();\n  };\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n\n\n  AbstractSqliteDriver.prototype.createGeneratedMap = function (metadata, insertResult, entityIndex, entityNum) {\n    var generatedMap = metadata.generatedColumns.reduce(function (map, generatedColumn) {\n      var value;\n\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult) {\n        // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.\n        // see also: SqliteQueryRunner.query()\n        value = insertResult - entityNum + entityIndex + 1; // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     value = insertValue[generatedColumn.databaseName];\n      }\n\n      if (!value) return map;\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  };\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n\n\n  AbstractSqliteDriver.prototype.findChangedColumns = function (tableColumns, columnMetadatas) {\n    var _this = this;\n\n    return columnMetadatas.filter(function (columnMetadata) {\n      var tableColumn = tableColumns.find(function (c) {\n        return c.name === columnMetadata.databaseName;\n      });\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n      // console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n      // console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n      // console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n      // console.log(\"length:\", tableColumn.length, columnMetadata.length);\n      // console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n      // console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n      // console.log(\"comment:\", tableColumn.comment, columnMetadata.comment);\n      // console.log(\"default:\", this.normalizeDefault(columnMetadata), columnMetadata.default);\n      // console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n      // console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n      // console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n      // console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n      // console.log(\"==========================================\");\n\n      return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== _this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale //  || tableColumn.comment !== columnMetadata.comment || // todo\n      || _this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== _this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated;\n    });\n  };\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n\n\n  AbstractSqliteDriver.prototype.isReturningSqlSupported = function () {\n    return false;\n  };\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n\n\n  AbstractSqliteDriver.prototype.isUUIDGenerationSupported = function () {\n    return false;\n  };\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n\n\n  AbstractSqliteDriver.prototype.isFullTextColumnTypeSupported = function () {\n    return false;\n  };\n  /**\n   * Creates an escaped parameter.\n   */\n\n\n  AbstractSqliteDriver.prototype.createParameter = function (parameterName, index) {\n    // return \"$\" + (index + 1);\n    return \"?\"; // return \"$\" + parameterName;\n  }; // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Creates connection with the database.\n   */\n\n\n  AbstractSqliteDriver.prototype.createDatabaseConnection = function () {\n    throw new Error(\"Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers\");\n  };\n  /**\n   * If driver dependency is not given explicitly, then try to load it via \"require\".\n   */\n\n\n  AbstractSqliteDriver.prototype.loadDependencies = function () {// dependencies have to be loaded in the specific driver\n  };\n\n  return AbstractSqliteDriver;\n}();\n\nexport { AbstractSqliteDriver };","map":{"version":3,"sources":["../browser/src/driver/sqlite-abstract/AbstractSqliteDriver.ts"],"names":[],"mappings":"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","sourcesContent":["import {Driver} from \"../Driver\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\nimport {DateUtils} from \"../../util/DateUtils\";\nimport {Connection} from \"../../connection/Connection\";\nimport {RdbmsSchemaBuilder} from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport {MappedColumnTypes} from \"../types/MappedColumnTypes\";\nimport {ColumnType} from \"../types/ColumnTypes\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {DataTypeDefaults} from \"../types/DataTypeDefaults\";\nimport {TableColumn} from \"../../schema-builder/table/TableColumn\";\nimport {BaseConnectionOptions} from \"../../connection/BaseConnectionOptions\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {ApplyValueTransformers} from \"../../util/ApplyValueTransformers\";\nimport {ReplicationMode} from \"../types/ReplicationMode\";\n\n/**\n * Organizes communication with sqlite DBMS.\n */\nexport abstract class AbstractSqliteDriver implements Driver {\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: Connection;\n\n    /**\n     * Sqlite has a single QueryRunner because it works on a single database connection.\n     */\n    queryRunner?: QueryRunner;\n\n    /**\n     * Real database connection with sqlite database.\n     */\n    databaseConnection: any;\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: BaseConnectionOptions;\n\n    /**\n     * Master database used to perform all write queries.\n     */\n    database?: string;\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false;\n\n    /**\n     * SQLite underlying library.\n     */\n    sqlite: any;\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true;\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm\n     * @see https://sqlite.org/datatype3.html\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"int\",\n        \"integer\",\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"bigint\",\n        \"unsigned big int\",\n        \"int2\",\n        \"int8\",\n        \"integer\",\n        \"character\",\n        \"varchar\",\n        \"varying character\",\n        \"nchar\",\n        \"native character\",\n        \"nvarchar\",\n        \"text\",\n        \"clob\",\n        \"text\",\n        \"blob\",\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n        \"boolean\",\n        \"date\",\n        \"time\",\n        \"datetime\"\n    ];\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"character\",\n        \"varchar\",\n        \"varying character\",\n        \"nchar\",\n        \"native character\",\n        \"nvarchar\",\n        \"text\",\n        \"blob\",\n        \"clob\"\n    ];\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = [];\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n        \"date\",\n        \"time\",\n        \"datetime\"\n    ];\n\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n    ];\n\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime\",\n        createDateDefault: \"datetime('now')\",\n        updateDate: \"datetime\",\n        updateDateDefault: \"datetime('now')\",\n        deleteDate: \"datetime\",\n        deleteDateNullable: true,\n        version: \"integer\",\n        treeLevel: \"integer\",\n        migrationId: \"integer\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"varchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"text\",\n        cacheResult: \"text\",\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"text\",\n    };\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults;\n\n    /**\n     * No documentation specifying a maximum length for identifiers could be found\n     * for SQLite.\n     */\n    maxAliasLength?: number;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: Connection) {\n        this.connection = connection;\n        this.options = connection.options as BaseConnectionOptions;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Abstract\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    abstract createQueryRunner(mode: ReplicationMode): QueryRunner;\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        this.databaseConnection = await this.createDatabaseConnection();\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Closes connection with database.\n     */\n    async disconnect(): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.queryRunner = undefined;\n            this.databaseConnection.close((err: any) => err ? fail(err) : ok());\n        });\n    }\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection);\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n\n        if (value === null || value === undefined)\n            return value;\n\n        if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n            return value === true ? 1 : 0;\n\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value);\n\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedDateToTimeString(value);\n\n        } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n            // to string conversation needs because SQLite stores date as integer number, when date came as Object\n            // TODO: think about `toUTC` conversion\n            return DateUtils.mixedDateToUtcDatetimeString(value);\n\n        } else if (columnMetadata.type === \"simple-array\") {\n            return DateUtils.simpleArrayToString(value);\n\n        } else if (columnMetadata.type === \"simple-json\") {\n            return DateUtils.simpleJsonToString(value);\n        } else if (columnMetadata.type === \"simple-enum\") {\n            return DateUtils.simpleEnumToString(value);\n        }\n\n        return value;\n    }\n\n    /**\n     * Prepares given value to a value to be hydrated, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n\n        if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n            value = value ? true : false;\n\n        } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n            /**\n             * Fix date conversion issue\n             *\n             * If the format of the date string is \"2018-03-14 02:33:33.906\", Safari (and iOS WKWebView) will convert it to an invalid date object.\n             * We need to modify the date string to \"2018-03-14T02:33:33.906Z\" and Safari will convert it correctly.\n             *\n             * ISO 8601\n             * https://www.w3.org/TR/NOTE-datetime\n             */\n            if (value && typeof value === \"string\") {\n                // There are various valid time string formats a sqlite time string might have:\n                // https://www.sqlite.org/lang_datefunc.html\n                // There are two separate fixes we may need to do:\n                //   1) Add 'T' separator if space is used instead\n                //   2) Add 'Z' UTC suffix if no timezone or offset specified\n\n                if (/^\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d/.test(value)) {\n                    value = value.replace(\" \", \"T\");\n                }\n                if (/^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d\\d\\d)?)?$/.test(value)) {\n                    value += \"Z\";\n                }\n            }\n\n            value = DateUtils.normalizeHydratedDate(value);\n\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value);\n\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value);\n\n        } else if (columnMetadata.type === \"simple-array\") {\n            value = DateUtils.stringToSimpleArray(value);\n\n        } else if (columnMetadata.type === \"simple-json\") {\n            value = DateUtils.stringToSimpleJson(value);\n\n        } else if ( columnMetadata.type === \"simple-enum\" ) {\n            value = DateUtils.stringToSimpleEnum(value, columnMetadata);\n\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n\n        return value;\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(sql: string, parameters: ObjectLiteral, nativeParameters: ObjectLiteral): [string, any[]] {\n        const builtParameters: any[] = Object.keys(nativeParameters).map(key => {\n            // Mapping boolean values to their numeric representation\n            if (typeof nativeParameters[key] === \"boolean\") {\n                return nativeParameters[key] === true ? 1 : 0;\n            }\n\n            return nativeParameters[key];\n        });\n\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, builtParameters];\n\n        const keys = Object.keys(parameters).map(parameter => \"(:(\\\\.\\\\.\\\\.)?\" + parameter + \"\\\\b)\").join(\"|\");\n        sql = sql.replace(new RegExp(keys, \"g\"), (key: string): string => {\n            let value: any;\n            let isArray = false;\n            if (key.substr(0, 4) === \":...\") {\n                isArray = true;\n                value = parameters[key.substr(4)];\n            } else {\n                value = parameters[key.substr(1)];\n            }\n\n            if (isArray) {\n                return value.map((v: any) => {\n                    builtParameters.push(v);\n                    return \"?\";\n                    // return \"$\" + builtParameters.length;\n                }).join(\", \");\n\n            } else if (value instanceof Function) {\n                return value();\n\n            } else {\n                builtParameters.push(value);\n                return \"?\";\n                // return \"$\" + builtParameters.length;\n            }\n        }); // todo: make replace only in value statements, otherwise problems\n        return [sql, builtParameters];\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return \"\\\"\" + columnName + \"\\\"\";\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. \"myDB\".\"mySchema\".\"myTable\"\n     *\n     * Returns only simple table name because all inherited drivers does not supports schema and database.\n     */\n    buildTableName(tableName: string, schema?: string, database?: string): string {\n        return tableName;\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: { type?: ColumnType, length?: number | string, precision?: number|null, scale?: number }): string {\n        if (column.type === Number || column.type === \"int\") {\n            return \"integer\";\n\n        } else if (column.type === String) {\n            return \"varchar\";\n\n        } else if (column.type === Date) {\n            return \"datetime\";\n\n        } else if (column.type === Boolean) {\n            return \"boolean\";\n\n        } else if (column.type === \"uuid\") {\n            return \"varchar\";\n\n        } else if (column.type === \"simple-array\") {\n            return \"text\";\n\n        } else if (column.type === \"simple-json\") {\n            return \"text\";\n\n        } else if (column.type === \"simple-enum\") {\n            return \"varchar\";\n\n        } else {\n            return column.type as string || \"\";\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default;\n\n        if (typeof defaultValue === \"number\") {\n            return \"\" + defaultValue;\n\n        } else if (typeof defaultValue === \"boolean\") {\n            return defaultValue === true ? \"1\" : \"0\";\n\n        } else if (typeof defaultValue === \"function\") {\n            return defaultValue();\n\n        } else if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`;\n\n        } else if (defaultValue === null) {\n            return undefined;\n\n        } else {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.uniques.some(uq => uq.columns.length === 1 && uq.columns[0] === column);\n    }\n\n    /**\n     * Calculates column length taking into account the default length values.\n     */\n    getColumnLength(column: ColumnMetadata): string {\n        return column.length ? column.length.toString() : \"\";\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type;\n        if (column.enum) {\n            return \"varchar\";\n        }\n        if (column.length) {\n            type += \"(\" + column.length + \")\";\n\n        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n            type += \"(\" + column.precision + \",\" + column.scale + \")\";\n\n        } else if (column.precision !== null && column.precision !== undefined) {\n            type +=  \"(\" + column.precision + \")\";\n        }\n\n        if (column.isArray)\n            type += \" array\";\n\n        return type;\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(metadata: EntityMetadata, insertResult: any, entityIndex: number, entityNum: number) {\n        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n            let value: any;\n            if (generatedColumn.generationStrategy === \"increment\" && insertResult) {\n                // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.\n                // see also: SqliteQueryRunner.query()\n                value = insertResult - entityNum + entityIndex + 1;\n            // } else if (generatedColumn.generationStrategy === \"uuid\") {\n            //     value = insertValue[generatedColumn.databaseName];\n            }\n\n            if (!value) return map;\n            return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n        }, {} as ObjectLiteral);\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(tableColumns: TableColumn[], columnMetadatas: ColumnMetadata[]): ColumnMetadata[] {\n        return columnMetadatas.filter(columnMetadata => {\n            const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n            if (!tableColumn)\n                return false; // we don't need new columns, we only need exist and changed\n\n            // console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n            // console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n            // console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n            // console.log(\"length:\", tableColumn.length, columnMetadata.length);\n            // console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n            // console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n            // console.log(\"comment:\", tableColumn.comment, columnMetadata.comment);\n            // console.log(\"default:\", this.normalizeDefault(columnMetadata), columnMetadata.default);\n            // console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n            // console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n            // console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n            // console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n            // console.log(\"==========================================\");\n\n            return tableColumn.name !== columnMetadata.databaseName\n                || tableColumn.type !== this.normalizeType(columnMetadata)\n                || tableColumn.length !== columnMetadata.length\n                || tableColumn.precision !== columnMetadata.precision\n                || tableColumn.scale !== columnMetadata.scale\n                //  || tableColumn.comment !== columnMetadata.comment || // todo\n                || this.normalizeDefault(columnMetadata) !== tableColumn.default\n                || tableColumn.isPrimary !== columnMetadata.isPrimary\n                || tableColumn.isNullable !== columnMetadata.isNullable\n                || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata)\n                || (columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated);\n        });\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        return false;\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false;\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false;\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        // return \"$\" + (index + 1);\n        return \"?\";\n        // return \"$\" + parameterName;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates connection with the database.\n     */\n    protected createDatabaseConnection() {\n        throw new Error(\"Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers\");\n    }\n\n    /**\n     * If driver dependency is not given explicitly, then try to load it via \"require\".\n     */\n    protected loadDependencies(): void {\n        // dependencies have to be loaded in the specific driver\n    }\n\n}\n"],"sourceRoot":"../.."},"metadata":{},"sourceType":"module"}