{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nexports.wrapInterop = wrapInterop;\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = _interopRequireDefault(require(\"./rewrite-this\"));\n\nvar _rewriteLiveReferences = _interopRequireDefault(require(\"./rewrite-live-references\"));\n\nvar _normalizeAndLoadMetadata = _interopRequireWildcard(require(\"./normalize-and-load-metadata\"));\n\nvar _getModuleName = _interopRequireDefault(require(\"./get-module-name\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst assert = require(\"assert\");\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, {\n  loose,\n  exportName,\n  strict,\n  allowTopLevelThis,\n  strictMode,\n  noInterop,\n  lazy,\n  esNamespaceOnly,\n  constantReexports = loose,\n  enumerableModuleMeta = loose\n}) {\n  assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    noInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", t.directive(t.directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return t.callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {\n  const statements = [];\n  let srcNamespace = t.identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = t.callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: t.cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: t.cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, t.cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: (0, _template.default)`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? t.callExpression(t.identifier(metadata.name), []) : t.identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT;\n\n    if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = t.memberExpression(t.cloneNode(namespace), t.stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = NAMESPACE_IMPORT = t.memberExpression(t.cloneNode(namespace), t.identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata, enumerableModuleMeta = false) {\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: t.variableDeclaration(\"var\", [t.variableDeclarator(name, t.valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata, constantReexports = false) {\n  const initStatements = [];\n  const exportNames = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push(buildInitStatement(metadata, data.names, t.identifier(localName)));\n    } else {\n      exportNames.push(...data.names);\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      initStatements.push(...buildReexportsFromMeta(metadata, data, false));\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportNames.push(exportName);\n    }\n  }\n\n  initStatements.push(...chunk(exportNames, 100).map(members => {\n    return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());\n  }));\n  return initStatements;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return t.expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}\n\nfunction chunk(array, size) {\n  const chunks = [];\n\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n\n  return chunks;\n}","map":{"version":3,"sources":["C:/Users/REINALDO/Desktop/ls-gait-web/dashboard/node_modules/@babel/helper-module-transforms/lib/index.js"],"names":["Object","defineProperty","exports","value","rewriteModuleStatementsAndPrepareHeader","ensureStatementsHoisted","wrapInterop","buildNamespaceInitStatements","enumerable","get","_helperModuleImports","isModule","_rewriteThis","default","_normalizeAndLoadMetadata","hasExports","isSideEffectImport","_getModuleName","t","_interopRequireWildcard","require","_template","_interopRequireDefault","_rewriteLiveReferences","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","assert","path","loose","exportName","strict","allowTopLevelThis","strictMode","noInterop","lazy","esNamespaceOnly","constantReexports","enumerableModuleMeta","node","sourceType","meta","initializeReexports","hasStrict","directives","some","directive","unshiftContainer","directiveLiteral","headers","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","statements","forEach","header","_blockHoist","programPath","expr","type","helper","Error","callExpression","hub","addHelper","metadata","sourceMetadata","srcNamespace","identifier","localName","importsNamespace","NAME","SOURCE","cloneNode","buildReexportsFromMeta","reexportNamespace","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","constantComputed","spec","namespace","stringSpecifiers","Array","from","reexports","importName","NAMESPACE_IMPORT","memberExpression","stringLiteral","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","variableDeclaration","variableDeclarator","valueToNode","initStatements","exportNames","kind","buildInitStatement","chunk","map","members","buildUndefinedNode","InitTemplate","computed","expression","initExpr","expressionStatement","reduce","acc","params","VALUE","array","size","chunks","i","slice"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nexports.wrapInterop = wrapInterop;\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = _interopRequireDefault(require(\"./rewrite-this\"));\n\nvar _rewriteLiveReferences = _interopRequireDefault(require(\"./rewrite-live-references\"));\n\nvar _normalizeAndLoadMetadata = _interopRequireWildcard(require(\"./normalize-and-load-metadata\"));\n\nvar _getModuleName = _interopRequireDefault(require(\"./get-module-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst assert = require(\"assert\");\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, {\n  loose,\n  exportName,\n  strict,\n  allowTopLevelThis,\n  strictMode,\n  noInterop,\n  lazy,\n  esNamespaceOnly,\n  constantReexports = loose,\n  enumerableModuleMeta = loose\n}) {\n  assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    noInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", t.directive(t.directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return t.callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {\n  const statements = [];\n  let srcNamespace = t.identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = t.callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: t.cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: t.cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, t.cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: (0, _template.default)`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? t.callExpression(t.identifier(metadata.name), []) : t.identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT;\n\n    if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = t.memberExpression(t.cloneNode(namespace), t.stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = NAMESPACE_IMPORT = t.memberExpression(t.cloneNode(namespace), t.identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata, enumerableModuleMeta = false) {\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: t.variableDeclaration(\"var\", [t.variableDeclarator(name, t.valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata, constantReexports = false) {\n  const initStatements = [];\n  const exportNames = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push(buildInitStatement(metadata, data.names, t.identifier(localName)));\n    } else {\n      exportNames.push(...data.names);\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      initStatements.push(...buildReexportsFromMeta(metadata, data, false));\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportNames.push(exportName);\n    }\n  }\n\n  initStatements.push(...chunk(exportNames, 100).map(members => {\n    return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());\n  }));\n  return initStatements;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return t.expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}\n\nfunction chunk(array, size) {\n  const chunks = [];\n\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n\n  return chunks;\n}"]},"metadata":{},"sourceType":"script"}