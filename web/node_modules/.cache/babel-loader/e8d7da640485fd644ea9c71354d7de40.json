{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperSimpleAccess = _interopRequireDefault(require(\"@babel/helper-simple-access\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst assert = require(\"assert\");\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = t.callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = t.identifier(meta.name);\n      if (meta.lazy) namespace = t.callExpression(namespace, []);\n      const computed = metadata.stringSpecifiers.has(importName);\n      return t.memberExpression(namespace, computed ? t.stringLiteral(importName) : t.identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return t.assignmentExpression(\"=\", t.memberExpression(t.identifier(metadata.exportName), computed ? t.stringLiteral(exportName) : t.identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && t.isMemberExpression(ref)) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(t.jsxMemberExpression(t.jsxIdentifier(object.name), t.jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          assert(path.node.operator === \"=\", \"Path was not simplified\");\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, t.identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = t.sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      scope: programScope\n    } = this;\n\n    if (!t.isVariableDeclaration(left)) {\n      let didTransform = false;\n      const bodyPath = path.get(\"body\");\n      const loopBodyScope = bodyPath.scope;\n\n      for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {\n        if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {\n          didTransform = true;\n\n          if (loopBodyScope.hasOwnBinding(name)) {\n            loopBodyScope.rename(name);\n          }\n        }\n      }\n\n      if (!didTransform) {\n        return;\n      }\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      bodyPath.unshiftContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)));\n      path.get(\"left\").replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Users/REINALDO/Desktop/ls-gait-web/dashboard/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"],"names":["Object","defineProperty","exports","value","default","rewriteLiveReferences","t","_interopRequireWildcard","require","_template","_interopRequireDefault","_helperSimpleAccess","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","assert","programPath","metadata","imported","Map","exported","requeueInParent","path","requeue","source","data","localName","importName","imports","importsNamespace","local","exportMeta","push","names","rewriteBindingInitVisitorState","scope","traverse","rewriteBindingInitVisitor","Set","Array","from","keys","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","lazy","callExpression","namespace","identifier","name","computed","stringSpecifiers","memberExpression","stringLiteral","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","expressionStatement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","getOuterBindingIdentifiers","forEach","localExpr","reduce","expr","exportName","assignmentExpression","buildImportThrow","expression","ast","ReferencedIdentifier","add","importData","localBinding","getBinding","rootBinding","ref","loc","parentPath","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","isMemberExpression","replaceWith","sequenceExpression","numericLiteral","isJSXIdentifier","object","property","jsxMemberExpression","jsxIdentifier","AssignmentExpression","exit","left","isIdentifier","exportedNames","operator","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","programScope","isVariableDeclaration","didTransform","bodyPath","loopBodyScope","hasOwnBinding","rename","newLoopId","generateUidIdentifierBasedOnNode","unshiftContainer","variableDeclaration","variableDeclarator","cloneNode","registerDeclaration"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperSimpleAccess = _interopRequireDefault(require(\"@babel/helper-simple-access\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst assert = require(\"assert\");\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = t.callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = t.identifier(meta.name);\n      if (meta.lazy) namespace = t.callExpression(namespace, []);\n      const computed = metadata.stringSpecifiers.has(importName);\n      return t.memberExpression(namespace, computed ? t.stringLiteral(importName) : t.identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return t.assignmentExpression(\"=\", t.memberExpression(t.identifier(metadata.exportName), computed ? t.stringLiteral(exportName) : t.identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && t.isMemberExpression(ref)) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(t.jsxMemberExpression(t.jsxIdentifier(object.name), t.jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          assert(path.node.operator === \"=\", \"Path was not simplified\");\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, t.identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = t.sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      scope: programScope\n    } = this;\n\n    if (!t.isVariableDeclaration(left)) {\n      let didTransform = false;\n      const bodyPath = path.get(\"body\");\n      const loopBodyScope = bodyPath.scope;\n\n      for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {\n        if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {\n          didTransform = true;\n\n          if (loopBodyScope.hasOwnBinding(name)) {\n            loopBodyScope.rename(name);\n          }\n        }\n      }\n\n      if (!didTransform) {\n        return;\n      }\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      bodyPath.unshiftContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)));\n      path.get(\"left\").replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n    }\n  }\n\n};"]},"metadata":{},"sourceType":"script"}